#Operating_Systems #OS_Processes 
## Основы планирования процессов
### Понятие планирования
**Планирование** — это процедура распределения ограниченных ресурсов вычислительной системы между конкурирующими процессами.

При предоставлении доступа к ограниченным ресурсам возникает необходимость в планировании доступа. В условиях многозадачности процессы конкурируют за главный ресурс — **процессорное время**.

**Планирование процессов** — это планирование доступа к процессору, то есть принятие решения о том, какой процесс получит право использовать процессор в данный момент времени.

### Цели планирования
Планирование должно иметь четко поставленные цели — результат распределения ресурса должен быть сформулирован. Для достижения поставленной цели создается **алгоритм планирования**.

Основные цели планирования зависят от типа системы и требований к ней.

---
## Уровни планирования

Всего различают три уровня планирования процессов в операционной системе:
1. **Долгосрочное планирование** (планирование заданий)
2. **Краткосрочное планирование** (планирование процессора)
3. **Среднесрочное планирование**

### 1. Планирование заданий (долгосрочное планирование)
**Планирование заданий** появилось в пакетных системах с началом использования магнитных дисков, когда задание стало возможно хранить на магнитном диске (а не в пакете из колод перфокарт или на перфоленте), и их можно было загружать в произвольном порядке.

**Планирование заданий** — процедура выбора задания для загрузки и исполнения, то есть для создания процесса.

**Долгосрочное планирование** - принятие решения о том, какой процесс будет создан из задания и загружен в оперативную память для исполнения.
#### Характеристики долгосрочного планирования:
- Отвечает за **создание новых процессов**
- Определяет **степень мультипрограммирования** (количество процессов в системе)
- Осуществляется **сравнительно редко**
- Оказывает **длительное влияние** на работу системы
- В некоторых системах (например, **интерактивных**) долгосрочное планирование **отсутствует**

### 2. Планирование процессора (краткосрочное планирование)
В мультизадачных вычислительных системах в состоянии готовности могут находиться несколько процессов одновременно.

**Планирование процессора** — процедура выбора процесса, которому будет предоставлено процессорное время.

**Краткосрочное планирование** — принятие решения о том, какой из готовых процессов будет выполняться на процессоре в данный момент времени.

#### Характеристики краткосрочного планирования:
- Проводится при **обращении к внешним устройствам**
- Осуществляется по **прерываниям таймера** (при переходе в состояние ожидания или готовности)
- Выполняется **не реже 1 раза в 100 мс**
- Выбор процесса оказывает влияние на работу системы **до следующего события** (прерывания). Это значит что процессор может быть выделен одному процессу на короткий промежуток времени.

### 3. Среднесрочное планирование
Иногда для освобождения оперативной памяти процессы, не исполняющиеся на процессоре, **выгружают на диск** (swap).

**Среднесрочное планирование** — принятие решения о том, какой процесс выгружается на диск, а какой загружается с диска в память.

Параметры среднесрочного планирования:
- Время с момента выгрузки на диск или загрузки в ОП
- Память, предоставленная процессу
- Затраченное процессорное время

---
## Критерии планирования
Выбор алгоритма планирования определяется **целями планирования**:
### 1. Справедливость (Fairness)
Гарантировать каждому заданию или процессу определенную часть времени использования процессора в компьютерной системе, стараясь не допустить возникновения ситуации, когда процесс одного пользователя постоянно занимает процессор, в то время как процесс другого пользователя фактически не начинал выполняться.
### 2. Эффективность (Efficiency)
Постараться занять процессор на все **100% рабочего времени**, не позволяя ему простаивать в ожидании процессов, готовых к исполнению. 

В реальных вычислительных системах загрузка процессора колеблется от **40% до 90%**.
### 3. Сокращение полного времени выполнения (Turnaround Time)
Обеспечить **минимальное время** между стартом процесса (или постановкой задания в очередь для загрузки) и его завершением.

**Turnaround time** = время завершения - время поступления
### 4. Сокращение времени ожидания (Waiting Time)
Сократить время, которое проводят процессы в **состоянии готовности** и задания в **очереди для загрузки**.
### 5. Сокращение времени отклика (Response Time)
Минимизировать время, которое требуется процессу в интерактивных системах для **ответа на запрос пользователя**.

---
## Желательные свойства алгоритмов планирования
При разработке алгоритмов планирования стремятся обеспечить следующие свойства:
### 1. Предсказуемость
Одно и то же задание исполняется примерно за одно и то же время независимо от загрузки системы.
### 2. Минимальные накладные расходы
Сам процесс планирования должен занимать минимальное время и ресурсы.
### 3. Равномерная загрузка ресурсов
Предпочтение процессам, занимающим малоиспользуемые ресурсы, чтобы обеспечить сбалансированное использование всех компонентов системы.
### 4. Масштабируемость
Сохранение работоспособности алгоритма при увеличении нагрузки на систему.

---
## Параметры планирования
Алгоритмы планирования учитывают характеристики процессов в системе, количество процессов, состояние системы — **параметры планирования**.

**Параметры планирования** — совокупность характеристик процессов и системы, используемых планировщиком для принятия решений о распределении процессорного времени.

Параметры планирования делятся на **статические** и **динамические**.
### - Статические параметры планирования
**Статические параметры** — это параметры, которые не изменяются в процессе исполнения процесса.
#### Параметры системы:
- Предельные значения ресурсов:
    - Размер оперативной памяти
    - Размер пространства выгрузки (swap)
    - Доступные устройства ввода-вывода
    - Максимальное количество процессов
#### Параметры процессов:
- Пользователь, запустивший процесс
- Приоритет исполнения
- Требуемое количество процессорного времени
- Требуемые ресурсы (память, устройства и т.д.)

### - Динамические параметры
**Динамические параметры** — это параметры, которые изменяются в процессе исполнения процесса.
#### Для системы:
- Количество свободных ресурсов на данный момент
#### Для процессов:
- Количество потребленных ресурсов на данный момент
- Количество требуемых ресурсов

### Использование параметров на разных уровнях
**Долгосрочное планирование** использует:
- Статические и динамические параметры системы
- Статические параметры процессов

**Краткосрочное планирование** использует:
- Все параметры долгосрочного планирования
- Динамические параметры процессов

**Среднесрочное планирование** использует:
- Время с момента выгрузки на диск или загрузки в ОП
- Память, предоставленная процессу
- Затраченное процессорное время

---
## Дополнительные параметры для краткосрочного планирования
### CPU Burst и I/O Burst
**CPU burst** — непрерывный период вычислений, потребление времени процессора без обращения к устройствам ввода-вывода.

**I/O burst** — время ожидания завершения операций ввода-вывода.

Процессы чередуют периоды CPU burst и I/O burst в течение своего жизненного цикла.
### Динамические параметры процесса:
- Продолжительность **последнего CPU burst**
- Оценка продолжительности **очередного CPU burst**
- Продолжительность **последнего I/O burst**
- Оценка продолжительности **очередного I/O burst**

Эти параметры позволяют классифицировать процессы на:
- **CPU-bound** (требующие много процессорного времени)
- **I/O-bound** (часто обращающиеся к устройствам ввода-вывода)
---
## Планировщик (Scheduler)
**Планировщик** — программа операционной системы, которая управляет миграцией процесса между различными очередями и принимает решения о выделении процессорного времени.
### Типы планировщиков
Операционная система, обеспечивающая режим мультипрограммирования, обычно включает два планировщика:
1. **Долгосрочный планировщик** (планировщик заданий)
   - Пример: в OS/360 назывался "планировщиком заданий"
   
2. **Краткосрочный планировщик** (диспетчер)
   - Пример: в OS/360 назывался "супервизором задач"

На уровень долгосрочного планирования выносятся:
- Редкие системные действия
- Действия, требующие больших затрат системных ресурсов

На уровень краткосрочного планирования выносятся:
- Частые процессы
- Более короткие процессы

На каждом уровне существует свой объект и собственные средства управления им.

---
## Моменты осуществления планирования
Планировщик может принимать решения о выборе нового процесса для исполнения из числа находящихся в состоянии готовности в следующих **четырех случаях**:
### Случай 1: Завершение процесса
Когда процесс переводится из состояния **исполнение** в состояние **закончил исполнение** (завершение).
### Случай 2: Переход в ожидание
Когда процесс переводится из состояния **исполнение** в состояние **ожидание** (например, при запросе операции ввода-вывода).
### Случай 3: Прерывание выполнения
Когда процесс переводится из состояния **исполнение** в состояние **готовность** (например, после прерывания от таймера).
### Случай 4: Завершение ожидания
Когда процесс переводится из состояния **ожидание** в состояние **готовность** (завершилась операция ввода-вывода или произошло другое событие).

---
## Вытесняющее и невытесняющее планирование
### Невытесняющее планирование (Nonpreemptive Scheduling)
В **случаях 1 и 2** процесс, находившийся в состоянии исполнение, не может дальше исполняться, и операционная система **вынуждена** осуществлять планирование, выбирая новый процесс для выполнения.

Если в операционной системе планирование осуществляется **только в вынужденных ситуациях**, говорят, что имеет место **невытесняющее планирование**.
#### Характеристики:
- Процесс выполняется до завершения или перехода в ожидание
- Не требует прерываний по таймеру
- Более простая реализация
- Может привести к монополизации процессора одним процессом
### Вытесняющее планирование (Preemptive Scheduling)
В **случаях 3 и 4** планирование может как проводиться, так и не проводиться. Планировщик не вынужден обязательно принимать решение о выборе процесса для выполнения — процесс, находившийся в состоянии исполнение, может просто продолжить свою работу.

Если планировщик принимает и **вынужденные**, и **невынужденные** решения, говорят о **вытесняющем планировании**.

**Вытесняющее планирование** - это планирование, при котором исполняющийся процесс может быть прерван и вытеснен из состояния исполнения другим процессом.

#### Характеристики:
- Исполняющийся процесс помимо своей воли может быть **вытеснен** из состояния исполнение другим процессом
- Требует механизма прерываний по таймеру
- Обеспечивает более справедливое распределение процессорного времени
- Повышает отзывчивость интерактивных систем
- Требует более сложной реализации
---
## Алгоритмы планирования процессов
### 1) First Come First Served (FCFS)
**Принцип работы:**
Процессы, находящиеся в состоянии готовности, выстраиваются в очередь по мере поступления. Когда процесс переходит в состояние готовности, он (а точнее, ссылка на его PCB) помещается в **конец очереди**.

Выбор нового процесса для исполнения осуществляется из **начала очереди** с удалением оттуда ссылки на его PCB. Очередь подобного типа имеет в программировании специальное наименование — **FIFO** (First In, First Out).

![[OS 26.png]]
#### Характеристики:
- **Невытесняющий алгоритм**
- Процесс, получивший в свое распоряжение процессор, занимает его столько, сколько ему необходимо
- После завершения для выполнения выбирается новый процесс из начала очереди

#### Пример:
Предположим, имеются три процесса P1, P2, P3 с временем выполнения:
- P1 = 24 мс
- P2 = 3 мс
- P3 = 3 мс

Если процессы прибывают в порядке P1, P2, P3:
- Среднее время ожидания = (0 + 24 + 27) / 3 = 17 мс

Если процессы прибывают в порядке P2, P3, P1:
- Среднее время ожидания = (0 + 3 + 6) / 3 = 3 мс

#### Преимущества:
- Простота реализации
- Отсутствие накладных расходов

#### Недостатки:
- Эффект **конвоя** — короткие процессы ждут за длинными
- Большое среднее время ожидания
- Низкая эффективность при смешанной нагрузке
---
### 2) Shortest Job First (SJF)
**Принцип работы:**
Если короткие задачи расположены в очереди ближе к ее началу, то общая производительность алгоритма значительно возрастает.

Если бы мы знали время следующих CPU burst для процессов, находящихся в состоянии готовности, то могли бы выбрать для исполнения не процесс из начала очереди, а **процесс с минимальной длительностью CPU burst**.

Если таких процессов два или больше, то для выбора одного из них можно использовать алгоритм FCFS.

![[OS 27.png]]
#### Характеристики:
- Может быть как **вытесняющим**, так и **невытесняющим**
- **Оптимален** по критерию минимизации среднего времени ожидания
- Требует знания или оценки времени выполнения процессов

#### Невытесняющая версия (SJF):
Процесс выполняется до завершения своего CPU burst, даже если появился процесс с меньшим временем выполнения.
#### Вытесняющая версия (SRTF - Shortest Remaining Time First):
Если появляется процесс с меньшим оставшимся временем выполнения, текущий процесс вытесняется.

#### Оценка времени выполнения:
Поскольку точное время следующего CPU burst обычно неизвестно, используются методы **прогнозирования** на основе истории:

τ(n+1) = α × t(n) + (1-α) × τ(n)

где:
- τ(n+1) — прогноз длительности следующего CPU burst
- t(n) — фактическая длительность n-го CPU burst
- α — коэффициент (0 ≤ α ≤ 1), обычно α = 0.5

#### Преимущества:
- Минимальное среднее время ожидания
- Высокая пропускная способность

#### Недостатки:
- Невозможность точного предсказания времени выполнения
- Риск **голодания** длинных процессов
- Усложнение реализации

**Голодание (Starvation)** — ситуация, когда процесс не может получить необходимые ресурсы в течение неопределенно долгого времени из-за постоянного появления процессов с более коротким временем выполнения.

---
### 3) Round Robin (RR) — Циклическое планирование
**Принцип работы:**
Можно представить себе все множество готовых процессов организованным **циклически** — процессы сидят на карусели. Карусель вращается так, что каждый процесс находится около процессора небольшой фиксированный **квант времени**, обычно **10-100 миллисекунд**.

Пока процесс находится рядом с процессором, он получает процессор в свое распоряжение и может исполняться.

Планировщик выбирает для очередного исполнения процесс, расположенный в **начале очереди**, и устанавливает таймер для генерации прерывания по истечении определенного кванта времени.

Если процесс завершает свой CPU burst до истечения кванта времени, он освобождает процессор, и планировщик выбирает следующий процесс из начала очереди.

![[OS 28.png]]
#### Характеристики:
- **Вытесняющий алгоритм**
- Каждый процесс получает равную долю процессорного времени
- Процессы выполняются по очереди
- Размер кванта времени — критический параметр

#### Влияние размера кванта:
**Квант слишком большой:**
- Алгоритм приближается к FCFS
- Ухудшается время отклика

**Квант слишком малый:**
- Увеличиваются накладные расходы на переключение контекста
- Снижается эффективность

**Оптимальный квант:**
- Обычно 10-100 мс
- 80% CPU burst должны быть короче кванта

#### Преимущества:
- Справедливое распределение времени
- Хорошее время отклика для интерактивных систем
- Отсутствие голодания процессов

#### Недостатки:
- Накладные расходы на переключение контекста
- Среднее время ожидания может быть больше, чем у SJF
- Требуется настройка размера кванта
---
### 4) Гарантированное планирование
**Принцип работы:**
При интерактивной работе **N пользователей** в вычислительной системе можно применить алгоритм планирования, который гарантирует, что каждый из пользователей будет иметь в своем распоряжении примерно **1/N часть** процессорного времени.

Пронумеруем всех пользователей от 1 до N.

Для каждого пользователя с номером i введем две величины:
- **Ti** — время нахождения пользователя в системе (длительность сеанса)
- **ti** — суммарное процессорное время, уже выделенное всем его процессам в течение сеанса

Справедливым для пользователя было бы получение **Ti/N** процессорного времени.

#### Анализ справедливости:

**Если ti << Ti/N:**
- i-й пользователь несправедливо **обделен** процессорным временем

**Если ti >> Ti/N:**
- Система явно **благоволит** к пользователю с номером i

#### Коэффициент справедливости:
Вычислим для процессов каждого пользователя значение **коэффициента справедливости**:

**Коэффициент = (ti × N) / Ti**

Будем предоставлять очередной квант времени готовому процессу с **наименьшей величиной** этого отношения.

#### Характеристики:
- Обеспечивает строгую справедливость между пользователями
- Учитывает время присутствия в системе
- Динамически подстраивается под количество пользователей

#### Преимущества:
- Гарантированная доля процессорного времени для каждого пользователя
- Предсказуемость производительности
- Защита от монополизации ресурсов

#### Недостатки:
- Накладные расходы на вычисление коэффициентов
- Не учитывает приоритеты процессов
- Может быть неоптимальным для систем с различными типами задач
---
### 5) Планирование с приоритетами
**Принцип работы:**
Алгоритмы SJF и гарантированного планирования представляют собой **частные случаи** приоритетного планирования.

При приоритетном планировании каждому процессу присваивается определенное числовое значение — **приоритет**, в соответствии с которым ему выделяется процессор.

Процессы с **одинаковыми приоритетами** планируются в порядке FCFS.

#### Типы приоритетов:
**Внутренние параметры** (связанные с процессом):
- Ограничения по времени использования процессора
- Требования к размеру памяти
- Число открытых файлов
- Используемые устройства ввода-вывода
- Отношение средних продолжительностей I/O burst к CPU burst

**Внешние параметры** (политические факторы):
- Важность процесса для достижения целей
- Стоимость оплаченного процессорного времени
- Статус пользователя (студент, преподаватель, администратор)

#### Примеры использования внутренних параметров:
**Для алгоритма SJF:**
- Приоритет = оценка продолжительности следующего CPU burst
- Чем меньше значение, тем выше приоритет

**Для гарантированного планирования:**
- Приоритет = коэффициент справедливости (ti × N) / Ti
- Чем меньше коэффициент, тем выше приоритет

#### Вытесняющее и невытесняющее планирование:
**Невытесняющее:**
- Процесс выполняется до завершения или перехода в ожидание
- Новый высокоприоритетный процесс ждет в очереди

**Вытесняющее:**
- Процесс с более высоким приоритетом, появившийся в очереди готовых процессов, **вытесняет** исполняющийся процесс с более низким приоритетом
- Обеспечивает лучшую отзывчивость системы

#### Проблема голодания (Starvation):

Низкоприоритетные процессы могут **никогда не получить процессор**, если постоянно появляются высокоприоритетные процессы.

**Решение — старение (Aging):**
- Постепенное увеличение приоритета процессов, долго ожидающих в очереди
- Гарантирует, что любой процесс рано или поздно будет выполнен

#### Преимущества:
- Гибкость в управлении ресурсами
- Учет важности задач
- Возможность реализации различных политик

#### Недостатки:
- Риск голодания низкоприоритетных процессов
- Сложность определения справедливых приоритетов
- Возможность инверсии приоритетов

---

### 6) Многоуровневые очереди (Multilevel Queue)
**Принцип работы:**
Для систем, в которых процессы могут быть легко **рассортированы по разным группам**, был разработан другой класс алгоритмов планирования.

Для каждой группы процессов создается **своя очередь** процессов, находящихся в состоянии готовности. Этим очередям приписываются **фиксированные приоритеты**.

#### Пример структуры очередей:

1. **Системные процессы** (наивысший приоритет)
2. **Интерактивные процессы**
3. **Пакетные процессы**
4. **Студенческие процессы** (наименьший приоритет)

#### Правило планирования:
- Приоритет очереди системных процессов устанавливается **выше**, чем приоритет очередей пользовательских процессов
- Приоритет очереди процессов преподавателей **выше**, чем для очереди процессов студентов
- **Ни один** пользовательский процесс не будет выбран для исполнения, пока есть хоть один готовый системный процесс
- **Ни один** студенческий процесс не получит процессор, если есть процессы преподавателей, готовые к исполнению

#### Алгоритмы внутри очередей:
Внутри каждой очереди могут применяться **различные алгоритмы** планирования:
- Для **фоновых процессов** (большие счетные задачи) — алгоритм **FCFS**
- Для **интерактивных процессов** — алгоритм **RR**

![[OS 31.png]]
#### Характеристики:
- Процессы **не перемещаются** между очередями
- Каждая очередь имеет **свой приоритет** и **свой алгоритм планирования**
- Гибкость в настройке под разные типы процессов

#### Преимущества:
- Повышенная гибкость планирования
- Для процессов с различными характеристиками применяется наиболее подходящий алгоритм
- Простота реализации
- Низкие накладные расходы

#### Недостатки:
- Жесткая структура — процессы не могут переходить между очередями
- Риск голодания низкоприоритетных очередей
- Необходимость заранее классифицировать процессы
---
### 7) Многоуровневые очереди с обратной связью (Multilevel Feedback Queue)
**Принцип работы:**
Это усовершенствование алгоритма многоуровневых очередей, в котором процессы **могут перемещаться** между очередями.

Алгоритм **адаптируется** к поведению процессов: процессы, требующие много процессорного времени, постепенно перемещаются в очереди с более низким приоритетом, а процессы, требующие мало времени, остаются в высокоприоритетных очередях.

#### Пример реализации с 4 очередями:

**Очередь 0** (наивысший приоритет):
- Квант времени: **8 единиц**
- Только что созданный процесс поступает в очередь 0
- Если CPU burst < 8, процесс остается в очереди 0
- Если CPU burst ≥ 8, процесс переходит в очередь 1

**Очередь 1:**
- Квант времени: **16 единиц**
- Если CPU burst < 16, процесс остается в очереди 1
- Если CPU burst ≥ 16, процесс переходит в очередь 2

**Очередь 2:**
- Квант времени: **32 единицы**
- Если CPU burst < 32, процесс остается в очереди 2
- Если CPU burst ≥ 32, процесс переходит в очередь 3

**Очередь 3** (наименьший приоритет):
- **Без квантования времени** (алгоритм FCFS)
- Процесс может исполняться до окончания своего CPU burst
- Выполняется только при отсутствии готовых процессов в других очередях

#### Логика работы:
Чем больше значение продолжительности CPU burst, тем:
- В **менее приоритетную очередь** попадает процесс
- На **большее процессорное время** он может рассчитывать

Через некоторое время:
- Все процессы, требующие **малого времени** работы процессора, окажутся в **высокоприоритетных очередях**
- Все процессы, требующие **большого счета** и с низкими запросами к времени отклика, окажутся в **низкоприоритетных очередях**

![[OS 32.png]]

#### Параметры алгоритма:
1. Количество очередей
2. Алгоритм планирования внутри каждой очереди
3. Метод определения момента повышения приоритета процесса
4. Метод определения момента понижения приоритета процесса
5. Метод определения очереди для нового процесса

#### Преимущества:
- Автоматическая адаптация к характеристикам процессов
- Хорошее время отклика для коротких процессов
- Справедливость для длинных процессов
- Не требуется предварительная информация о процессах

#### Недостатки:
- Сложность реализации
- Больше накладных расходов
- Необходимость тонкой настройки параметров
- Возможность временного голодания процессов в нижних очередях


## Глоссарий терминов

**Планирование (Scheduling)** — процесс распределения ресурсов между конкурирующими процессами.

**Планировщик (Scheduler)** — компонент операционной системы, отвечающий за планирование.

**Диспетчер (Dispatcher)** — компонент, который фактически переключает процессор с одного процесса на другой.

**CPU Burst** — период непрерывных вычислений на процессоре.

**I/O Burst** — период ожидания завершения операции ввода-вывода.

**Квант времени (Time Quantum)** — фиксированный интервал времени, выделяемый процессу в алгоритме Round Robin.

**Переключение контекста (Context Switch)** — сохранение состояния текущего процесса и загрузка состояния нового процесса.

**Turnaround Time** — полное время выполнения процесса (от поступления до завершения).

**Waiting Time** — суммарное время нахождения процесса в очереди готовности.

**Response Time** — время от подачи запроса до первого отклика.

**Throughput** — количество процессов, завершенных в единицу времени.

**Голодание (Starvation)** — ситуация, когда процесс не может получить необходимые ресурсы в течение неопределенно долгого времени.

**Старение (Aging)** — техника постепенного увеличения приоритета процесса для предотвращения голодания.

**Конвой (Convoy Effect)** — ситуация, когда короткие процессы ждут завершения одного длинного процесса.


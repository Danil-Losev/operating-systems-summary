#Operating_Systems #OS_Processes 
## Основные понятия о процессах
### 1) Определение процесса
**Процесс** — это фундаментальная абстракция операционной системы, представляющая собой программу в состоянии выполнения.

**Процесс** -  это идентифицируемая абстракция совокупности взаимосвязанных системных ресурсов на основе отдельного и независимого виртуального адресного пространства в контексте которой организуется выполнение потоков. 

Стандарт ISO 9000:2000 Definitions определяет процесс как совокупность взаимосвязанных и взаимодействующих действий, преобразующих входящие данные в исходящие.

Ключевые характеристики процесса:
- Выполняет последовательность инструкций в своём адресном пространстве
- Адресное пространство — набор адресов, к которым процесс имеет доступ
- Последовательность выполняемых инструкций отслеживается с помощью **счётчика команд** (указатель команд, контрольная точка)
- Может содержать несколько счётчиков команд, что означает наличие нескольких **нитей исполнения** (потоков)

**Процесс как фундаментальная абстракция:**
- Позволяет манипулировать выполнением кода на компьютере
- Создаёт иллюзию наличия собственного независимого компьютера для каждого пользователя
- Обеспечивает изоляцию между выполняемыми программами
- Предоставляет механизм для реализации мультипрограммирования


### 2) Виртуальная машина и API
Процесс выполняется в **виртуальном адресном пространстве** на виртуальной машине. Семантика взаимодействия приложения и операционной системы определяется через **Прикладной Интерфейс Программирования (API)**.
![[OS 8.png]]

---
## Образ процесса — виртуальное адресное пространство
### Структура виртуального адресного пространства
Образ процесса содержит несколько сегментов, расположенных в памяти:
![[OS 9.png]]

![[OS 10.png]]

![[OS 13.png]]

**TEXT (Текст программы):**
- Содержит исполняемый машинный код программы
- Статическая часть, не изменяется во время выполнения
- Может разделяться несколькими процессами

**DATA (Сегмент данных):**
- Глобальные и статические переменные
- Инициализированные данные программы
- Может изменяться во время выполнения

**HEAP (Куча):**
- Область динамического выделения памяти
- Управляется программно (malloc/free, new/delete)
- Растёт в направлении стека
- Память выделяется и освобождается явно
- Используется для объектов и структур данных переменного размера

При переполнении кучи может возникнуть ошибка "out of memory" или "segmentation fault". Такая ошибка происходит, когда программа пытается выделить больше памяти, чем доступно, или когда она пытается обратиться к памяти за пределами выделенного пространства. Она может привести к аварийному завершению программы. 

**STACK (Стек):**
- Локальные переменные функций
- Параметры функций
- Адреса возврата
- Растёт в направлении кучи (вниз, к меньшим адресам)
- Автоматическое управление памятью
- Используется для вызовов функций и управления контекстом выполнения

При переполнении стека может возникнуть ошибка "stack overflow". Такая ошибка часто происходит из-за бесконечной рекурсии или чрезмерно глубоких вызовов функций. Она может привести к повреждению данных и сбою программы.

**COFF (Common Object File Format)** — формат объектных файлов, используемый в некоторых операционных системах для хранения исполняемых файлов и библиотек. 

**ELF (Executable and Linkable Format)** — универсальный формат файлов, используемый в Unix-подобных операционных системах для хранения исполняемых файлов, объектных файлов и библиотек.


## Блок управления процессом (PCB)
Блок управления процессом (Process Control Block, PCB) — это структура данных в ядре операционной системы, которая содержит информацию о процессе. PCB используется для управления процессами и хранения их состояния.

**Содержимое PCB:**
- Идентификаторы: PID (Process ID), PPID (Parent Process ID)
- Состояние процесса (готовность, выполнение, ожидание и т.д.)
- Приоритет процесса
- Регистры процессора (значения регистров приостанавливаемого процесса)
- Счётчик команд (Program Counter)
- Указатель стека (Stack Pointer)
- Адресное пространство (указатели на сегменты текста, данных, стека, кучи)
- Информация о планировании (квант времени, приоритеты)
- Список открытых файлов (дескрипторы файлов)

У процесса дескрипторы с номера 0 по 2 зарезервированы для стандартных потоков ввода-вывода:
- 0 — стандартный ввод (stdin)
- 1 — стандартный вывод (stdout)
- 2 — стандартный вывод ошибок (stderr)


---
## Состояния процесса
### Диаграмма состояний процесса
![[OS 11.png]]
Процесс в течение своей жизни проходит через различные состояния. Переходы между состояниями управляются операционной системой.
### Основные состояния процесса
Процесс может находиться в следующих основных состояниях:
1. **Инициализация (Initialization)**
2. **Готовность (Ready)**
3. **Выполнение (Running)**
   - Режим задачи (Task Mode / User Mode)
   - Режим ядра (Kernel Mode / System Mode)
4. **Ожидание / Сон (Waiting / Sleeping)**
5. **Завершение (Terminated / Zombie)**
---
## Подробное описание состояний
#### 1) Инициализация (Initialization)
**Описание:**
При загрузке системы создаётся первый процесс — **init**. Все остальные процессы являются его потомками, образуя **иерархию процессов**. Они образуются с помощью системных вызовов (fork, exec и т.д.).

Сначала процесс находится в переходном состоянии **Инициализация**.

**Что происходит в этом состоянии:**
- Сведения о процессе заносятся в структуры данных операционной системы
- Выделяется память для процесса
- Инициализируется адресное пространство
- Создаётся запись в таблице процессов
- Подготавливаются необходимые системные ресурсы

**Переход:** После завершения инициализации процесс переходит в состояние **Готовность**.

---
#### 2) Готовность (Ready)
**Описание:**
В состоянии готовности процесс **полностью подготовлен к выполнению**, имеет все необходимые ресурсы, **кроме процессорного времени**.

**Важно:** Не путать с состоянием ожидания! В состоянии готовности процесс ждёт только выделения процессора, а не каких-либо событий или ресурсов.

**Характеристики:**
- Процесс находится в **очереди готовых процессов**
- Может быть немедленно запущен на выполнение
- Ожидает решения планировщика о выделении CPU

**Переход:** Когда планировщик выбирает процесс для выполнения, он переходит в состояние **Выполнение**.

---
#### 3) Выполнение (Running)
Процесс может выполняться в двух режимах:
##### 1) Выполнение в режиме задачи (Task Mode / User Mode)
**Описание:**
Выполнение пользовательского кода программы.

**Характеристики:**
- Исполняются прикладные программы
- Ограниченный доступ к системным ресурсам
- Нет прямого доступа к аппаратуре
- Защищённое адресное пространство

**Переход в режим ядра:**
Для выполнения системного вызова происходит переключение в режим ядра через **переключатель режимов (mode switcher)**.

**Системным вызовом может быть:**
- Ввод/вывод (чтение/запись файлов)
- Управление памятью
- Создание/завершение процессов
- Управление сигналами
- Другие операции, требующие привилегий ядра
##### 2) Выполнение в режиме ядра (Kernel Mode / System Mode)
**Описание:**
Выполнение кода операционной системы от имени процесса.

**Характеристики:**
- Исполняются функции ядра и системные команды
- Полный доступ к аппаратуре и системным ресурсам
- Возможность выполнения привилегированных операций
- Доступ к адресному пространству как процесса, так и ядра

**Обработка прерываний:**
Если в этом состоянии возникает прерывание (при условии, что исполняется код без запрета прерываний), системный контекст будет сохранён как часть контекста задачи.

---
#### 4) Ожидание / Сон (Waiting / Sleeping)
**Описание:**
Процесс блокируется и ожидает наступления какого-либо события или завершения операций ввода-вывода.

При переходе в это состояние процесс **освобождает процессорное время** и не может быть выполнен до тех пор, пока не произойдёт ожидаемое событие.

**Причины перехода в состояние ожидания:**
- Ожидание завершения операций ввода-вывода (чтение с диска, сетевой обмен)
- Ожидание освобождения ресурса
- Ожидание сигнала от другого процесса
- Ожидание наступления события

**Выход из состояния:**
Когда событие происходит или операции ввода-вывода завершаются, процесс переходит в состояние **Готовность**. В некоторых случаях он может быть сразу допущен к исполнению (переход в состояние **Выполнение**).

---
#### 5) Завершение процесса (Termination)
**Описание:**
Процесс завершил своё выполнение, но его информация ещё не полностью удалена из системы.

**Виды завершения:**
- **Нормальное завершение:** Процесс завершает выполнение корректно, освобождая ресурсы.
- **Аварийное завершение:** Процесс завершается из-за ошибки или внешнего сигнала (например, сигнал SIGKILL).
- **Фатальное завершение:** Процесс завершается из-за серьёзной ошибки, которая не позволяет продолжать выполнение.
- **Ошибка выполнения:** Процесс завершается из-за ошибки в коде (например, деление на ноль, нарушение доступа к памяти).

**Нормальное завершение:**
- Процесс завершается, посылает сигнал своему родительскому процессу
- Родительский процесс должен принять этот сигнал (выполнить функцию **wait()**)
- **Только после того, как родитель примет сигнал**, информация о процессе будет убрана из таблицы процессов

**Процессы-зомби (Zombie Processes):**
Если родительский процесс не исполняет функцию **wait()**, информация о потомке не будет убрана из таблицы процессов, и процесс-потомок переходит в состояние **зомби**.

Характеристики процесса-зомби:
- Образа процесса в памяти не существует (освобождены все ресурсы)
- Информация о процессе в таблице процессов остаётся
- Занимает запись в таблице процессов (может привести к исчерпанию доступных PID)
- Необходимо, чтобы родительский процесс "собрал" информацию о завершении

---
## Ядро ОС и управление процессами
**Ядро операционной системы** - это центральная часть операционной системы, которая управляет аппаратными ресурсами и предоставляет услуги для выполнения процессов.
### Роль ядра
**Ядро операционной системы:**
- Управляет аппаратурой компьютера
- Управляет процессами и их взаимодействием
- Предоставляет системные вызовы для взаимодействия с аппаратурой

**Обработка исключений:**
Некоторые действия процесса могут вызвать аппаратные исключения. Для их обработки ядро выполняет действия от имени процесса.

**Системные процессы:**
Выполняются, когда это необходимо (например, swapper, pagedaemon). Эти процессы выполняют задачи, не относящиеся к конкретному пользовательскому процессу.
``` 
swapper - системный процесс, отвечающий за управление памятью и обмен страницами между оперативной памятью и диском.

pagedaemon - системный процесс, который занимается управлением страницами памяти, включая очистку и освобождение страниц, а также обеспечение наличия свободной памяти для процессов.
```
---
## Режимы и контекст исполнения
### - Режимы исполнения
Современные процессоры поддерживают различные режимы работы для обеспечения защиты и безопасности.
##### Режим задачи (Task Mode / User Mode)
**Режим задачи** предназначен для выполнения пользовательских программ.

**Характеристики:**
- Выполнение прикладных программ
- Ограниченный набор инструкций процессора
- Нет прямого доступа к аппаратуре
- Адресное пространство защищено

##### Режим ядра (Kernel Mode / System Mode)
**Режим ядра** предназначен для выполнения кода операционной системы.

**Характеристики:**
- Выполнение функций ядра
- Полный набор инструкций процессора
- Прямой доступ к аппаратуре
- Доступ к адресному пространству процесса и системы

### - Контекст исполнения
**Контекст исполнения** — совокупность данных, необходимых для возобновления выполнения процесса (регистры CPU, стек, память, дескрипторы файлов).

**Виды контекста:**
##### 1. Контекст пользователя (User Context)
- Выполнение кода приложения
- Ограниченные права доступа
- Пользовательское адресное пространство
##### 2. Контекст ядра (Kernel Context)
- Выполнение системного кода
- Полный доступ к ресурсам
- Активируется при системных вызовах и обработке событий
##### 3. Контекст прерывания (Interrupt Context)
- Обработка аппаратных/программных прерываний
- Асинхронное выполнение
- Высокий приоритет
##### 5. Контекст процесса (Process Context)
- Полное состояние процесса как единицы выполнения
- Включает всю информацию для управления процессом
- Хранится в PCB (Process Control Block)
##### 4. Контекст потока (Thread Context)
- Легковесный поток выполнения
- Собственный стек и регистры
- Разделяет память с другими потоками процесса
##### 5. Контекст исключения (Exception Context)
- Обработка ошибок и исключительных ситуаций
- Типы:  Fault (исправимые), Trap (отладка), Abort (критические)
##### 6. Cистемный контекст (System Context)
- Выполнение кода ядра вне контекста конкретного процесса
- Используется для фоновых задач ядра
- Не имеет доступа к пользовательскому пространству
- Используется для обслуживания прерываний и таймеров
- Имеет доступ только к пространству системы
##### Переключение контекста (Context Switch)
**Процесс:**
1. Сохранение текущего состояния (регистры, стек, PC)
2. Обновление PCB и очередей планировщика
3. Загрузка состояния нового процесса

### - Соответствие режимов и контекстов
- **Код приложения** выполняется в режиме **задачи** в **контексте процесса**, доступ только к пространству процесса
- **Системные вызовы и исключения** – в режиме **ядра** в **контексте процесса**, доступ к пространству процесса и системы
- **Прерывания** – в режиме **ядра**, **системном контексте**, доступ только к пространству системы
---
### - Переключение режимов (Mode Switching)
При выполнении системного вызова запускается **переключатель режимов (mode switcher)**, который:

1. Переводит систему в **режим ядра**
2. Управление передаётся коду ядра
3. Выполняются необходимые операции ядра
4. После завершения операций переключатель режимов вызывается снова
5. Система переключается обратно в **режим задачи**
6. Управление передаётся процессу

**Переключение режимов** — это быстрая операция, которая изменяет уровень привилегий без смены процесса.

## Контекст процесса подробнее
Полный контекст процесса состоит из трёх компонентов:
#### 1) Пользовательский контекст (User Context)
**Содержимое:**
- **Адресное пространство задачи:**
  - Text (код программы)
  - Data (данные)
  - Stack (стек пользователя)
- Пользовательские регистры
- Локальные переменные
- Параметры функций
#### 2) Системный контекст (System Context)
**Содержимое:**
- **U-area** (область пользователя — user structure)
- **Kernel Stack** (стек ядра)
- Карты трансляции адресов (страницы памяти)
- Структура **proc** (блок управления процессом)

**Карты трансляции адресов:**
- Таблицы страниц для виртуальной памяти
- Сегментные регистры (если применимо)
- Другие структуры управления памятью
#### 3) Аппаратный контекст процесса (Hardware Context)
**Содержимое:**
1. **Слово состояния процессора (Processor Status Word, PSW):**
   - Текущий режим исполнения
   - Предыдущий режим исполнения
   - Уровни приоритетов прерываний
   - Флаги процессора

2. **Регистры общего назначения:**
   - Счётчик команд (Program Counter, PC)
   - Указатель стека (Stack Pointer, SP) - указывает на вершину стека процесса или ядра
   - Регистры данных

3. **Регистры сопроцессора (FPU — Floating Point Unit):**
   - Регистры для операций с плавающей точкой

4. **Регистры управления памятью:**
   - Регистры таблиц страниц
   - Регистры сегментации
---

## User-Area и Kernel Stack
### User-Area (U-Area)
**Определение:**
U-area (структура user) — это область данных, связанная с процессом, которая содержит информацию, необходимую для управления процессом.

**Содержимое U-area:**
- Таблица открытых файлов процесса
- Текущий рабочий каталог
- Данные для идентификации пользователя (UID, GID)
- Лимиты на использование ресурсов
- Обработчики сигналов
- Регистровый контекст (сохранённые регистры)
- Указатель на kernel stack
- Статистика использования процессорного времени

**Видимость:**
U-area видна и нужна только во время выполнения процесса и самому процессу. Является частью пространства процесса, но управляется ядром.

---
### Kernel Stack (Стек ядра)
**Определение:**
Kernel stack — это стек, используемый ядром операционной системы для хранения данных при выполнении кода ядра от имени процесса.

**Необходимость:**
К ядру могут обращаться несколько процессов одновременно. Ядро является **реентерабельным** (может быть прервано и вызвано повторно). Поэтому каждому процессу необходим собственный стек ядра.

**Характеристики:**
- Стек ядра может размещаться в адресном пространстве процесса
- Является **собственностью ядра**, как и U-area
- Используется при выполнении системных вызовов
- Хранит локальные переменные функций ядра
- Хранит параметры системных вызовов

**Использование:**
- При системном вызове процесс переключается в режим ядра
- Используется kernel stack для хранения локальных данных
- После завершения системного вызова управление возвращается процессу

---
## Системные структуры для управления процессом
Операционная система использует две основные структуры данных для управления процессом:
### Структура Proc
**Определение:**
Структура **proc** — это основная структура данных ядра, которая содержит информацию о процессе и используется для управления его выполнением.

Она хранится в пространстве системы (kernel space) и доступна ядру операционной системы.

**Назначение:**
- Доступна системе **постоянно**
- Нужна всегда, даже когда процесс не выполняется
- Все структуры proc вместе составляют **таблицу процессов**
- Является частью пространства системы (kernel space)

**Содержимое структуры proc:**
- Идентификатор процесса (PID)
- Состояние процесса (готовность, выполнение, ожидание и т.д.)
- Приоритет процесса
- Информация о планировании
- Указатели на связанные структуры данных
- Информация об иерархии процессов (родитель, потомки)
- Указатель на U-area
- Статистика использования ресурсов
- Маска ожидаемых сигналов
- Информация о блокировках

**Таблица процессов (Process Table):**
Совокупность всех структур proc образует **таблицу процессов**. Это центральная структура данных ядра для управления процессами. 

Эта таблица позволяет ядру отслеживать состояние и характеристики всех процессов в системе.
Она хранится в **пространстве системы** (kernel space) и доступна только ядру операционной системы.

**Пространство системы (Kernel Space)** — область памяти, доступная только ядру операционной системы и привилегированным процессам. В этом пространстве хранятся критические структуры данных, такие как таблица процессов, драйверы устройств и другие компоненты ядра.

![[OS 12.png]]![[OS 14.png]]

---
### Область U-Area (User Area)

**Назначение:**
- Видна и нужна только во время выполнения процесса
- Необходима самому процессу
- Является частью пространства процесса

**Содержимое:**
- Таблица открытых файлов
- Текущий каталог
- Kernel stack (иногда)
- Лимиты ресурсов
- Обработчики сигналов
- Аппаратный контекст (сохранённые регистры)
- Информация о системном вызове

---
## Полномочия пользователя и идентификаторы
### Информация о пользователях
Информация о пользователях и их правах хранится в структурах системы:
- Файл **/etc/passwd**
- RADIUS
- NIS (Network Information Service)
- LDAP и другие системы аутентификации

Пользователи идентифицируются с помощью **User ID (UID)** и **Group ID (GID)**.
### Идентификаторы пользователя процесса
Каждый процесс имеет несколько идентификаторов пользователя:

1. **Real User ID (RUID)** — реальный идентификатор пользователя
   - Идентификатор пользователя, запустившего процесс
   - Определяет, кому принадлежит процесс

2. **Effective User ID (EUID)** — эффективный идентификатор пользователя
   - Определяет права доступа процесса к ресурсам
   - Используется для проверки прав при доступе к файлам и ресурсам
   - Может отличаться от RUID (механизм SUID)

3. **Saved User ID (SUID)** — сохранённый идентификатор пользователя
   - Сохраняет предыдущее значение EUID
   - Позволяет временно изменять привилегии

**Важное правило безопасности:**
- Если effective user id (EUID) равен root и вы меняете uid, привилегии сбрасываются **навсегда**
- Если effective user id не root, то saved user id никогда не изменяется, и вы можете вернуть привилегии root обратно в любой момент в вашей программе

Аналогично существуют идентификаторы группы: **RGID**, **EGID**, **SGID**.

---
## Прерывания (Interrupts)
### Общие сведения о прерываниях
**Прерывание** — это сигнал процессору о необходимости временно приостановить выполнение текущей программы и обработать какое-либо внешнее событие.

**Источники прерываний:**
- Аппаратные устройства (клавиатура, диск, сетевая карта, таймер)
- Программные прерывания (системные вызовы)
- Исключения процессора (деление на ноль, ошибка страницы)

### Обработка прерываний
**Контекст процесса и прерывания:**
Контекст процесса **защищён от ISR (Interrupt Service Routine)** не полностью. При обработке прерывания может использоваться стек процесса или специальный стек прерываний.

**Процедура обработки прерывания (ISR — Interrupt Service Routine):**
Выполняется в системном контексте (контексте прерываний), не имеет доступа к адресному пространству процесса.

**Время обработки прерывания** является частью времени выполнения процесса, от имени которого выполняется ISR.

---
### Приоритет прерываний
Прерывания имеют различные **уровни приоритета**. Процессор может обрабатывать прерывания с более высоким приоритетом, даже если уже обрабатывается прерывание с более низким приоритетом.

**Стек прерываний:**
- Иногда создаётся отдельный **глобальный стек прерываний**
- Если его нет, задействуется **kernel stack текущего процесса**

---
### Алгоритм обработки прерываний
1. **Получение прерывания:**
   - Процессор получает сигнал прерывания

2. **Сохранение контекста:**
   - Сохраняются регистры процессора
   - Сохраняется PSW (Processor Status Word)
   - Контекст сохраняется в стеке

3. **Повышение уровня приоритета:**
   - Устанавливается уровень приоритета прерывания
   - Блокируются прерывания с более низким или равным приоритетом

4. **Определение источника прерывания:**
   - Чтение вектора прерывания
   - Определение обработчика прерывания

5. **Выполнение ISR (Interrupt Service Routine):**
   - Переход к коду обработчика прерывания
   - Обработка события

6. **Восстановление контекста:**
   - Извлечение из стека сохранённого контекста
   - Восстановление регистров
   - Восстановление PSW

7. **Восстановление предыдущего уровня приоритета:**
   - Восстановление предыдущего уровня приоритета прерываний

8. **Возврат из прерывания:**
   - Возврат к прерванной программе

---
## Переключение контекста (Context Switching)
### Определение
**Переключение контекста** — это процесс сохранения состояния текущего процесса и восстановления состояния другого процесса для предоставления ему процессорного времени.
### Когда происходит переключение контекста

- Процесс исчерпал выделенный квант процессорного времени
- Процесс выполнил системный вызов, который блокирует его (например, операция ввода-вывода)
- Процесс ожидает события
- Процесс с более высоким приоритетом стал готов к выполнению
- По решению планировщика процессов

### Процедура переключения контекста
- Аппаратное – сохраняем счетчик команд и стек
- Аппаратное – загружаем новый счетчик команд из вектора прерываний
- Программно (ассемблер) -  сохраняем регистры
- Программно (ассемблер) – настраиваем новый стек
- ISR(С) работает (обычно начинается со считывания буфера ввода)
- Диспетчер решает, какой процесс запускать после ISR
- Возврат из С процедуры к ассемблерному коду
- Ассемблерая процедура запускает новый текущий процесс

### Подробный алгоритм переключения контекста
1. **Сохранение контекста текущего процесса:**
   - Сохранение регистров процессора
   - Сохранение счётчика команд
   - Сохранение указателя стека
   - Сохранение PSW
   - Сохранение в структуру данных процесса (U-area)

2. **Выбор нового процесса:**
   - Планировщик выбирает следующий процесс для выполнения

3. **Восстановление контекста нового процесса:**
   - Загрузка сохранённых регистров
   - Загрузка счётчика команд
   - Загрузка указателя стека
   - Загрузка PSW
   - Переключение адресного пространства (смена таблиц страниц)

4. **Передача управления:**
   - Процессор начинает выполнение нового процесса

**Стоимость переключения контекста:**
Переключение контекста — это дорогостоящая операция с точки зрения производительности:
- Требуется время на сохранение и восстановление регистров
- Сброс кэша процессора
- Сброс TLB (Translation Lookaside Buffer)
- Возможные промахи в кэше после переключения

---
## Мультипрограммирование (Multitasking)
**Мультипрограммирование (многозадачность, multitasking)** — это способ организации вычислительного процесса, при котором на одном процессоре выполняется поочерёдно несколько программ.
### Преимущества мультипрограммирования
- Повышение использования процессора (пока один процесс ожидает ввода-вывода, другой может выполняться)
- Повышение пропускной способности системы
- Лучшее время отклика для интерактивных приложений
- Возможность одновременной работы нескольких пользователей

### Единицы работы в ОС
Чтобы поддерживать мультипрограммирование, ОС должна определить для себя внутренние **единицы работы**, между которыми будут распределяться ресурсы.

В настоящее время в большинстве операционных систем определены два типа единиц работы:
1. **Процесс (process)** — более крупная единица, или задача
2. **Поток, или нить (thread)** — менее крупная единица

**Важно:** Процесс выполняется в форме одного или нескольких потоков.

---
## Структура процесса и потоки

### Процесс как контейнер ресурсов
Процессы рассматриваются операционной системой как **заявки или контейнеры** для всех видов ресурсов, **кроме одного** — процессорного времени.

Этот важнейший ресурс — процессорное время — распределяется операционной системой между другими единицами работы — **потоками (нитями)**, которые и получили своё название от английского слова "thread of execution" — **нить исполнения**.

В русском языке термин **"поток"** более распространён, чем **"нить"**.

P.S. Впервые потоки были реализованы в операционной системе **Solaris** компании Sun Microsystems в 1992 году.

---
### Иерархия: процесс и потоки
![[OS 20.png]]

**Процесс содержит:**
- Адресное пространство (text, data, heap)
- Таблицу открытых файлов
- Информацию о пользователе
- Один или несколько потоков исполнения

**Каждый поток имеет:**
- Собственный программный счётчик (PC)
- Собственный набор регистров
- Собственный стек

**Потоки одного процесса разделяют:**
- Программный код (text)
- Глобальные переменные (data)
- Открытые файлы
- Другие системные ресурсы

---
## Зачем нужны потоки (нити)?
### Проблема мультипрограммирования
Внедрение мультипрограммирования позволило повысить **пропускную способность** компьютерных систем (количество выполненных задач в единицу времени).

**Однако:** Любой отдельно взятый процесс в мультипрограммной системе никогда не может быть выполнен **быстрее**, чем при выполнении в однопрограммном режиме.

### Внутренний параллелизм алгоритмов
Если алгоритм решения задачи обладает определённым **внутренним параллелизмом**, мы могли бы ускорить его работу, организовав взаимодействие нескольких исполнительных единиц.

**Пример задачи:**
```
	Ввести массив a
	 Ожидание окончания операции ввода

	 Ввести массив b
	 Ожидание окончания операции ввода

	 Ввести массив с
	 Ожидание окончания операции ввода

	a = a + b
	c = a + c
	
	 Вывести массив с
	 Ожидание окончания операции вывода
```

При выполнении такой программы в рамках одного процесса, процесс **четырежды блокируется**, ожидая окончания операций ввода-вывода.

**Идея оптимизации:**
Вычисление суммы массивов можно было бы делать **параллельно** с ожиданием чтения третьего массива.

---
### Попытка решения с помощью процессов
Такое совмещение операций по времени можно было бы реализовать, используя **два взаимодействующих процесса** с разделяемой памятью:

![[OS 16.png]]

**Проблемы этого подхода:**
![[OS 17.png]]

1. **Создание процесса** — дорогостоящая операция
2. **Выделение разделяемой памяти** — требует системных вызовов
3. **Переключение контекста между процессами** — существенные накладные расходы
4. **Синхронизация** — сложная и ресурсоёмкая

**Результат:** Временные потери на создание процесса, выделение общей памяти и переключение контекста могут **превысить** выигрыш, полученный за счёт совмещения операций.

---
### Решение: нити исполнения (потоки)
Для эффективной реализации параллелизма внутри одной задачи была введена новая абстракция — **нить исполнения (поток, thread)**.

**Определение:**
Нить исполнения — это независимый поток управления внутри процесса.

**Характеристики потоков:**
Нити процесса **разделяют:**
- Программный код
- Глобальные переменные
- Системные ресурсы (открытые файлы, сигналы и т.д.)
- Адресное пространство

Каждая нить имеет **собственные:**
- Программный счётчик (PC)
- Содержимое регистров
- Собственный стек

**Результат:** Процесс представляется как **совокупность нитей исполнения**, работающих в общем адресном пространстве.

![[OS 18.png]]

---
## Управление потоками
### Операции с потоками
Нити, как и процессы, могут:
- **Создаваться** (порождаться другими нитями)
- **Порождать нити-потомки** (только внутри своего процесса)
- **Переходить из состояния в состояние**
- **Завершаться**

При порождении нити создаётся её собственный стек и контекст исполнения.

Когда нить порождает новую нить, новая нить получает **копию контекста родительской нити** (регистры, стек и т.д.), но **разделяет с родительской нитью ресурсы процесса** (память, файлы и т.д.).

### Состояния нитей (потоков)
Нити проходят через состояния, аналогичные состояниям процессов:
1. **Рождение (Creation)**
2. **Готовность (Ready)**
3. **Выполнение (Running)**
4. **Ожидание (Waiting / Blocked)**
5. **Завершение (Terminated)**

**Связь состояний процесса и потоков:**

- Из состояния **рождение** процесс приходит, содержа всего **одну нить исполнения**. Другие нити процесса будут являться потомками первой нити.

- Процесс находится в состоянии **готовность**, если **хотя бы одна** из его нитей находится в состоянии готовность и **ни одна** из нитей не выполняется.

- Процесс находится в состоянии **выполнение**, если **хотя бы одна** из его нитей выполняется.

- Процесс находится в состоянии **ожидание**, если **все** его нити находятся в состоянии ожидание.

- Процесс находится в состоянии **завершил исполнение**, если **все** его нити находятся в состоянии завершили исполнение.

**Важное преимущество:**
Пока одна нить процесса **заблокирована** (например, ожидает ввода-вывода), другая нить того же процесса может **выполняться**. Нити разделяют процессор так же, как и процессы.


Если одна из нитей аварийно завершается, то **вся программа (процесс) завершается**.

---
### Переключение нитей (потоков)
**Режимы работы:**
Как правило, поток работает в **пользовательском режиме**, но когда он обращается к **системному вызову**, то переключается в **режим ядра**.

**Контекст потока:**
Помимо состояния (текущие значения всех объектов потока), у каждого потока есть:
- **Идентификатор** (Thread ID, TID)
- **Два стека:**
  - Стек пользователя
  - Стек ядра (для системных вызовов)
- **Контекст** — сохранённые регистры, когда поток не работает
- **Приватная область** для локальных переменных
- **Дополнительные данные** (может быть специфично для реализации)

**Завершение потоков:**
- Когда поток завершает работу, он может прекратить своё существование
- **Процесс завершается**, когда прекратит существование **последний активный поток**

---
## Преимущества использования потоков
### Основные выигрыши при наличии нитей
1. **Время отклика (Responsiveness)**
   - Для интерактивных приложений
   - Программа продолжает работать, даже когда какие-либо нити заблокированы или выполняют длительные операции
   - Пользовательский интерфейс остаётся отзывчивым

2. **Разделение ресурсов (Resource Sharing)**
   - Нити совместно используют память (код и данные)
   - Совместное использование других ресурсов (файлы, сокеты)
   - Выделенные ресурсы принадлежат процессу и доступны всем его нитям
   - Упрощается обмен данными между нитями

3. **Экономия (Economy)**
   - Выделение памяти и ресурсов процессу — затратная операция
   - Создание нити значительно дешевле создания процесса
   - Переключение контекста между нитями одного процесса **существенно быстрее**, чем между процессами
   - Нити разделяют ресурсы процесса, что снижает накладные расходы

4. **Использование многопроцессорной архитектуры (Scalability)**
   - Нити могут работать **параллельно** на разных процессорах или ядрах
   - Эффективное использование многоядерных систем
   - Реальное ускорение выполнения программы

**Сравнение производительности:**
Операции создания новой нити и переключения контекста между нитями одного процесса занимают существенно **меньше времени**, чем аналогичные операции для процессов в целом.

---
## Визуализация нитей исполнения
### Нити в пространстве пользователя

![[OS 19.png]]

**a)** Один процесс с одной нитью исполнения
**б)** Три нити исполнения в одном процессе

Все нити работают в едином адресном пространстве процесса.

---
### Компоненты процесса и нити

![[OS 21.png]]

**Слева — то, что является общим для всех нитей процесса:**
- Код программы (Text)
- Глобальные данные (Data)
- Открытые файлы
- Сигналы
- Текущий каталог
- Идентификатор пользователя

**Справа — то, что принадлежит только нити:**
- Программный счётчик (PC)
- Регистры
- Стек
- Состояние нити
#### У каждой нити свой стек
Каждая нить имеет собственный стек, который позволяет ей независимо вызывать функции и хранить локальные переменные.

---
## Примеры использования нитей
### Текстовый редактор
![[OS 22.png]]
**Архитектура с нитями:**

1. **Нить пользовательского интерфейса:**
   - Обрабатывает ввод с клавиатуры и мыши
   - Отображает текст на экране
   - Остаётся отзывчивой

1. **Нить автосохранения:**
   - Периодически сохраняет документ на диск
   - Работает в фоновом режиме

3. **Нить проверки орфографии:**
   - Проверяет текст в фоновом режиме
   - Не блокирует основную работу

**Преимущества:**
- Пользователь может продолжать вводить текст во время сохранения
- Проверка орфографии не замедляет редактирование
### Многопоточный Web-сервер
![[OS 23.png]]
**Архитектура:**
1. **Основная нить (Dispatcher):**
   - Прослушивает входящие соединения
   - Принимает запросы от клиентов
   - Создаёт рабочие нити для обработки запросов

2. **Рабочие нити (Worker Threads):**
   - Обрабатывают HTTP-запросы
   - Читают файлы с диска
   - Формируют и отправляют ответы
   - Работают параллельно

**Преимущества:**
- Сервер может обрабатывать множество запросов одновременно
- Блокирующие операции ввода-вывода одной нити не блокируют другие
- Эффективное использование ресурсов на многопроцессорных системах
---
## Реализация нитей
Существует два основных подхода к реализации нитей:
### 1) Нити пользователя (User Threads)
**Определение:**
Нити, реализованные на **уровне библиотеки** в пространстве пользователя, без участия ядра операционной системы.
![[OS 24.png]]
**Характеристики:**
- Управление нитями осуществляется библиотекой времени выполнения
- Ядро не знает о существовании нитей, видит только процессы
- Планирование нитей происходит в пространстве пользователя

**Достоинства:**
- **Быстрое создание и удаление нитей** — не требуется системный вызов
- **Быстрое переключение контекста** — происходит в пространстве пользователя
- **Гибкое планирование** — приложение может использовать собственный алгоритм планирования
- **Переносимость** — могут работать на ОС, не поддерживающих нити на уровне ядра

**Недостатки:**
- **Блокирующие системные вызовы блокируют весь процесс** — если одна нить выполняет блокирующий системный вызов, все нити процесса блокируются
- **Нет истинного параллелизма** — на многопроцессорных системах нити одного процесса не могут выполняться параллельно
- **Нет справедливого планирования нитей** — если одна нить не освобождает процессор, другие нити процесса не получат управления
- **Проблемы с блокирующими операциями** — требуются специальные неблокирующие версии системных вызовов

---
### 2) Нити ядра (Kernel Threads)
**Определение:**
Нити, поддерживаемые непосредственно **ядром операционной системы**.
![[OS 25.png]]
**Характеристики:**
- Управление нитями осуществляется ядром
- Ядро знает о существовании нитей и планирует их выполнение
- Каждая нить представлена в ядре своей структурой данных

**Достоинства:**
- **Истинный параллелизм** — нити могут выполняться параллельно на разных процессорах
- **Блокирование одной нити не блокирует процесс** — если одна нить блокируется, другие нити процесса могут продолжать выполнение
- **Справедливое планирование** — ядро обеспечивает справедливое распределение процессорного времени между нитями
- **Эффективное использование многопроцессорных систем**

**Недостатки:**
- **Больше затрат на создание и удаление нитей** — требуются системные вызовы
- **Больше затрат на переключение нитей** — переключение контекста происходит через ядро
- **Менее гибкое планирование** — приложение не может использовать собственные алгоритмы планирования

### Сравнительная таблица

| Характеристика          | Нити пользователя | Нити ядра |
|-------------------------|-------------------|-----------|
| Скорость создания       | Быстро            | Медленнее |
| Скорость переключения   | Быстро            | Медленнее |
| Параллелизм на SMP      | Нет               | Да        |
| Блокирующий вызов       | Блокирует процесс | Блокирует только нить |
| Планирование            | Приложением       | Ядром     |
| Справедливость          | Нет гарантий      | Обеспечивается ядром |

**SMP** — Symmetric Multiprocessing (симметричная многопроцессорность) — архитектура, в которой несколько процессоров имеют равный доступ к общей памяти и устройствам ввода-вывода.

---
## Гибридные подходы
Некоторые системы используют **гибридный подход**, комбинируя нити пользователя и нити ядра:
- **Модель M:N** — M нитей пользователя отображаются на N нитей ядра
- Преимущества обоих подходов
- Более сложная реализация

Примеры: Solaris (до версии 9), современные реализации POSIX threads на некоторых системах.
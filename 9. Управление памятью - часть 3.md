#Operating_Systems #OS_Memory
## Оптимизация производительности виртуальной памяти
### Проблема производительности
При реализации виртуальной памяти возникает фундаментальная проблема: **каждое обращение к памяти требует преобразования виртуального адреса в физический**, что добавляет значительные накладные расходы. В наихудшем случае:

- Обращение к таблице страниц в памяти: **1 доступ к памяти**
- Обращение к самим данным: **1 доступ к памяти**
- **Итого: 2 обращения к памяти** вместо одного → замедление в 2 раза!

**Ключевые факторы, влияющие на производительность**:
1. Время преобразования адресов
2. Частота страничных прерываний (page faults)
3. Размер страниц
4. Алгоритмы замещения страниц
---
## MMU (Memory Management Unit) — Устройство управления памятью
### Определение и назначение
**MMU (Memory Management Unit, Диспетчер памяти)** — это **аппаратный модуль**, отвечающий за адресацию памяти и связанный с процессором и другими устройствами системной шиной.

**Основная функция MMU**: Преобразование **логического адреса** (полученного по общей шине от процессора) в **физический адрес** (реальный адрес в памяти, по которому происходит обращение).

### Принцип работы
**Важный момент**: Программа пользователя работает **только с логическими (виртуальными) адресами** и не "видит" физических адресов. Это обеспечивает:
- Изоляцию процессов
- Защиту памяти
- Возможность перемещения процессов в памяти
- Иллюзию непрерывного адресного пространства
### Архитектура без виртуальной памяти vs с виртуальной памятью

| Система                    | Путь адреса                                                                      | Обработка                          |
| -------------------------- | -------------------------------------------------------------------------------- | ---------------------------------- |
| **Без виртуальной памяти** | Виртуальный адрес → Шина памяти → Физическая память                              | Прямое обращение, адреса совпадают |
| **С виртуальной памятью**  | Виртуальный адрес → **MMU** → Физический адрес → Шина памяти → Физическая память | Преобразование через MMU           |

**Преимущество аппаратной реализации**: Часть работы по преобразованию адреса перекладывается на **аппаратуру**, что значительно ускоряет процесс по сравнению с чисто программной реализацией.

![[OS 57.png]]

---
## Оптимизация преобразования адресов
### 1. Использование степеней двойки для размера страниц
**Ключевая оптимизация**: Размер страницы выбирается равным **степени двойки** (512, 1024, 4096 байт и т.д.).

**Почему это важно?**
При размере страницы 2^n байт, двоичная запись адреса естественным образом разделяется на две части:
- **Старшие биты** → номер страницы
- **Младшие n бит** → смещение внутри страницы

**Преимущество**:
```
Вместо операции СЛОЖЕНИЯ:
  Физический адрес = (Номер_физической_страницы × Размер_страницы) + Смещение
  
Используется КОНКАТЕНАЦИЯ (присоединение битов):
  Физический адрес = [Номер_физической_страницы][Смещение]
```

**Конкатенация** — это простая операция присоединения битов, которая выполняется практически мгновенно аппаратурой, в то время как умножение и сложение требуют значительно больше времени.

**Пример для страницы 4 КБ (2^12)**:
```
Виртуальный адрес (32 бита):
┌──────────────────────┬─────────────┐
│ Номер страницы (20)  │ Смещение (12)│
└──────────────────────┴─────────────┘

Дескриптор страницы содержит номер физической страницы:
Физический номер = 0x12345

Конкатенация:
┌──────────────────────┬─────────────┐
│     0x12345          │  смещение   │
└──────────────────────┴─────────────┘
    Готовый физический адрес!
```

### 2. Размещение таблицы страниц в быстрых устройствах
Время преобразования виртуального адреса в физический **в значительной степени определяется временем доступа к таблице страниц**.

**Методы оптимизации**:
1. **Специальные регистры**
   - Таблица страниц размещается в наборе высокоскоростных регистров процессора
   - Недостаток: ограниченное количество регистров

2. **Ассоциативная память**
   - Использует параллельный поиск по всем записям одновременно
   - Очень быстрая, но дорогая

3. **Кэширование данных таблицы страниц (TLB)**
   - Наиболее распространенное решение
   - Подробнее рассмотрим ниже

### 3. Стратегия замещения
При использовании кэша для таблицы страниц (TLB) возникает необходимость в стратегии замещения записей.

**Популярные алгоритмы замещения для TLB**:
- **LRU (Least Recently Used)** — вытеснение наименее недавно использованной записи
- **FIFO (First In First Out)** — вытеснение самой старой записи
- **Random** — случайный выбор записи для вытеснения
- **NRU (Not Recently Used)** — вытеснение записи, которая не использовалась в последнее время
- **Clock** — модифицированный алгоритм, использующий бит использования

---

## TLB (Translation Lookaside Buffer) — Буфер ассоциативной трансляции
### Определение
**TLB (Translation Lookaside Buffer)** — это **высокоскоростной кэш** для хранения наиболее часто используемых записей таблицы страниц.

**Суть**: Вместо обращения к таблице страниц в памяти (медленно), MMU сначала проверяет TLB (быстро).

### Последовательность преобразования адреса с TLB
**Аппаратные операции (выполняются MMU)**:
1. **Извлечение номера страницы** из виртуального адреса (старшие биты)
2. **Поиск в TLB**:
   - Номер страницы используется для поиска в TLB
   - Поиск производится **параллельно** по всем записям

1. **Анализ результата поиска**:
   **Случай A: TLB Hit (попадание в кэш)**
   - Запись найдена в TLB
   - Извлекается номер физической страницы
   - Проверяется бит присутствия (Present bit)
   - Если бит = 1 → формируется физический адрес (конкатенация номера физической страницы и смещения)
   - Обращение к памяти

   **Случай B: TLB Miss (промах кэша)**
   - Записи нет в TLB
   - Обращение к таблице страниц в памяти
   - Чтение дескриптора страницы
   - Запись добавляется в TLB для последующих обращений
   - Продолжение как в случае A

   **Случай C: Page Fault**
   - Бит присутствия/отсутствия = 0 (страница на диске)
   - Управление переходит к ОС
   - Обработка страничного прерывания

**Программные операции (выполняются ОС)**:
4. **Формирование физического адреса**:
   - Номер физической страницы записывается в старшие биты выходного регистра
   - Биты смещения копируются без изменения из входящего виртуального адреса
   - Вместе они составляют полный физический адрес

5. **Обращение к памяти**:
   - Выходной регистр помещается на шину памяти
   - Производится чтение/запись данных

![[OS 58.png]]

### 4.3 Эффективность TLB
**Типичные характеристики**:
- Размер TLB: 64-1024 записи
- Время доступа: 1-2 такта процессора
- Hit rate (вероятность попадания): 95-99%

**Расчет эффективного времени доступа с TLB**:
Пусть:
- Время доступа к памяти = 100 нс
- Время поиска в TLB = 20 нс
- Hit rate = 98%

```
EAT = Время_TLB + Hit_rate × Время_памяти + Miss_rate × (Время_памяти_для_таблицы + Время_памяти_для_данных)

EAT = 20 + 0.98 × 100 + 0.02 × (100 + 100)
EAT = 20 + 98 + 4
EAT = 122 нс
```

**Без TLB**: 100 + 100 = 200 нс (обращение к таблице + обращение к данным)

**С TLB**: 122 нс — **ускорение в 1.64 раза**!

---
## Обработка страничного прерывания (Page Fault) — подробный алгоритм
### Определение ситуации
**Page Fault** возникает, когда процесс обращается к виртуальной странице, которая **отсутствует в оперативной памяти**.

### Полная последовательность обработки
**Этап 1: Возникновение прерывания**
1. Процесс выполняет инструкцию `load M` (загрузить данные из адреса M)
2. MMU обнаруживает, что бит присутствия = 0
3. Генерируется прерывание (trap)

**Этап 2: Передача управления ОС**
4. Контекст текущего процесса сохраняется
5. Управление передается обработчику прерываний ОС

**Этап 3: Анализ ситуации ОС**
ОС по таблицам определяет, что именно произошло:

**Случай A: Неверная ссылка (Invalid Reference)**
- Адрес находится **за пределами** виртуального адресного пространства процесса
- Или обращение к защищенной области памяти
- **Действие**: Работа программы **прекращается** (Segmentation Fault)

**Случай B: Обычное отсутствие страницы (Valid Page Fault)**
- Адрес корректен, но страница просто выгружена на диск
- **Действие**: Загрузка страницы в память

**Этап 4: Загрузка страницы (для случая B)**
6. **Найти незанятый фрейм в основной памяти**:
   - Если есть свободные фреймы → используем один из них
   - Если нет свободных фреймов → запускаем алгоритм замещения страниц

7. **Обращение к странице в файле подкачки на диске**:
   - ОС знает местоположение страницы в swap-файле
   - Инициируется операция чтения с диска

8. **Считывание содержимого страницы в выбранный фрейм**:
   - Данные копируются с диска в оперативную память
   - Это долгая операция (миллисекунды)

9. **Изменение элемента таблицы страниц**:
   - Validation bit устанавливается равным 1 (v — страница в памяти)
   - Номер физического фрейма записывается в дескриптор
   - При необходимости обновляется TLB

**Этап 5: Возобновление выполнения**
10. **Продолжить работу программы**:
    - Программа после прерывания **продолжается с той же команды**, которая была прервана
    - Теперь при повторном выполнении `load M` обращение к странице произойдет успешно

![[OS 59.png]]
### Важные детали
**Почему команда выполняется заново?**
- При прерывании указатель команд (Program Counter) **не увеличивается**
- После обработки page fault управление возвращается к той же инструкции
- Это гарантирует корректное выполнение программы

**Прозрачность для программы**:
- Программа **не знает**, что произошел page fault
- Для нее это просто более медленное обращение к памяти
- Прозрачность — ключевое свойство виртуальной памяти
---

## Замещение страниц при отсутствии свободных фреймов
### Проблема
На этапе поиска свободного фрейма возможна ситуация: **все физические страницы заняты**.

**Решение**: ОС должна выполнить **замещение страницы (page replacement)** — найти страницу, загруженную в память, но реально не используемую, и выгрузить ее.

### Критерии выбора страницы для вытеснения
**Цель**: Минимизировать количество page faults в будущем.

**Хорошая страница для вытеснения**:
- Не будет использоваться в ближайшем будущем
- Не была модифицирована (не нужно записывать на диск)

**Плохая страница для вытеснения**:
- Будет нужна в ближайшее время (сразу вызовет новый page fault)
- Была модифицирована (требует записи на диск)

### Алгоритм замещения — общие требования
**Алгоритм замещения страниц** должен:
1. Быть эффективным (минимум page faults)
2. Выполняться быстро (минимум накладных расходов)
3. По возможности использовать аппаратную поддержку

**Важно**: Для оптимальной реализации требуется алгоритм, приводящий к **наименьшему возможному числу page faults**.

---
## Оценка производительности систем с виртуальной памятью
### Метрики производительности
**Page Fault Rate (p)** — коэффициент частоты страничных прерываний:
- **0 ≤ p ≤ 1.0**
- p = 0 → отсутствие page faults (все страницы в памяти)
- p = 1 → каждое обращение приводит к page fault (крайне плохо)
### Эффективное время доступа (Effective Access Time — EAT)
**Упрощенная формула**:
```
EAT = (1 - p) × 2 × T_mem + p × T_pf
```

Где:
- $T_{mem}$ — время доступа к памяти
- $T_{pf}$ — время обслуживания page fault
- Множитель 2 — учитывает обращение к таблице страниц и к данным

**Полная формула** (с учетом замещения):
```
EAT = (1 - p) × 2 × T_mem + p × (T_trap + k × (T_swap_out + T_swap_in) + T_restart)
```

Где:
- $T_{trap}$ — время реакции на прерывание (переключение контекста)
- k — коэффициент (0 если есть свободный фрейм, 1 если нужно вытеснение)
- $T_{swap-out}$ — время откачки страницы на диск (если она модифицирована)
- $T_{swap-in}$ — время подкачки страницы с диска
- $T_{restart}$ — время перезапуска процесса

### Пояснения к формуле EAT
**Первое слагаемое** `(1 - p) × 2 × T_mem`:
- Соответствует ситуации, когда page fault **не имеет места**
- Оценивает среднее время доступа к странице, находящейся в памяти
- Умножение на 2: одно обращение к таблице страниц, другое — к данным

**Второе слагаемое** `p × (...)`:
- Вычисляет оценку времени в случае page fault
- Взвешивается вероятностью p

**Компоненты времени обслуживания page fault**:
1. $T_{trap}$ — суммарное время реакции аппаратуры и ОС на прерывание
2. $T_{swap-out}$ (необязательная) — время откачки страницы (если требуется замещение и страница модифицирована)
3. $T_{swap-in}$ — время подкачки нужной страницы с диска
4. $T_{restart}$ — время возобновления работы программы

**Математическая интерпретация**: Если рассматривать p как **вероятность page fault**, то EAT является **математическим ожиданием** общего времени доступа к странице.

### Пример расчета
**Дано**:
- Время доступа к памяти ($T_{mem}$) = 200 нс
- Время обслуживания page fault ($T_{pf}$) = 8 мс = 8 000 000 нс
- Page fault rate (p) = 0.001 (один page fault на 1000 обращений)

**Расчет**:
```
EAT = (1 - 0.001) × 2 × 200 + 0.001 × 8 000 000
EAT = 0.999 × 400 + 8 000
EAT = 399.6 + 8 000
EAT ≈ 8 400 нс = 8.4 микросекунды
```

**Без page faults**: 2 × 200 = 400 нс

**Замедление**: 8400 / 400 = **21 раз**!

**Вывод**: Даже очень редкие page faults (0.1%) приводят к **значительному замедлению**. Критически важно минимизировать частоту page faults.

---
## Трэшинг (Thrashing) — катастрофическое падение производительности
### Определение
**Трэшинг (Thrashing, пробуксовка)** — критическая ситуация, при которой процесс находится в состоянии, когда **больше времени уходит на подкачку страниц, нежели на выполнение команд**.

**Характеристики трэшинга**:
- Высокая частота страничных прерываний
- Процессор большую часть времени простаивает, ожидая операций ввода-вывода
- Производительность системы падает катастрофически

### Механизм возникновения трэшинга
**Классический сценарий (глобальная политика замещения)**:
1. **Начальная проблема**: Процессу P1 не хватает фреймов
   - P1 часто генерирует page faults
   - При глобальном алгоритме замещения P1 начинает "отбирать" фреймы у других процессов

2. **Эффект домино**: Другие процессы (P2, P3, ...) тоже начинают испытывать нехватку фреймов
   - Все процессы начинают генерировать page faults
   - Очередь запросов к диску растет

3. **Падение загрузки процессора**:
   - Все процессы попадают в очередь ожидания I/O
   - Очередь готовых к выполнению процессов пустеет
   - Процессор простаивает

4. **Неправильная реакция ОС**:
   - ОС видит низкую загрузку процессора
   - Решает **увеличить степень мультипрограммирования** (запустить больше процессов)
   - Это приводит к **еще большему трэшингу**!

1. **Катастрофа**: Пропускная способность системы падает практически до нуля
### Зависимость частоты page faults от количества фреймов
**Общая закономерность**: Чем больше фреймов выделено процессу, тем меньше частота page faults.

```
Частота page faults
        ↑
        │  ╲
        │    ╲___
        │        ╲___
        │            ╲_____
        │                  ╲_________
        └───────────────────────────→ Количество фреймов
```

**Критическая точка**: Существует **минимальное количество фреймов**, ниже которого процесс впадает в трэшинг.

![[OS 60.png]]

### Аномалия Белэди (Belady's Anomaly)
**Удивительное явление**: Для некоторых алгоритмов замещения (например, FIFO) увеличение количества фреймов может **увеличить** количество page faults!

**Пример**:
```
Последовательность обращений: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

С 3 фреймами (FIFO):
1   1   4   5
2   2   1   3   → 9 page faults
3   3   3   4

С 4 фреймами (FIFO):
1   1   5   4
2   2   1   5   → 10 page faults!
3   3   2
4   4   3
```

**Больше фреймов, но больше page faults** — парадокс!

**Важно**: Не все алгоритмы страдают от аномалии Белэди. Алгоритмы типа LRU и оптимальный алгоритм **не подвержены** этой аномалии.

![[OS 61.png]]

### Трэшинг при локальной политике замещения
При **локальной политике** замещения:
- Процесс может вытеснять только свои собственные страницы
- Один процесс в трэшинге **не влияет напрямую** на другие процессы

**Однако**:
- Процесс в трэшинге много времени проводит в очереди к дисковому устройству
- Это **затрудняет подкачку страниц** для остальных процессов
- Общая производительность системы все равно страдает, хотя и не так катастрофически

### Важный вывод
**Критическая ситуация трэшинга возникает вне зависимости от конкретных алгоритмов замещения.**

**Единственный теоретически идеальный алгоритм** — оптимальный (заменяющий страницу, которая будет использована позже всех) — гарантирует отсутствие трэшинга, но **не реализуем на практике**, так как требует знания будущего.

---
## Модель рабочего множества (Working Set Model)
### Мотивация
**Проблема**: Как узнать, сколько фреймов реально нужно процессу?

**Идея Деннинга**: Использовать **модель рабочего множества**, основанную на **принципе локальности** обращений к памяти.

### Принцип локальности ссылок
**Принцип локальности** — фундаментальное свойство программ, заключающееся в том, что в любой момент времени процесс активно использует **небольшое подмножество** своих страниц.

**Типы локальности**:
1. **Временна́я локальность**:
   - Если обратились к странице сейчас, вероятно обратимся к ней снова в ближайшее время
   - Пример: циклы, часто вызываемые функции

2. **Пространственная локальность**:
   - Если обратились к странице, вероятно обратимся к соседним страницам
   - Пример: последовательная обработка массива

### Определение рабочего множества
**Рабочее множество W(t, T)** — набор страниц {P₁, P₂, ..., Pₙ}, к которым процесс обращался в течение последних T обращений к памяти в момент времени t.

**Параметры**:
- **t** — текущий момент времени
- **T** — размер окна наблюдения (window size). Это количество последних обращений, которые учитываются при формировании рабочего множества.
- **W(t, T)** — множество уникальных страниц, использованных за последние T обращений

**Свойства рабочего множества**:
- Число страниц в W(t, T) является **неубывающей функцией** T
- Размер рабочего множества относительно **невелик** при правильном выборе T
- T называют **размером окна рабочего множества**

### Динамика рабочего множества
**Начало работы процесса** (cold start):
- Процесс не имеет страниц в памяти (подкачка по требованию)
- При выполнении первой инструкции → page fault (подкачка кода)
- При обращении к глобальным переменным → page fault (подкачка данных)
- При использовании стека → page fault (подкачка стека)

**После "разогрева"**:
- Процесс собрал большую часть необходимых ему страниц
- Page faults возникают **редко**
- Процесс работает производительно

**Переход между рабочими множествами**:
- Программа обычно состоит из нескольких рабочих множеств
- Рабочие множества могут **перекрываться** (например, при вызовах процедур)
- При вызове новой функции рабочее множество **расширяется**
- При возврате из функции рабочее множество **сужается**

![[OS 62.png]]

### Формализация принципа локальности
**Формальное выражение**: Если в период времени **(t - T, t)** программа обращалась к страницам W(t, T), то при **надлежащем выборе T** с **большой вероятностью** программа будет обращаться к тем же страницам в период времени **(t, t + T)**.

**Интерпретация**: Принцип локальности утверждает, что **прошлое предсказывает будущее** — если не слишком далеко заглядывать вперед.

**Важно**: С течением времени рабочий набор процесса может изменяться:
- По составу страниц
- По их числу

### Рабочее множество и трэшинг
**Ключевое утверждение**: Если процессу выделять **меньше фреймов**, чем требуется для поддержки его рабочего множества, он будет находиться в состоянии **трэшинга**.

**Следствие**: Для предотвращения трэшинга необходимо:
```
Количество выделенных фреймов ≥ |W(t, T)|
```

### Управление памятью на основе рабочего множества
**Наиболее важное свойство** рабочего множества — его **размер**. ОС должна:
1. **Выделить каждому процессу достаточное число фреймов** для размещения его рабочего множества
2. **Если кадры еще остались** → может быть инициирован другой процесс (увеличить степень мультипрограммирования)
3. **Если рабочие множества не помещаются в память** и начинается трэшинг → один из процессов можно **выгрузить на диск** целиком (уменьшить степень мультипрограммирования)

**Стратегия**:
```
Суммарный размер рабочих множеств всех процессов ≤ Количество доступных фреймов
```

Если неравенство не выполняется — выгружаем процесс с наименьшим приоритетом.

---
## Отслеживание рабочего множества
### Проблема измерения
Решение о размещении процессов в памяти должно базироваться на размере их рабочих множеств. Но как определить этот размер?

### Метод на основе времени последнего использования
**Идея**: Включить в состав атрибутов страницы **время последнего использования** tᵢ (для страницы с номером i).

**Критерий принадлежности** i-й страницы к рабочему набору в момент времени t с параметром T:
```
t - T < tᵢ ≤ t
```

**Реализация**:
1. При каждом обращении к странице обновляется tᵢ (записывается текущее время)
2. Периодически (например, при page fault) система просматривает таблицу страниц
3. Страницы, удовлетворяющие неравенству, составляют рабочее множество
4. Страницы вне рабочего множества — кандидаты на вытеснение

**Алгоритм WSClock** (Working Set Clock) — эффективная реализация этого подхода, подробно описана в книге Таненбаума.

### Метод отслеживания страничных прерываний
**Альтернативный подход**: Отслеживать **количество page faults**, генерируемых процессом.

**Логика работы**:
1. **Высокая частота page faults** + **память не слишком заполнена**:
   - Процессу не хватает фреймов
   - Система **увеличивает** число выделенных ему кадров

2. **Низкая частота page faults** в течение некоторого времени:
   - Процесс не использует все выделенные фреймы
   - Уровень генерации ниже порога
   - Число кадров процесса может быть **урезано**

3. **Динамическая регулировка**:
   - Размер множества страниц процесса изменяется автоматически
   - Реагирует на фактическое поведение процесса

**Преимущества**:
- Не требует явного вычисления рабочего множества
- Адаптируется к изменениям в поведении процесса
- Не требует дополнительной настройки системы

**Недостатки**:
- Возможна "пробуксовка" в моменты перехода от одного рабочего множества к другому
- Требует дополнения алгоритмом замещения страниц

---
## Алгоритмы замещения страниц
### Критерии оценки алгоритмов
**Основной критерий**: Минимизация количества page faults.

**Дополнительные критерии**:
- Простота реализации
- Накладные расходы (время выполнения)
- Требования к аппаратной поддержке
- Отсутствие аномалии Белэди

### 1) Оптимальный алгоритм (OPT, Optimal)
**Идея**: Заменять страницу, которая **не будет использоваться дольше всех** в будущем.

**Алгоритм**:
1. Для каждой страницы в памяти определить, через сколько обращений она будет использована
2. Выбрать страницу с максимальным "временем до использования"
3. Если страница не будет использоваться вообще — выбрать ее

**Пример**:
```
Последовательность: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
3 фрейма

Каждая страница помечается количеством команд до следующего обращения к ней

1[3]  1[5]  1[2]  1[1]  5[4]
2[4]  2[1]  2[2]  2[1]  2[1]
3[X]  3[5]  3[1]  4[4]  4[1]

→ 7 page faults (минимально возможное число)
```
**Проблема**: Алгоритм **не реализуем на практике**, так как требует **знания будущего**!

**Применение**: Используется как **эталон** для сравнения других алгоритмов.

---
### 2) FIFO (First In, First Out) — Первым пришел, первым ушел
**Идея**: Заменять страницу, которая **дольше всех находится в памяти**.

**Реализация**:
- Поддерживается очередь страниц в порядке их загрузки
- Новая страница добавляется в конец очереди
- При замещении удаляется страница из начала очереди

**Пример**:
```
Последовательность: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
3 фрейма

1   1         4       5
    2   2         1       3   → 9 page faults
        3   3         3       4

Стрелка указывает на страницу-кандидата на вытеснение
```

**Преимущества**:
- Простота реализации
- Минимальные накладные расходы

**Недостатки**:
- Не учитывает частоту использования страниц
- **Подвержен аномалии Белэди**
- Может вытеснить часто используемые страницы

**Аномалия Белэди для FIFO**:
```
С 4 фреймами → 10 page faults (больше, чем с 3 фреймами!)
```

---
### 3) LRU (Least Recently Used) — Дольше всех не использовавшаяся
**Идея**: Заменять страницу, которая **не использовалась дольше всех** (к которой не обращались дольше всех).

**Обоснование**: Если страница долго не использовалась, вероятно, она не понадобится и в ближайшем будущем (принцип локальности).

**Пример**:
```
Последовательность: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
3 фрейма

1   1   1   1           5
2   2   2   2   2       2
3           5   5   4   4
    4   4       3   3   3

→ 8 page faults (лучше, чем FIFO)
```

**Преимущества**:
- Хорошо приближает оптимальный алгоритм
- **Не подвержен** аномалии Белэди
- Учитывает реальное использование страниц

**Недостатки**:
- Требует аппаратной поддержки или значительных накладных расходов
- Сложность реализации

#### 1) Реализация LRU со счетчиками
**Метод**:
1. Каждая запись таблицы страниц содержит **счетчик** (timestamp)
2. При каждом обращении к странице в счетчике устанавливается **текущее время** (или номер обращения)
3. При замещении просматриваются все счетчики
4. Выбирается страница с **минимальным значением счетчика** (самое "давнее" обращение)

**Проблемы**:
- Требуется поиск минимума среди всех страниц (O(n))
- Необходимо обновлять счетчик при каждом обращении
- Может произойти переполнение счетчика

#### 2) Реализация LRU с помощью стека
**Метод**:
1. Создать **стек номеров страниц** с двойными связями (doubly-linked list)
2. **При ссылке на страницу**:
   - Переместить ее номер на **вершину стека**
   - Изменить до 6 указателей (убрать из середины, вставить в начало)
3. **При замещении**: страница в **нижней части стека** — кандидат на вытеснение

**Преимущество**: **Не нужно искать** страницу для замещения — она всегда внизу стека!

**Структура**:
```
Вершина стека → Недавно использованная страница
   ↓
   ↓
   ↓
Дно стека → Давно не использованная страница (кандидат на вытеснение)
```

**Операции над стеком**:
- Обращение к странице X → извлечь X из текущей позиции → вставить X на вершину
- Замещение → взять страницу со дна стека
---
### 4) Алгоритм "Вторая попытка" (Second Chance)
**Идея**: Улучшить FIFO, давая шанс часто используемым страницам остаться в памяти.

**Использует бит R (Reference bit)**:
- R = 1: к странице обращались недавно
- R = 0: к странице не обращались с последней проверки

**Алгоритм**:
1. Страницы организованы в **связный список** (как в FIFO)
2. Самая старая страница — **первый кандидат** на вытеснение
3. **Проверка бита R**:
   - Если R = 0 → вытеснить страницу
   - Если R = 1 → **дать второй шанс**:
     - Сбросить R в 0
     - Переместить страницу в **конец очереди** (как будто только загрузили)
     - Перейти к следующей странице
4. Повторять до нахождения страницы с R = 0

**Пример работы**:
```
Очередь страниц: [A(R=1)] → [B(R=0)] → [C(R=1)] → [D(R=0)]
                   ↑
                 старейшая

Шаг 1: A имеет R=1 → сбросить R в 0, переместить в конец
       [B(R=0)] → [C(R=1)] → [D(R=0)] → [A(R=0)]
       
Шаг 2: B имеет R=0 → вытеснить B
```

**Преимущества**:
- Проще, чем LRU
- Учитывает использование страниц
- Дает часто используемым страницам шанс остаться

**Недостатки**:
- В худшем случае просматривается вся очередь
- Если все страницы имеют R=1, вырождается в FIFO
---
### 5) Алгоритм "Часы" (Clock Algorithm)
**Идея**: Оптимизация алгоритма "Вторая попытка" с использованием кольцевого буфера.

**Структура данных**: Страницы организованы в **кольцевой список**, указатель ("стрелка часов") движется по кругу.

**Алгоритм**:
1. Указатель указывает на текущую страницу-кандидата
2. **Проверка бита R** текущей страницы:
   - Если R = 0 → **вытеснить** эту страницу, загрузить новую на ее место
   - Если R = 1 → **сбросить R в 0**, передвинуть указатель на следующую страницу
3. Повторять до нахождения страницы с R = 0

**Преимущества**:
- Эффективная реализация (не нужно перемещать элементы)
- Простая структура данных
- Хорошая производительность на практике

**Используется**: В реальных ОС (Linux, Windows) в различных модификациях.

![[OS 63.png]]

---
### 6) Алгоритм NRU (Not Recently Used) — Не использовавшийся недавно

**Идея**: Классифицировать страницы на основании **двух битов**: R (Reference) и M (Modified/Dirty).

**Классы страниц** (в порядке предпочтения для вытеснения):

| Класс | R   | M   | Описание                         | Приоритет вытеснения                                |
| ----- | --- | --- | -------------------------------- | --------------------------------------------------- |
| 0     | 0   | 0   | Не обращались, не модифицирована | **Высший** (вытеснить в первую очередь)             |
| 1     | 0   | 1   | Не обращались, но модифицирована | Высокий                                             |
| 2     | 1   | 0   | Обращались, не модифицирована    | Средний                                             |
| 3     | 1   | 1   | Обращались, модифицирована       | **Низший** (не вытеснять без крайней необходимости) |

**Алгоритм**:
1. Периодически (например, при прерывании таймера) **бит R сбрасывается** для всех страниц
2. При замещении:
   - Классифицировать все страницы по 4 классам
   - **Выбрать случайную страницу из низшего непустого класса**
3. Если класс 0 не пустой → вытеснить страницу из него (быстро — не нужно записывать на диск)

**Преимущества**:
- Учитывает как использование (R), так и модификацию (M)
- Избегает записи на диск немодифицированных страниц
- Прост в реализации

**Использование**: Часто применяется в сочетании с алгоритмом "Часы" (Clock-NRU).

---
## Вопросы разработки систем со страничной организацией
### 1) Политика распределения — локальная или глобальная
**Локальная политика**:
- Процесс может заменять только **свои собственные** страницы
- Изолирует процессы друг от друга
- Может быть неэффективна (одни процессы имеют избыток памяти, другие — недостаток)

**Глобальная политика**:
- Процесс может заменять страницы **любого процесса** в системе
- Более эффективное использование памяти
- Риск трэшинга распространяется на всю систему

### 2) Распределение фреймов между процессами
**Минимум фреймов**: Каждому процессу необходим **минимум страниц** для выполнения.

**Пример (IBM 370)**: Инструкция SS MOVE может потребовать до **6 страниц**:
- Сама инструкция (6 байт) может быть "размазана" на **2 страницы**
- **2 страницы** для источника (from)
- **2 страницы** для назначения (to)

**Схемы размещения**:
1. **Фиксированное размещение**:
   - **Равное**: все процессы получают одинаковое количество фреймов
     ```
     Пример: 100 фреймов на 5 процессов → по 20 фреймов каждому
     ```
   - **Пропорциональное**: фреймы выделяются пропорционально размеру процесса
     ```
     Формула: a(i) = s(i) × m / S
     
     Где:
       s(i) — размер процесса i
       S — суммарный размер всех процессов
       m — общее количество фреймов
       a(i) — выделяется процессу i
     ```

2. **Приоритетное размещение**:
   - Используется пропорциональная схема, но не с размерами, а с **приоритетами**
   - **При page fault процесса P(i)**:
     - Можно заменить один из его фреймов (локальный подход)
     - Или заменить фрейм процесса с **меньшим приоритетом** (глобальный подход)

### 3) Размер страницы
**Факторы выбора размера страницы**:

| Размер | Преимущества | Недостатки |
|--------|--------------|------------|
| **Маленький** (1-2 КБ) | • Меньше внутренняя фрагментация<br>• Лучшая локальность<br>• Меньше неиспользуемого кода в памяти | • Больше таблица страниц<br>• Больше накладные расходы на управление<br>• Больше page faults |
| **Большой** (4-64 КБ) | • Меньше таблица страниц<br>• Меньше накладные расходы<br>• Быстрее работа с диском | • Больше внутренняя фрагментация<br>• Больше неиспользуемого кода в памяти |

**Современная тенденция**: 4 КБ (стандарт), с поддержкой **больших страниц** (Huge Pages) до 2 МБ или 1 ГБ для специальных приложений (базы данных, научные вычисления).

### 4) Отдельные пространства для команд и данных
**Идея**: Разделить адресное пространство на независимые сегменты:
- **I-space** (Instruction space) — для кода
- **D-space** (Data space) — для данных

**Преимущества**:
- Независимое управление
- Защита кода от перезаписи
- Возможность разделения кода между процессами

### 5) Совместное использование страниц
**Применение**:
- Разделяемые библиотеки (shared libraries): libc.so, kernel32.dll
- Код программы между родительским и дочерним процессами (с Copy-on-Write)
- Общие данные между процессами (shared memory)

**Требования**:
- Страницы помечаются как разделяемые
- Read-only для кода
- Read-write для данных (требует синхронизации)

### 6) Очистка страниц (Page Cleaning)
**Проблема**: Запись модифицированных (dirty) страниц на диск — медленная операция, блокирующая процесс при page fault.

**Решение**: **Фоновая очистка** (background page cleaning):
- Периодически **daemon-процесс** (paging daemon) просматривает страницы
- Находит модифицированные страницы (M = 1)
- **Записывает их на диск** заранее (не дожидаясь page fault)
- **Сбрасывает бит M** в 0
- Страница остается в памяти, но теперь "чистая"

**Преимущество**: При page fault не нужно ждать записи на диск — страницу можно просто заменить.
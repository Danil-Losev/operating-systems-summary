#Operating_Systems #OS_Processes 

## Введение
В предыдущей части были рассмотрены программные алгоритмы синхронизации процессов, которые имели существенный недостаток — **занятое ожидание (busy wait)**. В этой части рассматриваются более эффективные методы синхронизации, которые не тратят процессорное время впустую.

### Напоминание: основные проблемы программных алгоритмов
1. **Занятое ожидание (Busy Wait):**
   - Процедура ожидания входа в критический участок включает вращение процесса в пустом цикле
   - Впустую расходуется драгоценное время процессора
   - Снижается общая производительность системы

2. **Инверсия приоритетов (Priority Inversion):**
   - Высокоприоритетный процесс блокируется низкоприоритетным
   - Может привести к тупиковой ситуации
   - Нарушает предсказуемость системы
---
## Аппаратная поддержка синхронизации
Для решения проблем программных алгоритмов современные процессоры предоставляют специальные атомарные инструкции.
### 1. Команда Test-and-Set
**Команда Test-and-Set** — это атомарная операция, которая проверяет значение логической переменной и одновременно устанавливает её в определённое состояние.
#### Описание операции
Операция Test-and-Set выполняется **атомарно** (как единое целое, без прерываний) и имеет следующую семантику:
```c
// Псевдокод атомарной операции Test-and-Set
boolean Test_and_Set(boolean *target) {
    boolean old_value = *target;  // Сохраняем старое значение
    *target = true;                // Устанавливаем в true
    return old_value;              // Возвращаем старое значение
}
```

**Ключевое свойство:** Всё это выполняется как **одна неделимая операция**, которую невозможно прервать.

#### Использование Test-and-Set для синхронизации
С использованием этой атомарной команды можно модифицировать алгоритм с переменной-замком:
```c
shared boolean lock = false;  // Замок для критической секции

// Для процесса Pi:
while (some_condition) {
    // Вход в критическую секцию
    while (Test_and_Set(&lock)) {
        // Ждём, пока lock не станет false
        // Test_and_Set вернёт true, если lock был true
        // И установит lock в true
    }
    
    // КРИТИЧЕСКАЯ СЕКЦИЯ
    critical_section();
    
    // Выход из критической секции
    lock = false;  // Освобождаем замок
    
    // Остальная часть программы
    remainder_section();
}
```

**Как это работает:**
1. Если lock == false (свободно), Test_and_Set вернёт false, установит lock = true, процесс входит в КС
2. Если lock == true (занято), Test_and_Set вернёт true, lock останется true, процесс продолжает ждать

#### Преимущества
✓ Решает проблему некорректного алгоритма с переменной-замком
✓ Гарантирует взаимное исключение
✓ Простота реализации

#### Недостатки
**К сожалению, даже в таком виде полученный алгоритм не удовлетворяет условию ограниченного ожидания.**

**Проблема:** 
- Процесс может ждать бесконечно долго, даже если другие процессы многократно входят и выходят из критической секции
- Нет гарантии справедливости (fairness)
- Возможно "голодание" (starvation) отдельных процессов
### 2. Команда Swap (Exchange)
**Команда Swap** — это ещё одна атомарная операция, которая обменивает значения двух переменных.
#### Описание операции
```c
// Псевдокод атомарной операции Swap
void Swap(boolean *a, boolean *b) {
    boolean temp = *a;
    *a = *b;
    *b = temp;
}
```

Операция выполняется **атомарно** — обмен значений происходит как единое целое.
#### Использование Swap для синхронизации
Применяя атомарную команду Swap, можно реализовать алгоритм с дополнительной локальной переменной:
```c
shared boolean lock = false;  // Общий замок

// Для процесса Pi:
while (some_condition) {
    boolean key = true;  // Локальная переменная
    
    // Вход в критическую секцию
    do {
        Swap(&lock, &key);  // Обмениваем значения
    } while (key == true);  // Продолжаем, пока key == true
    
    // КРИТИЧЕСКАЯ СЕКЦИЯ
    critical_section();
    
    // Выход из критической секции  
    lock = false;  // Освобождаем замок
    
    // Остальная часть программы
    remainder_section();
}
```

**Как это работает:**
1. Изначально: lock = false, key = true
2. После Swap: lock = true, key = false → процесс входит в КС
3. Если lock уже был true: после Swap lock остаётся true, key становится true → процесс ждёт
4. При выходе: lock устанавливается в false, следующий процесс может войти

#### Анализ
**Преимущества:**
✓ Гарантирует взаимное исключение
✓ Использует аппаратную поддержку

**Недостатки:**
✗ Всё ещё использует busy waiting
✗ Может не удовлетворять условию ограниченного ожидания
✗ Расходует процессорное время на ожидание

---
## Примитивы межпроцессорного взаимодействия
Для решения проблемы busy wait были предложены специальные примитивы, позволяющие процессу блокироваться вместо вращения в цикле.

### Базовые примитивы Sleep и Wakeup
**Sleep()** — переводит вызвавший процесс в состояние ожидания (блокировки), освобождая процессор для других процессов.

**Wakeup(pid)** — запускает (пробуждает) процесс с идентификатором pid, переводя его из состояния ожидания в состояние готовности.

**Преимущества:**
- Процесс не расходует процессорное время в ожидании
- Процессор может выполнять другие задачи
- Более эффективное использование ресурсов

**Проблемы:**
- Сложность корректной реализации
- Возможность потери сигналов wakeup
- Риск возникновения race condition

#### Классическая задача Producer-Consumer
**Задача производителя-потребителя** — одна из классических задач синхронизации процессов.

**Условия задачи:**
- **Производитель (Producer)** создаёт данные и помещает их в буфер
- **Потребитель (Consumer)** извлекает данные из буфера и обрабатывает их
- Буфер имеет **ограниченный размер** (N элементов)
- Производитель не должен добавлять данные в полный буфер
- Потребитель не должен извлекать данные из пустого буфера

![[OS 33.png]]

##### Решение с помощью Sleep/Wakeup
**Общие данные:**
```c
#define N 100         // Размер буфера
int count = 0;        // Количество элементов в буфере
int buffer[N];        // Сам буфер
```

##### Код производителя (Producer)
```c
void producer() {
    int item;
    
    while (1) {
        // Производим элемент
        item = produce_item();
        
        // Если буфер полон, засыпаем
        if (count == N) {
            sleep();
        }
        
        // Помещаем элемент в буфер
        put_item(item);
        count++;
        
        // Если буфер был пуст, будим потребителя
        if (count == 1) {
            wakeup(consumer);
        }
    }
}
```

**Логика производителя:**
1. Производим новый элемент
2. Если буфер полон (count == N), засыпаем
3. Помещаем элемент в буфер
4. Увеличиваем счётчик
5. Если это первый элемент (count == 1), будим потребителя

##### Код потребителя (Consumer)
```c
void consumer() {
    int item;
    
    while (1) {
        // Если буфер пуст, засыпаем
        if (count == 0) {
            sleep();
        }
        
        // Извлекаем элемент из буфера
        item = get_item();
        count--;
        
        // Если буфер был полон, будим производителя
        if (count == N - 1) {
            wakeup(producer);
        }
        
        // Обрабатываем элемент
        consume_item(item);
    }
}
```

**Логика потребителя:**
1. Если буфер пуст (count == 0), засыпаем
2. Извлекаем элемент из буфера
3. Уменьшаем счётчик
4. Если освободили место в полном буфере (count == N-1), будим производителя
5. Обрабатываем извлечённый элемент

---
#### Проблема с примитивами Sleep/Wakeup
**Критическая проблема:** Процесс может не успеть перейти в состояние ожидания, и сигнал wakeup может быть **пропущен**.

#### Сценарий возникновения проблемы
**Ситуация с потерянным wakeup:**
1. Буфер пуст (count == 0)
2. Потребитель проверяет условие `if (count == 0)` → true
3. **Прерывание!** Планировщик передаёт управление производителю
4. Производитель создаёт элемент, помещает в буфер, count становится 1
5. Производитель проверяет `if (count == 1)` → true, вызывает `wakeup(consumer)`
6. Но потребитель ещё **НЕ СПИТ**! Сигнал wakeup **теряется**
7. Планировщик возвращает управление потребителю
8. Потребитель вызывает `sleep()` и засыпает
9. **Результат:** Потребитель спит, хотя в буфере есть данные!

**Последствия:**
- Если производитель тоже заснёт (буфер заполнится), оба процесса будут спать
- Возникает **взаимная блокировка (deadlock)**
- Система перестаёт работать

##### Причина проблемы
**Race Condition:** Между проверкой условия и вызовом sleep() может произойти прерывание, и другой процесс может изменить условие и послать wakeup.

**Вывод:** Примитивы Sleep/Wakeup в таком виде **небезопасны** и требуют дополнительных механизмов синхронизации.

---
## Механизмы синхронизации более высокого уровня
Для решения проблем низкоуровневых примитивов были разработаны механизмы синхронизации более высокого уровня:

1. **Семафоры (Semaphores)**
2. **Мониторы (Monitors)**  
3. **Передача сообщений (Message Passing)**

Эти механизмы скрывают сложность низкоуровневой синхронизации и предоставляют более безопасные и удобные интерфейсы.

---
## Семафоры (Semaphores)
**Семафор** — это специальная переменная с целочисленным значением, над которой определены две атомарные операции.
### Определение семафора
Семафор был предложен **Эдсгером Дейкстрой в 1965 году**.
**Семафор S** — это целочисленная переменная, к которой, после её инициализации, можно обращаться только через две атомарные операции:

#### Операция P (Proberen - проверить, от голландского; иногда down) 
Также называется **wait()** или **down()**
```c
P(S): 
    if (S > 0) {
        S = S - 1;  // Уменьшаем семафор
    } else {
        // Процесс блокируется
        // Процесс помещается в очередь ожидания семафора
        block();
    }
```

**Что делает P(S):**
- Если S > 0: уменьшает S на 1 и продолжает выполнение
- Если S ≤ 0: блокирует процесс (процесс засыпает в очереди семафора)
#### Операция V (Verhogen - увеличить, от голландского; иногда up)
Также называется **signal()** или **up()**
```c
V(S):
    S = S + 1;  // Увеличиваем семафор
    if (есть заблокированные процессы в очереди S) {
        // Пробуждаем один процесс из очереди
        wakeup(один_процесс_из_очереди);
    }
```

**Что делает V(S):**
- Увеличивает S на 1
- Если есть процессы, ожидающие на семафоре, пробуждает один из них

### Типы семафоров
#### Двоичный семафор (Binary Semaphore)
- Может принимать только значения 0 и 1
- Аналог мьютекса (mutex)
- Используется для взаимного исключения

#### Счётный семафор (Counting Semaphore)
- Может принимать любые неотрицательные целые значения
- Используется для управления доступом к множеству одинаковых ресурсов
- Значение семафора показывает количество доступных ресурсов

### Важные свойства семафоров
**1. Атомарность операций P и V:**
- Операции P и V выполняются как неделимые (атомарные)
- Невозможно прервать их выполнение
- Реализуется либо аппаратно, либо с помощью запрета прерываний в критической секции ядра ОС

**2. Отсутствие busy wait:**
- Процесс, не получивший ресурс, **блокируется**
- Процесс не расходует процессорное время на ожидание
- Пробуждается только когда ресурс становится доступным

**3. Очередь ожидающих процессов:**
- Каждый семафор имеет связанную с ним очередь заблокированных процессов
- При операции V один из процессов извлекается из очереди и пробуждается

### Решение задачи Producer-Consumer с помощью семафоров
Используем три семафора для корректного решения задачи:

**Инициализация семафоров:**
```c
semaphore mutex = 1;    // Для взаимного исключения (доступ к буферу)
semaphore empty = N;    // Количество пустых мест в буфере
semaphore full = 0;     // Количество заполненных мест в буфере
```

**Семантика семафоров:**
- **mutex** — двоичный семафор для защиты критической секции (доступа к буферу)
- **empty** — счётный семафор, показывает количество свободных мест
- **full** — счётный семафор, показывает количество занятых мест

#### Код производителя с семафорами
```c
void producer() {
    int item;
    
    while (1) {
        // Производим элемент
        item = produce_item();
        
        // Ждём, пока появится свободное место
        P(empty);  // Если empty == 0, блокируемся
        
        // Входим в критическую секцию
        P(mutex);
        
        // Помещаем элемент в буфер
        put_item(item);
        
        // Выходим из критической секции
        V(mutex);
        
        // Сообщаем, что добавили элемент
        V(full);  // Увеличиваем количество заполненных мест
    }
}
```

**Логика производителя:**
1. Производим элемент (вне критической секции)
2. P(empty) — ждём свободное место (если буфер полон, блокируемся)
3. P(mutex) — входим в критическую секцию
4. Помещаем элемент в буфер
5. V(mutex) — выходим из критической секции
6. V(full) — сообщаем, что добавили элемент

#### Код потребителя с семафорами
```c
void consumer() {
    int item;
    
    while (1) {
        // Ждём, пока появится элемент
        P(full);  // Если full == 0, блокируемся
        
        // Входим в критическую секцию
        P(mutex);
        
        // Извлекаем элемент из буфера
        item = get_item();
        
        // Выходим из критической секции
        V(mutex);
        
        // Сообщаем, что освободили место
        V(empty);  // Увеличиваем количество свободных мест
        
        // Обрабатываем элемент
        consume_item(item);
    }
}
```

**Логика потребителя:**
1. P(full) — ждём заполненное место (если буфер пуст, блокируемся)
2. P(mutex) — входим в критическую секцию
3. Извлекаем элемент из буфера
4. V(mutex) — выходим из критической секции
5. V(empty) — сообщаем, что освободили место
6. Обрабатываем элемент (вне критической секции)

#### Анализ решения
✓ **Взаимное исключение:** Семафор mutex гарантирует, что только один процесс может работать с буфером
✓ **Синхронизация по заполненности:** 
- Производитель блокируется, если буфер полон (empty == 0)
- Потребитель блокируется, если буфер пуст (full == 0)
✓ **Отсутствие race condition:** Операции P и V атомарны
✓ **Отсутствие busy wait:** Процессы блокируются, не расходуя процессорное время
✓ **Отсутствие потерянных сигналов:** Семафоры сохраняют количество сигналов

### Важность порядка операций с семафорами
**КРИТИЧЕСКАЯ ПРОБЛЕМА:** Порядок выполнения операций P над семафорами **имеет огромное значение**!

#### Неправильный порядок — возможен deadlock
**Ошибочный код производителя:**
```c
void producer() {
    item = produce_item();
    
    P(mutex);   // НЕПРАВИЛЬНО! Сначала захватываем mutex
    P(empty);   // Потом пытаемся ждать свободное место
    
    put_item(item);
    
    V(mutex);
    V(full);
}
```

**Сценарий deadlock:**
1. Производитель входит в критическую секцию: P(mutex) → mutex = 0
2. Буфер полон, производитель выполняет P(empty) → блокируется
3. Потребитель пытается извлечь элемент
4. Потребитель не может войти в критическую секцию (mutex == 0, захвачен производителем)
5. **Результат:** Производитель ждёт освобождения места, удерживая mutex. Потребитель не может освободить место, так как не может захватить mutex. **DEADLOCK!**

**Вывод:** При работе с семафорами необходимо тщательно продумывать порядок операций, чтобы избежать deadlock!

---
## Мониторы (Monitors)
**Монитор** — это высокоуровневый механизм синхронизации, встроенный в язык программирования.
### Концепция мониторов
Мониторы были предложены **Хором (Hoare)** и **Хансеном (Hansen)** в начале 1970-х годов.
**Монитор** представляет собой:
- **Тип данных**, который может быть внедрён в объектно-ориентированные языки программирования
- **Инкапсулированный** набор переменных и процедур
- **Механизм автоматического** обеспечения взаимного исключения

### Основные характеристики мониторов
#### 1. Собственные переменные
- Монитор обладает своими собственными переменными, определяющими его состояние
- Эти переменные **недоступны извне** монитора напрямую

#### 2. Методы (процедуры)
- Значения переменных монитора могут быть изменены **только** с помощью вызова функций-методов, принадлежащих монитору
- Эти функции-методы могут использовать только:
	  - Данные внутри монитора
	  - Свои параметры
	  - Локальные переменные
#### 3. Автоматическое взаимное исключение
**Важнейшее свойство:** В любой момент времени **только один процесс** может быть активен (находиться в состоянии готовности или исполнения) внутри данного монитора.

**Как это достигается:**
- Компилятор может отличить вызов функции монитора от вызовов других функций
- Компилятор обрабатывает такие вызовы специальным образом
- Автоматически добавляется **пролог и эпилог**, реализующий взаимоисключение

**Преимущества:**
✓ Обязанность конструирования механизма взаимоисключений возложена на компилятор, а не на программиста
✓ Работа программиста существенно упрощается
✓ Вероятность появления ошибок становится меньше

### Структура монитора
На абстрактном уровне структуру монитора можно описать следующим образом:
```pascal
monitor MonitorName {
    // ПЕРЕМЕННЫЕ МОНИТОРА (приватные)
    // Определяют состояние монитора
    // Доступны только внутри монитора
    
    // МЕТОДЫ МОНИТОРА (публичные)
    // Единственный способ доступа к данным монитора
    
    void m1(...) {
        // Тело метода 1
        // Может работать с переменными монитора
    }
    
    void m2(...) {
        // Тело метода 2
    }
    
    ...
    
    void mn(...) {
        // Тело метода n
    }
    
    // БЛОК ИНИЦИАЛИЗАЦИИ
    {
        // Код инициализации внутренних переменных
        // Выполняется один раз при создании монитора
    }
}
```

**Свойства:**
- Методы выполняются с автоматическим взаимным исключением
- Если процесс выполняет метод монитора, другие процессы, вызывающие методы этого монитора, блокируются
- После завершения метода один из ожидающих процессов получает доступ

---
### Условные переменные (Condition Variables)
Одних только взаимоисключений недостаточно для полноценного решения задач синхронизации. Нужны средства организации очередности процессов, подобно семафорам full и empty.

**Условная переменная** — специальная переменная, над которой определены две операции:
#### Операция wait
```pascal
condition.wait();
```

**Что делает wait:**
- Если функция монитора не может выполняться дальше, пока не наступит некоторое событие, она выполняет операцию wait над условной переменной
- Процесс, выполнивший операцию wait, **блокируется** и становится неактивным
- Процесс помещается в очередь ожидания этой условной переменной
- Другой процесс получает возможность войти в монитор

**Важно:** При выполнении wait процесс **освобождает монитор**, позволяя другим процессам войти в него.

#### Операция signal
```pascal
condition.signal();
```

**Что делает signal:**
- Когда ожидаемое событие происходит, процесс внутри функции-метода совершает операцию signal над той же самой условной переменной
- Это приводит к **пробуждению** ранее заблокированного процесса
- Если несколько процессов ожидали на этой переменной, активным становится **только один** из них

### Семантика signal: Hoare vs Hansen
**Проблема:** Что делать, чтобы у нас не оказалось **двух процессов** (разбудившего и пробуждённого) одновременно активных внутри монитора?

#### Подход Хора (Hoare)
- Пробуждённый процесс **подавляет** исполнение разбудившего процесса
- Пробуждённый процесс немедленно начинает выполнение
- Разбудивший процесс ждёт, пока пробуждённый не покинет монитор

#### Подход Хансена (Hansen)
- Разбудивший процесс **покидает монитор немедленно** после исполнения операции signal
- Пробуждённый процесс начинает выполнение

**Мы будем придерживаться подхода Хансена** — разбудивший процесс должен немедленно завершить выполнение метода после signal.

**Следствие:** Операция signal обычно является **последней операцией** в методе монитора.

---
### Решение задачи Producer-Consumer с помощью монитора
```pascal
monitor ProducerConsumer {
    // Условные переменные
    condition full, empty;
    
    // Переменная состояния
    int count;
    
    // Метод для производителя
    void put() {
        // Если буфер полон, ждём
        if (count == N) {
            full.wait();
        }
        
        // Помещаем элемент в буфер
        put_item();
        count += 1;
        
        // Если буфер был пуст, сообщаем потребителю
        if (count == 1) {
            empty.signal();
        }
    }
    
    // Метод для потребителя
    void get() {
        // Если буфер пуст, ждём
        if (count == 0) {
            empty.wait();
        }
        
        // Извлекаем элемент из буфера
        get_item();
        count -= 1;
        
        // Если буфер был полон, сообщаем производителю
        if (count == N - 1) {
            full.signal();
        }
    }
    
    // Блок инициализации
    {
        count = 0;
    }
}
```

#### Код производителя
```pascal
void producer() {
    while (1) {
        // Производим элемент (вне монитора)
        produce_item();
        
        // Вызываем метод монитора
        ProducerConsumer.put();
    }
}
```

#### Код потребителя
```pascal
void consumer() {
    while (1) {
        // Вызываем метод монитора
        ProducerConsumer.get();
        
        // Обрабатываем элемент (вне монитора)
        consume_item();
    }
}
```

#### Анализ решения
**Преимущества:**
✓ **Простота:** Код значительно проще, чем с семафорами
✓ **Безопасность:** Взаимное исключение обеспечивается автоматически
✓ **Нет риска deadlock** из-за неправильного порядка операций
✓ **Читаемость:** Логика синхронизации понятна и естественна

**Как это работает:**
1. Взаимное исключение обеспечивается компилятором автоматически
2. Условные переменные full и empty управляют синхронизацией
3. Процесс блокируется при wait и освобождает монитор
4. Процесс пробуждается при signal

**Сравнение с семафорами:**
- Нет необходимости явно захватывать/освобождать мьютекс
- Нет риска забыть освободить мьютекс
- Невозможно перепутать порядок операций блокировки

### Реализация мониторов
**Требования:**
Реализация мониторов требует разработки специальных языков программирования и компиляторов для них.

**Языки с поддержкой мониторов:**
- **Concurrent Pascal** (Параллельный Паскаль)
- **Concurrent Euclid** (Параллельный Евклид)
- **Java** (встроенная поддержка через synchronized)
- **C#** (через lock и Monitor класс)

**Проблема эмуляции:**
Эмуляция мониторов с помощью системных вызовов для обычных широко используемых языков программирования **не так проста**, как эмуляция семафоров.

**Альтернатива:**
Можно пользоваться ещё одним механизмом со скрытыми взаимоисключениями — **передачей сообщений**.

---
## Передача сообщений (Message Passing)
**Передача сообщений** — механизм синхронизации и коммуникации процессов через отправку и получение сообщений.

### Примитивы send и receive
Базовые операции для обмена сообщениями:

#### Прямая адресация (к процессу)
```c
send(P, message)      // Послать сообщение message процессу P
receive(Q, message)   // Получить сообщение message от процесса Q
```

**Характеристики:**
- Процессы обращаются друг к другу напрямую по идентификатору
- Требуется знание идентификатора процесса-партнёра

#### Непрямая адресация (через почтовый ящик)
```c
send(A, message)      // Послать сообщение message в почтовый ящик A
receive(A, message)   // Получить сообщение message из почтового ящика A
```

**Характеристики:**
- Процессы общаются через промежуточный объект (mailbox, port, channel)
- Процессам не нужно знать друг о друге
- Один mailbox может использоваться многими процессами

### Встроенная синхронизация
**Важное свойство:** Примитивы send и receive уже имеют **скрытый от наших глаз механизм взаимоисключения**.

**Автоматическая блокировка:**
- При чтении из **пустого буфера** процесс **блокируется**
- При записи в **полностью заполненный буфер** процесс **блокируется**
- Механизм блокировки реализуется на уровне операционной системы

### Решение Producer-Consumer с передачей сообщений
Реализация решения задачи producer-consumer для таких примитивов становится **неприлично тривиальной**:
```c
#define N 100  // Размер буфера сообщений

void producer() {
    message msg;
    
    while (1) {
        // Производим элемент
        produce_item(&msg);
        
        // Отправляем в канал (mailbox)
        send(MAILBOX, msg);
    }
}

void consumer() {
    message msg;
    
    while (1) {
        // Получаем из канала (блокируемся, если пусто)
        receive(MAILBOX, &msg);
        
        // Обрабатываем элемент
        consume_item(&msg);
    }
}
```

**Анализ:**
✓ **Простота:** Самое простое решение из всех рассмотренных
✓ **Безопасность:** Синхронизация встроена в примитивы
✓ **Нет явного управления** счётчиками, семафорами, условными переменными

### Преимущества и недостатки

**Преимущества:**
✓ Простота использования
✓ Встроенная синхронизация и взаимное исключение
✓ Подходит для распределённых систем
✓ Процессам не нужно разделять память

**Недостатки:**
✗ **Низкая производительность:** Несмотря на простоту использования, передача сообщений в пределах одного компьютера происходит **существенно медленнее**, чем работа с семафорами и мониторами
✗ Накладные расходы на копирование данных
✗ Больше системных вызовов

**Когда использовать:**
- В распределённых системах (между компьютерами)
- Когда простота важнее производительности
- Когда процессы не разделяют память

---
## Эквивалентность механизмов синхронизации
### Теоретическая эквивалентность
**Важный факт:** Семафоры, мониторы и передача сообщений являются **теоретически эквивалентными** — любой из них можно реализовать через другой.

**Это означает:**
- Можно реализовать семафоры с помощью мониторов
- Можно реализовать мониторы с помощью семафоров
- Можно реализовать любой из них через передачу сообщений

### Реализация семафоров через очереди сообщений
**Пример:** Семафор можно реализовать через mailbox с сообщениями:
```c
// Инициализация семафора со значением N
void init_semaphore(mailbox_t sem, int N) {
    for (int i = 0; i < N; i++) {
        send(sem, TOKEN);  // Отправляем N токенов
    }
}

// Операция P
void P(mailbox_t sem) {
    message token;
    receive(sem, &token);  // Получаем токен (блокируемся, если пусто)
}

// Операция V
void V(mailbox_t sem) {
    send(sem, TOKEN);  // Отправляем токен обратно
}
```

**Как это работает:**
- Количество сообщений в mailbox соответствует значению семафора
- P — извлекает сообщение (уменьшает счётчик)
- V — добавляет сообщение (увеличивает счётчик)
- Блокировка при пустом mailbox реализует блокировку при S ≤ 0

### Реализация мониторов через семафоры
Монитор можно реализовать, используя:
- Один семафор для взаимного исключения (mutex)
- По семафору для каждой условной переменной
- Дополнительные счётчики для управления очередями

**Вывод:** Выбор механизма синхронизации зависит от:
- Доступности в языке программирования / ОС
- Требований к производительности
- Удобства использования
- Специфики задачи

---
## Классические задачи синхронизации
Для демонстрации и анализа механизмов синхронизации используются классические задачи:

1. **Проблема обедающих философов** (Dining Philosophers Problem)
2. **Проблема читателей и писателей** (Readers-Writers Problem)
3. **Проблема спящего брадобрея** (Sleeping Barber Problem)
4. **Задача производителя-потребителя** (Producer-Consumer Problem)
5. **Задача об ограниченном буфере** (Bounded Buffer Problem)

Эти задачи были предложены **Эдсгером Дейкстрой в 1965 году** и стали классическими примерами для изучения синхронизации.

---

## Проблема обедающих философов
### Описание задачи
**Дейкстра, 1965 год:** Одна из самых известных задач синхронизации.
![[OS 34.png]]

**Условия:**
- За круглым столом сидят **пять философов**
- Перед каждым философом — тарелка с едой
- Между каждой парой философов лежит **одна палочка для еды**
- Всего палочек — **пять штук**

**Поведение философов:**
- **Жизнь философа** состоит из двух действий:
  1. **Размышление** (thinking)
  2. **Еда** (eating)

**Правила:**
- Для еды философу нужны **две палочки** (левая и правая)
- Философ берёт палочки по одной
- После еды философ кладёт **обе палочки** обратно на стол
- Затем возвращается к размышлениям
### Постановка проблемы
**Задача:** Можно ли написать алгоритм, моделирующий действия философов и **никогда не застревающий**?

**Требования:**
1. Философы не должны умереть от голода (нет starvation)
2. Не должно быть взаимоблокировки (нет deadlock)
3. Максимальный параллелизм (несколько философов могут есть одновременно)

### Возможные решения

#### Решение 1: Нечётное правило
- Нечётные философы берут сначала левую, потом правую палочку
- Чётные философы берут сначала правую, потом левую палочку
- Это нарушает симметрию и предотвращает deadlock

#### Решение 2: Ограничение на количество
- Разрешаем **не более 4 философов** одновременно пытаться взять палочки
- Используем семафор, ограничивающий количество сидящих за столом

#### Решение 3: Атомарное взятие двух палочек
- Философ берёт обе палочки одновременно (в критической секции)
- Если обе доступны — берёт, иначе — ждёт

#### Решение 4: Проверка доступности
- Философ проверяет, доступны ли обе палочки
- Берёт их только если обе свободны
- Иначе ждёт, не захватывая ресурсы

**Вывод:** Задача демонстрирует сложность предотвращения deadlock при конкуренции за несколько ресурсов.

---
## Проблема читателей и писателей
### Описание задачи
**Проблема читателей и писателей** — моделирует доступ к общим данным (например, к базе данных или файлу).

**Действующие лица:**
- **Читатели (Readers)** — процессы, которые только **читают** данные
- **Писатели (Writers)** — процессы, которые **изменяют** данные

**Правила:**
1. **Множественное чтение:** Несколько читателей могут **одновременно** читать данные
2. **Эксклюзивная запись:** При записи доступ к данным должен быть **запрещён** всем (и читателям, и писателям)
3. **Взаимное исключение писателей:** Только один писатель может изменять данные в каждый момент времени

**Почему так:**
- Чтение не изменяет данные → можно читать одновременно
- Запись изменяет данные → нельзя допустить одновременное чтение или запись

### Требования
**При попытке записи:**
- Запрос отклоняется, если есть **читающие** процессы
- Запрос отклоняется, если есть **пишущие** процессы
- Процесс-писатель ждёт, пока все освободят данные

**При попытке чтения:**
- Запрос разрешается, если нет **пишущих** процессов
- Запрос может быть отклонён, если есть ожидающий **писатель** (зависит от политики)

### Проблема starvation писателей
**Сценарий голодания писателя:**
1. Писатель запрашивает доступ, но есть читатели
2. Писатель ждёт
3. Приходят новые и новые читатели
4. Писатель ждёт бесконечно долго!

**Вопрос:** Как сделать так, чтобы записывающий процесс всё-таки получил доступ к данным?

### Возможные решения

#### Решение 1: Приоритет читателям (Readers-Preference)
- Читатели имеют приоритет
- **Проблема:** Писатели могут голодать

#### Решение 2: Приоритет писателям (Writers-Preference)
- Если есть ожидающий писатель, новые читатели блокируются
- Писатель получает доступ сразу после текущих читателей
- **Проблема:** Читатели могут голодать

#### Решение 3: Справедливое (Fair)
- Процессы обслуживаются в порядке запросов
- Используется очередь FIFO
- Никто не голодает

**Реализация с семафорами:**
```c
semaphore mutex = 1;      // Защита счётчика читателей
semaphore wrt = 1;        // Эксклюзивный доступ для писателя
int readcount = 0;        // Количество активных читателей

// Читатель
void reader() {
    while (1) {
        P(mutex);
        readcount++;
        if (readcount == 1) {
            P(wrt);  // Первый читатель блокирует писателей
        }
        V(mutex);
        
        // ЧТЕНИЕ ДАННЫХ
        read_data();
        
        P(mutex);
        readcount--;
        if (readcount == 0) {
            V(wrt);  // Последний читатель разблокирует писателей
        }
        V(mutex);
    }
}

// Писатель
void writer() {
    while (1) {
        P(wrt);  // Ждём эксклюзивного доступа
        
        // ЗАПИСЬ ДАННЫХ
        write_data();
        
        V(wrt);  // Освобождаем доступ
    }
}
```

**Вывод:** Проблема демонстрирует необходимость балансировки между производительностью (параллельное чтение) и справедливостью (отсутствие голодания).

---
## Проблема спящего брадобрея
### Описание задачи
![[OS 35.png]]

**Условия:**
- **Брадобрей** — один человек, который стрижёт клиентов
- **Кресло брадобрея** — одно рабочее место
- **Стулья для ожидания** — N стульев в зале ожидания
- **Посетители** — приходят случайным образом

**Правила:**
1. **Если брадобрей свободен:**
   - И приходит посетитель
   - Брадобрей обслуживает его

2. **Если брадобрей занят:**
   - И есть свободные стулья
   - Посетитель садится и ждёт

3. **Если брадобрей занят:**
   - И все стулья заняты
   - Посетитель уходит

4. **Если посетителей нет:**
   - Брадобрей спит

### Задача синхронизации
**Проблемы, которые нужно решить:**
1. Брадобрей не должен стричь несуществующего клиента
2. Клиент не должен пытаться сесть в занятое кресло
3. Брадобрей должен просыпаться при появлении клиента
4. Клиент должен ждать, если брадобрей занят, но есть свободные стулья

### Решение с семафорами
```c
#define N 5  // Количество стульев для ожидания

semaphore customers = 0;   // Количество ожидающих клиентов
semaphore barber = 0;      // Готовность брадобрея
semaphore mutex = 1;       // Защита счётчика ожидающих
int waiting = 0;           // Количество ожидающих клиентов

// Брадобрей
void barber() {
    while (1) {
        P(customers);  // Ждём клиента (спим, если нет)
        P(mutex);
        waiting--;     // Один клиент встал из зала ожидания
        V(barber);     // Готовы стричь
        V(mutex);
        
        cut_hair();    // Стрижём клиента
    }
}

// Клиент
void customer() {
    P(mutex);
    
    if (waiting < N) {  // Есть свободные стулья
        waiting++;
        V(customers);   // Сообщаем брадобрею о своём приходе
        V(mutex);
        
        P(barber);      // Ждём готовности брадобрея
        
        get_haircut();  // Стрижёмся
    } else {
        V(mutex);       // Нет свободных мест
        // Уходим
    }
}
```

**Анализ решения:**
✓ Брадобрей спит на семафоре customers, когда нет клиентов
✓ Клиенты пробуждают брадобрея через V(customers)
✓ Счётчик waiting отслеживает заполненность зала ожидания
✓ Mutex защищает критическую секцию изменения waiting

**Вывод:** Задача демонстрирует синхронизацию между производителем услуг (брадобрей) и потребителями (клиенты) с ограниченной очередью.

---

## Резюме
### Сравнительная таблица

| Механизм              | Простота | Безопасность | Производительность | Поддержка в языках |
| --------------------- | -------- | ------------ | ------------------ | ------------------ |
| Программные алгоритмы | ✗        | ✓            | ✗                  | ✓                  |
| Test-and-Set          | ✓        | ✓            | ✗                  | ✓                  |
| Семафоры              | ○        | ○            | ✓                  | ✓                  |
| Мониторы              | ✓        | ✓            | ✓                  | ○                  |
| Сообщения             | ✓        | ✓            | ○                  | ✓                  |

Легенда: ✓ — хорошо, ○ — средне, ✗ — плохо
### Выбор механизма синхронизации
**Используйте семафоры, когда:**
- Нужна высокая производительность
- Требуется точный контроль над синхронизацией
- Язык не поддерживает мониторы

**Используйте мониторы, когда:**
- Язык поддерживает их (Java, C#, Concurrent Pascal)
- Важна безопасность и простота кода
- Команда разработчиков не очень опытна в параллельном программировании

**Используйте передачу сообщений, когда:**
- Работаете с распределённой системой
- Процессы находятся на разных машинах
- Простота важнее производительности
- Процессы не разделяют память


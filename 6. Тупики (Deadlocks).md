#Operating_Systems #OS_Processes 
## Ресурсы
### Что такое ресурсы?
**Ресурсы** — это объекты, необходимые процессам для выполнения своих задач. Они могут быть аппаратными (принтеры, память) или программными (файлы, базы данных).

В операционных системах ресурсы играют ключевую роль в работе процессов. Существует два основных типа ресурсов:
#### Выгружаемые (Preemptable) ресурсы
- **Определение:** Ресурс, который можно безболезненно забрать у владеющего им процесса
- **Примеры:** 
  - Оперативная память (можно выгрузить на диск и продолжить работу)
  - Процессорное время
- **Особенность:** Изъятие ресурса не приводит к потере результатов работы процесса
- **Восстановление:** Процесс может продолжить работу после возврата ресурса
#### Невыгружаемые (Non-preemptable) ресурсы
- **Определение:** Ресурс, который нельзя забрать у текущего владельца без уничтожения результатов работы
- **Примеры:**
  - CD/DVD привод во время записи (если забрать управление, диск будет испорчен)
  - Принтер во время печати
  - Сканер во время сканирования
  - Плоттер во время вывода
- **Важно:** Именно при доступе к невыгружаемым ресурсам возникают взаимоблокировки (тупики)

### Процесс работы с ресурсами
Типичный цикл работы процесса с ресурсом включает три этапа:
1. **Запрос ресурса (Request/Open)**
   - Процесс запрашивает доступ к ресурсу
   - Если ресурс недоступен, процесс вынужден ждать
   
2. **Использование ресурса (Use)**
   - Процесс выполняет операции с ресурсом
   - Ресурс находится в эксклюзивном владении процесса

3. **Возврат ресурса (Release/Close)**
   - Процесс освобождает ресурс
   - Ресурс становится доступным для других процессов

**Поведение при недоступности ресурса:**
- В некоторых ОС процесс блокируется и возобновляется после освобождения ресурса
- В других случаях вызывающий процесс сам повторяет попытку позже
---
## Определение и суть тупиков
### Основное определение
**Тупик (Deadlock/Дедлок/Клинч)** — ситуация в мультипрограммной системе, когда процесс находится в состоянии ожидания события, которое никогда не произойдет.

**Более формальное определение:** Множество процессов находится в тупиковой ситуации, если каждый процесс из множества ожидает события, которое только другой процесс данного множества может вызвать.

### Механизм возникновения
Проблемы возникают, когда средствами синхронизации пользуются неосторожно:
1. Несколько процессов конкурируют за обладание конечным числом ресурсов
2. Запрашиваемый процессом ресурс недоступен → процесс переходит в состояние ожидания
3. Если требуемый ресурс удерживается другим ожидающим процессом → первый процесс не сможет сменить свое состояние
4. Все процессы чего-то ожидают → ни один не может инициировать событие для разблокировки других
5. Все процессы "спят" вместе

![[OS 36.png]]

**Системная тупиковая ситуация (зависание системы)** является следствием того, что один или более процессов находятся в состоянии тупика.

### Типы тупиков
#### Тупики на аппаратных ресурсах
- Принтеры, сканеры, CD-приводы
- Ленточные накопители
- Плоттеры
#### Тупики на программных ресурсах
**Пример 1: Базы данных**
- Процессы могут блокировать (локализовать) записи, чтобы избежать гонок
- Один процесс заблокировал записи, требуемые другому процессу, и наоборот
- Результат: взаимная блокировка

**Пример 2: Система спулинга (Spooling)**
- Спулинг — режим ввода-вывода с буферизацией информации на диске
- Программа должна полностью сформировать выходные данные в промежуточном файле
- Несколько заданий может оказаться в тупике, если буфер заполнен до завершения хотя бы одного задания

**Возможные решения для спулинга:**
- Увеличить размер буфера
- Не принимать дополнительные задания при заполнении буфера на 75%
- Установить пороги насыщения
---
## Условия возникновения тупиков (Условия Коффмана)
Для возникновения тупика **ОБЯЗАТЕЛЬНО** должны одновременно выполняться все 4 условия:
### 1) Условие взаимного исключения (Mutual Exclusion)
- Ресурс может быть выделен только одному процессу в каждый момент времени
- Если другой процесс запрашивает этот ресурс, он должен ждать его освобождения
- Ресурс находится в эксклюзивном владении процесса

### 2) Условие удержания и ожидания (Hold and Wait)
- Процесс удерживает как минимум один ресурс
- Одновременно процесс ожидает получения дополнительных ресурсов
- Удерживаемые ресурсы заняты другими ожидающими процессами

### 3) Условие невозможности принудительной выгрузки (Non-preemption)
- Ресурс не может быть принудительно забран у процесса
- Ресурс может быть освобожден только добровольно процессом, владеющим им
- После завершения его использования

### 4) Условие циклического ожидания (Circular Wait)
- Существует циклическая цепочка процессов
- Каждый процесс в цепочке ожидает ресурс, удерживаемый следующим процессом в цепочке
- Образуется замкнутый цикл зависимостей

**Важно:** Если хотя бы одно условие не выполняется, тупик невозможен!

---
## Моделирование тупиков
### Направленные графы "процесс-ресурс"
Для анализа тупиков используются направленные графы, где:
- **Круги** — процессы
- **Квадраты** — ресурсы
- **Стрелки** — отношения владения/запроса

#### Типы стрелок:
1. **От ресурса к процессу:** Ресурс R занят (выделен процессу)
2. **От процесса к ресурсу:** Процесс запросил ресурс

#### Признак тупика на графе:
- Наличие **цикла** в графе процесс-ресурс
- Пример: Процесс D владеет ресурсом T и запрашивает ресурс U, занятый процессом C, который ожидает ресурс T

![[OS 37.png]]

---
## Стратегии работы с тупиками
Существует 4 основных стратегии работы с тупиками:
### Обзор стратегий
1. **Пренебрежение (Алгоритм страуса)**
   - Игнорирование проблемы
   - "Спрятать голову в песок"

2. **Обнаружение и восстановление**
   - Разрешить тупикам происходить
   - Обнаруживать их
   - Предпринимать действия по восстановлению

3. **Динамическое избегание (Avoidance)**
   - Тщательное распределение ресурсов
   - Анализ безопасности состояний
   - Предотвращение входа в небезопасные состояния

4. **Предотвращение (Prevention)**
   - Атака на одно из четырех условий Коффмана
   - Структурное исключение возможности тупика
---
## Функции ОС по работе с тупиками
#### 1) Обнаружение тупиков (Deadlock Detection)
   - Определение наличия тупика в системе
   - Использование алгоритмов поиска циклов в графах процесс-ресурс
#### 2) Восстановление после тупиков (Deadlock Recovery)
   - Принятие мер для выхода из тупика
   - Принудительная выгрузка ресурсов, откат к контрольным точкам, уничтожение процессов
#### 3) Избежание тупиков (Deadlock Avoidance)
   - Предотвращение входа в небезопасные состояния
   - Алгоритм банкира и другие методы
#### 4) Предотвращение тупиков (Deadlock Prevention)
   - Исключение возможности возникновения тупиков
   - Нарушение одного из условий Коффмана
---
## Обнаружение тупиков (Detection)
### Обнаружение для одного ресурса каждого типа
**Метод:** Поиск циклов в графе процесс-ресурс

**Алгоритм поиска циклов:**

**Обозначения:**
- L — список узлов графа
- N — начальный узел
- Ребра помечаются как "уже проверено"

**Шаги алгоритма:**
1. **Инициализация:**
   - N — начальный узел
   - Список L пуст
   - Ребра не маркированы

2. **Добавление узла:**
   - Текущий узел добавляем в список L (в конец)
   - Проверяем весь список — есть ли данный узел?
   - Если узел уже был → **обнаружен цикл** → завершение

3. **Проверка исходящих ребер:**
   - Смотрим, выходит ли из узла хотя бы одно немаркированное ребро
   - Если да → переход к шагу 4
   - Если нет → переход к шагу 5

4. **Переход по ребру:**
   - Случайным образом выбираем любое исходящее немаркированное ребро
   - Отмечаем его как маркированное
   - По нему переходим к следующему узлу
   - Возврат к шагу 2

5. **Возврат назад (backtracking):**
   - Зашли в тупик графа — дальше хода нет
   - Удаляем последний узел из списка
   - Возвращаемся к предыдущему узлу
   - Обозначаем его следующим узлом
   - Возврат к шагу 2
   - Если это начальный узел → **тупиков нет** → завершение

![[OS 38.png]]

### Обнаружение при наличии нескольких ресурсов одного типа
**Обозначения:**
- **N** — число процессов
- **m** — число классов ресурсов
- **Ei** (1 ≤ i ≤ m) — количество экземпляров ресурса класса i в системе
- **E** — вектор существующих ресурсов
- **A** — вектор доступных ресурсов
- **C** — матрица текущего распределения (что занято)
- **R** — матрица запросов (что нужно)

**Важное соотношение:**
```
Сумма по всем процессам C[i][j] + A[j] = E[j]
```
(занятые + доступные = всего существующих)

**Алгоритм обнаружения:**

**Для сравнения векторов:** A ≤ B тогда и только тогда, когда A[i] ≤ B[i] для всех 1 ≤ i ≤ m

**Начальное состояние:** Все процессы немаркированы

**Шаги:**
1. **Поиск процесса:**
   - Ищем немаркированный процесс Pi, для которого Ri ≤ A
   - То есть ищем процесс, который может завершиться (все нужные ему ресурсы свободны)

2. **Моделирование завершения:**
   - Если нашли, прибавляем Ci к вектору A
   - Маркируем процесс
   - Возврат к шагу 1
   - (Процесс отдаст свои ресурсы после завершения)

3. **Проверка результата:**
   - Если таких процессов нет, все немаркированные процессы находятся в тупике
   - Завершение алгоритма

**Пример:**
```
4 класса ресурсов: магнитофоны, плоттеры, сканеры, CD
E = (4, 2, 3, 1) — всего ресурсов
A = (2, 1, 0, 0) — доступно

Матрица C (текущее распределение):
Процесс 1: (0, 0, 1, 0)
Процесс 2: (2, 0, 0, 1)
Процесс 3: (0, 1, 2, 0)

Матрица R (запросы):
Процесс 1: (2, 0, 0, 1)
Процесс 2: (1, 0, 1, 0)
Процесс 3: (2, 1, 0, 0)

Анализ: Процесс 3 может завершиться (R3 ≤ A), вернет ресурсы → все процессы смогут завершиться → тупика нет

Но если процессу 3 понадобится еще и CD: R3 = (2, 1, 0, 1) → тупик!
```

### Когда производить обнаружение тупиков?
**Варианты частоты проверки:**
1. **При каждом запросе ресурса**
   - Максимальная оперативность
   - Высокие накладные расходы
   - Точное определение виновника

2. **Периодически через каждые k минут**
   - Баланс между оперативностью и накладными расходами
   - Снижение нагрузки на систему

3. **При низкой загрузке процессора**
   - При большом количестве тупиков нагрузка на процессор падает
   - Проверять, когда загрузка меньше заданного значения
   - Косвенный индикатор наличия проблем

**Выбор стратегии зависит от:**
- Критичности системы
- Стоимости тупиков
- Доступных вычислительных ресурсов
---
## Восстановление после тупиков (Recovery)
После обнаружения тупика необходимо восстановить систему и привести ее в рабочее состояние.
### 1) Принудительная выгрузка ресурса (Preemption)
**Идея:** Временно забрать ресурс у процесса, дать другому, затем вернуть

**Процесс:**
1. Забрать ресурс у процесса
2. Сохранить состояние процесса
3. Передать ресурс другому процессу
4. После освобождения вернуть ресурс и продолжить работу

**Пример с принтером:**
- Откладываем отпечатанные процессом листы в сторону
- Даем отпечатать другому процессу
- Затем продолжаем работу с прерванного места

**Ограничения:**
- Возможность сильно зависит от свойств ресурсов
- Для многих ресурсов невозможна (например, CD-привод во время записи)
- В большинстве случаев не сработает

### 2) Откат к контрольным точкам (Rollback)
**Подготовка:**
- Если предполагается возможность тупика, расставляются контрольные точки (checkpoints)
- Состояние системы в контрольной точке записывается в файл
- Каждая контрольная точка записывается отдельно
- Состояние может быть восстановлено из файла

**Процесс восстановления:**
1. Один из процессов откатывается на контрольную точку до тупика
2. Результаты работы после контрольной точки теряются
3. Остальные процессы продолжают работу
4. Остановленный процесс запускается с контрольной точки

**Преимущества:**
- Сохранение большей части работы
- Возможность выбора оптимальной точки отката

**Недостатки:**
- Накладные расходы на создание контрольных точек
- Потеря части выполненной работы
- Требуется дисковое пространство для хранения

### 3) Уничтожение процесса (Process Termination)
**Простейший подход:** Выбрать жертву и завершить один (или несколько) процессов

**Критерии выбора жертвы:**
1. **Возможность перезапуска:**
   - Процессы, которые можно просто запустить сначала
   - Примеры: компиляция, импорт из текстового файла

2. **Приоритет процесса:**
   - Завершать процессы с низким приоритетом

3. **Время выполнения:**
   - Процессы, которые выполнялись недолго (меньше потерь)
   - Или наоборот — процессы, почти завершившие работу

4. **Использованные ресурсы:**
   - Минимизация потерь вычислительных ресурсов

5. **Количество удерживаемых ресурсов:**
   - Процессы, освобождение которых разблокирует больше других

**Варианты завершения:**
- **Завершить один процесс** — проверить, устранен ли тупик
- **Завершать по одному** — пока тупик не будет устранен
- **Завершить все** — гарантированное устранение, но максимальные потери

**Проблема голодания:**
- При постоянном выборе одного и того же процесса как жертвы
- Решение: учитывать количество предыдущих завершений при выборе

---
## Избежание тупиков (Avoidance)
Избежание тупиков предполагает осторожное выделение ресурсов, чтобы система никогда не входила в небезопасное состояние.
### Траектория ресурсов — графическое представление
**Модель для двух процессов:**
- Система с двумя процессами A и B
- Два ресурса — принтер и плоттер
- Ось X — команды процесса A
- Ось Y — команды процесса B

**Обозначения для процесса A:**
- A1-A3 — запрос и освобождение принтера
- A2-A4 — запрос и освобождение плоттера

**Обозначения для процесса B:**
- B1-B3 — запрос и освобождение плоттера
- B2-B4 — запрос и освобождение принтера

**Каждая точка на графике** — совместное состояние двух процессов

**Опасная зона:**
- Область, где оба процесса одновременно держат по одному ресурсу
- Вход в эту область может привести к тупику
- Планировщик должен избегать траекторий, проходящих через опасную зону

![[OS 39.png]]

Т.к. процессор предоставляется поочередно, траектория может продолжаться только параллельно осям.

Чтобы избежать тупика, процессам надо обойти **прямоугольник, охватывающий всю заштрихованную область**.
### Безопасные и небезопасные состояния
#### Определение безопасного состояния
**Состояние безопасно**, если:
1. Система не находится в тупике
2. Существует порядок планирования, при котором каждый процесс может работать до завершения. Даже если все процессы сразу запросят максимально требуемое количество ресурсов

#### Пример безопасного состояния
```
Всего 10 экземпляров ресурса

Процесс | Имеет | Максимум | Нужно еще
--------|-------|----------|----------
   A    |   1   |    9     |    8
   B    |   2   |    4     |    2
   C    |   2   |    7     |    5
--------|-------|----------|----------
Доступно: 5

Анализ безопасности:
1. Процесс B может получить 2 ресурса (есть 5), завершиться и освободить 4
2. Доступно станет 5 + 4 = 9
3. Процесс A может получить 8 ресурсов, завершиться и освободить 9
4. Доступно станет 9 + 9 = 18
5. Процесс C может получить 5 ресурсов и завершиться
6. Состояние БЕЗОПАСНО
```

#### Пример небезопасного состояния
```
Если процесс A после состояния (1) запросит еще один ресурс:
A: имеет 2, максимум 9, нужно 7
Доступно: 4

Тогда:
- B нужно 2 (есть 4) — может завершиться → освободит 4, доступно 8
- A нужно 7 (есть 8) — может завершиться → освободит 9, доступно 17  
- C нужно 5 (есть 17) — может завершиться
- НО! Если A сразу запросит 7, получит отказ

Если выделить A еще 2 ресурса: A имеет 4, доступно 2
- B нужно 2 (есть 2) — может завершиться
- Но если B запросит раньше A, то A запросит раньше B...
- Состояние НЕБЕЗОПАСНО — нет гарантированного порядка завершения
```

**Важно:** Небезопасное состояние ≠ тупик, но может к нему привести!

### Алгоритм банкира для одного вида ресурсов
**Название:** Назван по аналогии с банком, который не выдает все деньги сразу, чтобы обеспечить ликвидность

**Принцип работы:**
- При каждом запросе ресурса проверяем, приводит ли его выполнение к безопасному состоянию
- Если состояние остается безопасным — удовлетворяем запрос
- Если состояние становится небезопасным — запрос откладывается

**Пример:**
a) **Безопасное состояние (исходное):**
```
Процесс | Имеет | Максимум | Нужно | Доступно: 10
--------|-------|----------|-------|
   A    |   0   |    6     |   6   |
   B    |   0   |    5     |   5   |
   C    |   0   |    4     |   4   |
   D    |   0   |    7     |   7   |
```
Последовательность: C(4) → B(5) → A(6) → D(7) — все могут завершиться

b) **Безопасное состояние после выделения ресурсов:**
```
Процесс | Имеет | Максимум | Нужно | Доступно: 2
--------|-------|----------|-------|
   A    |   1   |    6     |   4   |
   B    |   1   |    5     |   4   |
   C    |   2   |    4     |   2   |
   D    |   4   |    7     |   3   |
```
- C может дополучить 2, завершиться → безопасно
- D может дополучить 3, завершиться → безопасно
- A может дополучить 4, завершиться → безопасно
- B может дополучить 4, завершиться → безопасно

c) **Небезопасное состояние после выделения ресурсов:**
```
Процесс | Имеет | Максимум | Нужно | Доступно: 1
--------|-------|----------|-------|
   A    |   1   |    6     |   5   |
   B    |   2   |    5     |   3   |
   C    |   2   |    4     |   2   |
   D    |   4   |    7     |   3   |
```
Никто не может завершиться → ОТКАЗАТЬ!

### Алгоритм банкира для нескольких видов ресурсов
**Расширение:** Обобщение алгоритма обнаружения тупика для предсказания

**Алгоритм проверки безопасности:**
1. **Поиск выполнимого процесса:**
   - Ищем в матрице запросов строку Ri ≤ A
   - Если такой строки нет → возможен тупик → состояние небезопасно

2. **Моделирование завершения:**
   - Допускаем, что найденный процесс запросил все ресурсы и завершается
   - Помечаем процесс
   - Прибавляем освобожденные ресурсы к вектору A

3. **Итерация:**
   - Повторяем шаги 1 и 2, пока все процессы не будут помечены
   - Если все помечены → состояние безопасно

**Пример:**
```
E = (6, 3, 4, 2) — всего ресурсов (ленты, принтеры, плоттеры, сканеры)

Матрица C (имеет):        Матрица R (может запросить):
       л  п  пл  с                  л  п  пл  с
A:     3  0  1   1          A:      1  1  0   0
B:     0  1  0   0          B:      0  1  1   2
C:     1  1  1   0          C:      3  1  0   0
D:     1  1  0   1          D:      0  0  1   0
E:     0  0  1   0          E:      2  1  0   1

Доступно A = (1, 0, 2, 0)

Анализ:
1. Процесс D: R_D = (0,0,1,0) ≤ A = (1,0,2,0) — может завершиться
2. D освобождает (1,1,0,1), A = (2,1,2,1)
3. Процесс B: R_B = (0,1,1,2) НЕ ≤ A (не хватает сканеров)
4. Процесс A: R_A = (1,1,0,0) ≤ A — может завершиться
5. И так далее...

Состояние БЕЗОПАСНО, процесс B может завершиться

НО: Если E запросит еще один сканер:
A = (1,0,0,0) — никто не может завершиться → ТУПИК
Запрос E нужно отложить!
```

**Применение:**
- Проверка при каждом запросе ресурса
- Выделение ресурса только если состояние остается безопасным
---
## Предотвращение тупиков (Prevention)
Предотвращение заключается в структурном исключении возможности тупика путем нарушения одного из четырех условий Коффмана.
### Атака на условие взаимного исключения
**Идея:** Если в системе нет ресурсов, требующих эксклюзивного доступа — тупиков не будет

**Проблема:**
- Природа большинства ресурсов требует эксклюзивного доступа
- Представьте принтер без эксклюзивного доступа — хаос в выводе!

**Решение — Spooling (спулинг):**

**Спулинг (Spooling)** — режим ввода-вывода с буферизацией информации на диске

**Механизм спулинга:**
1. Только демон принтера имеет право печатать
2. Процессы сохраняют свои файлы для печати на диске (в спул-директории)
3. Демон принтера последовательно обрабатывает файлы из очереди
4. Ресурс (принтер) становится виртуально разделяемым

**Преимущества:**
- Устранение эксклюзивного доступа со стороны процессов
- Упрощение управления очередью печати
- Процессы могут "печатать" параллельно (на диск)

**Ограничения:**
- Требуется достаточное место на диске
- Не для всех ресурсов применимо (например, CD-привод)
- Возможен тупик при заполнении спул-директории

### Атака на условие удержания и ожидания (Hold & Wait)
**Идея:** Процесс не должен удерживать ресурсы, ожидая получения других

#### Вариант 1: Запрос всех ресурсов до начала работы
**Механизм:**
- Требуем запрашивать все ресурсы сразу до начала работы
- Если какие-то ресурсы заняты, процесс ожидает
- Получив все ресурсы, процесс начинает выполнение

**Недостатки:**
1. **Не всегда известны нужные ресурсы:**
   - Требуемые ресурсы часто зависят от входных данных
   - Невозможно предсказать заранее

2. **Неоптимальное использование:**
   - Ресурсы блокируются на все время выполнения
   - Даже когда они не нужны в данный момент
   - Снижение степени мультипрограммирования

3. **Голодание:**
   - Процессы, требующие много ресурсов, могут долго ждать

#### Вариант 2: Освобождение перед запросом новых
**Механизм:**
- Процесс освобождает ВСЕ удерживаемые ресурсы перед тем, как запросить новый
- Затем пытается сразу получить все необходимое (старые + новые)

**Преимущества:**
- Нет удержания + ожидания одновременно
- Большая гибкость по сравнению с вариантом 1

**Недостатки:**
- Потеря состояния (например, данных в памяти)
- Необходимость повторного захвата и восстановления
- Возможность голодания

### Атака на условие невозможности принудительной выгрузки
**Проблема:** Для большинства невыгружаемых ресурсов принудительная выгрузка:
- Затруднительна
- Или вообще невозможна

**Примеры:**
- CD-привод во время записи (испортится диск)
- Принтер во время печати (испортится вывод)

**Возможные случаи применения:**
- Процессорное время (переключение контекста)
- Память (выгрузка на диск/swap)

**Вывод:** Для многих ресурсов это условие атаковать нецелесообразно или невозможно

### Атака на условие циклического ожидания
#### Вариант 1: Ограничение одним ресурсом
**Правило:** Процесс может обладать только одним ресурсом в каждый момент времени

**Механизм:**
- Перед запросом нового ресурса необходимо освободить имеющийся
- Циклическое ожидание становится невозможным

**Недостатки:**
- Не всегда удобно
- Не всегда приемлемо (многие процессы требуют несколько ресурсов одновременно)
- Значительно усложняет программирование

#### Вариант 2: Нумерация ресурсов (наиболее практичный)
**Механизм:**
1. Каждому ресурсу присваивается уникальный номер
2. Процессы могут запрашивать ресурсы только в порядке возрастания (или убывания) номеров
3. Если процессу нужен ресурс с меньшим номером, он должен сначала освободить все ресурсы с большими номерами

**Пример нумерации:**
```
1 - Клавиатура
2 - Мышь
3 - Сканер
4 - Принтер
5 - Плоттер
6 - CD-привод
7 - Ленточный накопитель
8 - Жесткий диск
```

**Почему это работает:**
- Циклическое ожидание требует цепочку: P1 → R1 → P2 → R2 → ... → Pn → Rn → P1
- Если номер R1 < R2 < ... < Rn, то Rn < R1 невозможно
- Следовательно, цикл невозможен

**Преимущества:**
- Простота реализации
- Не требует предварительных знаний обо всех ресурсах
- Умеренные накладные расходы

**Недостатки:**
- Ограничивает гибкость программирования
- Может привести к неоптимальному порядку захвата ресурсов
- Требуется тщательная нумерация для эффективности
---
## Специальные техники
### 1) Двухфазное блокирование (Two-Phase Locking)
**Область применения:** Базы данных с параллельным доступом

**Проблема:**
- Часто нужно заблокировать записи и обновить сразу все в одной или нескольких таблицах
- При одновременной работе нескольких процессов высокая вероятность тупиков

**Механизм двухфазного блокирования:**
**Фаза 1: Захват блокировок**
1. Пытаемся заблокировать все нужные записи по одной за раз
2. Если какая-то запись уже заблокирована:
   - В некоторых СУБД: освобождаем все блокировки и начинаем снова
   - В других: не освобождаем и ждем
3. Продолжаем до получения всех блокировок

**Фаза 2: Работа и освобождение**
1. Если получились все блокировки, делаем обновление
2. Освобождаем все блокировки

**Варианты стратегии при конфликте:**
- **Консервативная:** Освобождать все и повторять (избегание тупика)
- **Агрессивная:** Ожидать освобождения (возможен тупик, но меньше повторов)

**Преимущества:**
- Гарантия согласованности данных
- Предотвращение гонок

**Недостатки:**
- Возможность тупиков (при агрессивной стратегии)
- Снижение производительности при высоком уровне конфликтов
- Возможность livelock при консервативной стратегии

### 2) Тупики без ресурсов
**Важное замечание:** Тупик может возникнуть даже "без ресурсов" в классическом понимании

**Пример: Задача ограниченного буфера с семафорами**
```
Семафоры:
- full (количество заполненных слотов)
- empty (количество пустых слотов)
- mutex (взаимное исключение)

НЕПРАВИЛЬНЫЙ порядок операций:
Производитель:              Потребитель:
wait(mutex);                wait(mutex);
wait(empty);                wait(full);
добавить_элемент();         извлечь_элемент();
signal(full);               signal(empty);
signal(mutex);              signal(mutex);

ТУПИК: Оба захватили mutex, оба ждут empty/full!

ПРАВИЛЬНЫЙ порядок:
Производитель:              Потребитель:
wait(empty);                wait(full);
wait(mutex);                wait(mutex);
добавить_элемент();         извлечь_элемент();
signal(mutex);              signal(mutex);
signal(full);               signal(empty);
```

**Вывод:** Порядок операций с семафорами критически важен для избежания тупиков

---

## Проблема голодания (Starvation)
### Определение
**Голодание (Starvation)** — ситуация, когда процесс не блокирован, но не получает необходимых ресурсов в течение неопределенно долгого времени.
### Причины голодания
#### 1. Политики доступа к ресурсам
При доступе к ресурсам в динамичной системе используются политики, основанные на:
- **Приоритетах процессов:** Процессы с низким приоритетом могут бесконечно ждать
- **Размерах процессов/файлов:** "Короткие" задания всегда обслуживаются первыми
- **Положении головки диска:** Обслуживаются только "близкие" запросы
- **Возрасте процесса:** Новые процессы получают преимущество

#### 2. Выбор жертвы при выходе из тупика
**Проблема:**
- При выборе жертвы для выхода из тупика учитываются факторы "стоимости"
- На основе приоритетов, времени выполнения и т.д.
- Некоторые процессы постоянно избираются жертвами

**Последствие:**
- Процесс многократно завершается и перезапускается
- Фактически никогда не завершает свою работу
- Голодание в контексте тупиков

### Предотвращение голодания
**Дисциплина FIFO (First In, First Out):**
- При использовании FIFO голодания не возникает
- Гарантия: процесс, пришедший первым, будет обслужен первым
- Независимо от приоритетов и других факторов

**Старение (Aging):**
- Постепенное повышение приоритета ожидающего процесса
- Со временем даже низкоприоритетный процесс станет высокоприоритетным
- Гарантирует обслуживание в разумное время

**Учет истории:**
- При выборе жертвы учитывать количество предыдущих завершений
- Не выбирать одни и те же процессы многократно
- Справедливое распределение "стоимости" тупиков

**Квоты и гарантии:**
- Гарантировать минимальный процент процессорного времени
- Резервировать ресурсы для низкоприоритетных процессов
- Устанавливать максимальное время ожидания

### Голодание vs Тупик

| Аспект | Голодание | Тупик |
|--------|-----------|-------|
| **Блокировка** | Процесс НЕ заблокирован | Процесс заблокирован |
| **Прогресс** | Система работает, но процесс не обслуживается | Система застопорена для процессов в тупике |
| **Возможность завершения** | Теоретически может завершиться | Никогда не завершится без вмешательства |
| **Обнаружение** | Сложнее обнаружить | Можно обнаружить алгоритмически |
| **Причина** | Несправедливая политика планирования | Циклические зависимости ресурсов |

---
## Сравнение стратегий работы с тупиками
### Таблица сравнения

| Стратегия                        | Преимущества                                                                           | Недостатки                                                                                                             | Когда применять                                                                                     |
| -------------------------------- | -------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| **Пренебрежение (Страус)**       | • Нет накладных расходов<br>• Простота реализации<br>• Максимальная производительность | • Возможны зависания системы<br>• Требуется ручное вмешательство<br>• Потеря данных                                    | • Тупики крайне редки<br>• Стоимость предотвращения выше стоимости тупиков<br>• Настольные ОС       |
| **Обнаружение и восстановление** | • Максимальное использование ресурсов<br>• Гибкость<br>• Точная локализация проблемы   | • Накладные расходы на обнаружение<br>• Потеря работы при восстановлении<br>• Сложность выбора жертвы                  | • Критичные системы<br>• Редкие тупики<br>• Серверные ОС                                            |
| **Избежание (Банкир)**           | • Гарантия отсутствия тупиков<br>• Динамическая адаптация<br>• Процессы завершаются    | • Требуется знание максимальных требований<br>• Консервативное использование<br>• Накладные расходы при каждом запросе | • Системы реального времени<br>• Известны максимальные требования<br>• Критичные приложения         |
| **Предотвращение**               | • Полное исключение тупиков<br>• Не требуется обнаружение<br>• Простота понимания      | • Низкое использование ресурсов<br>• Ограничение гибкости<br>• Возможность голодания                                   | • Встроенные системы<br>• Системы с предсказуемым поведением<br>• Критичные по безопасности системы |

### Практические рекомендации
**Для настольных систем (Windows, Linux Desktop):**
- Обычно используется алгоритм страуса
- Тупики редки, пользователь может перезагрузить
- Приоритет — производительность

**Для серверных систем:**
- Комбинация обнаружения и восстановления
- Важна непрерывность работы
- Логирование для анализа

**Для систем реального времени:**
- Избежание или предотвращение
- Гарантии выполнения критичны
- Предсказуемость важнее эффективности

**Для баз данных:**
- Обнаружение + откат транзакций
- Двухфазное блокирование
- Timeout для автоматического разрешения

**Для встроенных систем:**
- Предотвращение (нумерация ресурсов)
- Статическое распределение
- Минимум динамики

---
## Практические примеры и задачи
### Пример 1: Классический тупик с двумя процессами
```
Ресурсы: R1 (принтер), R2 (сканер)

Процесс A:              Процесс B:
1. Захватить R1         1. Захватить R2
2. Захватить R2         2. Захватить R1
3. Использовать         3. Использовать
4. Освободить R2        4. Освободить R1
5. Освободить R1        5. Освободить R2

Сценарий тупика:
t1: A захватывает R1
t2: B захватывает R2
t3: A ждет R2 (занят B)
t4: B ждет R1 (занят A)
→ ТУПИК!

Решения:
1. Нумерация: R1=1, R2=2 → все захватывают в порядке 1,2
2. Банкир: анализировать безопасность перед выделением
3. Освобождение перед захватом второго ресурса
```

### Пример 2: Философы за обедом (Dining Philosophers)
**Постановка задачи:**
- 5 философов сидят за круглым столом
- Между каждыми двумя философами лежит одна вилка (всего 5 вилок)
- Для еды нужны 2 вилки (слева и справа)
- Философы чередуют размышления и еду

**Наивное решение (приводит к тупику):**
```
while (true) {
    думать();
    взять_левую_вилку();
    взять_правую_вилку();
    есть();
    положить_левую_вилку();
    положить_правую_вилку();
}

Тупик: Все философы одновременно берут левую вилку → все ждут правую → ТУПИК!
```

**Решения:**
**1. Нечетные и четные (асимметрия):**
```
if (номер_философа % 2 == 0) {
    взять_левую_вилку();
    взять_правую_вилку();
} else {
    взять_правую_вилку();
    взять_левую_вилку();
}
```

**2. Ограничение количества:**
- Разрешать не более 4 философам садиться за стол одновременно
- Гарантия: хотя бы один получит обе вилки

**3. Семафор на пару вилок:**
- Захват обеих вилок атомарно
- Или не захватывать вообще

**4. Иерархия ресурсов:**
- Нумеровать вилки 1-5
- Всегда брать сначала вилку с меньшим номером

### Пример 3: Тупик в файловой системе
**Сценарий:**
```
Процесс A:                  Процесс B:
1. Открыть файл file1.txt   1. Открыть файл file2.txt
2. Заблокировать            2. Заблокировать
3. Попытка открыть file2.txt 3. Попытка открыть file1.txt
→ ТУПИК!

Применение нумерации:
- Сортировать файлы по имени или inode
- Всегда блокировать в одинаковом порядке

Процесс A:                  Процесс B:
1. Определить порядок: file1 < file2
2. Заблокировать file1
3. Заблокировать file2
4. Работать с обоими
5. Освободить в обратном порядке
```
## Термины и определения

- **Deadlock (Дедлок, Тупик, Клинч)** — взаимная блокировка процессов
- **Starvation (Голодание)** — бесконечное ожидание без блокировки
- **Livelock** — процессы активны, но не продвигаются вперед
- **Preemption (Выгрузка)** — принудительное изъятие ресурса
- **Rollback (Откат)** — возврат к предыдущему состоянию
- **Checkpoint (Контрольная точка)** — сохраненное состояние системы
- **Safe State (Безопасное состояние)** — гарантия завершения процессов
- **Unsafe State (Небезопасное состояние)** — потенциальный тупик

#Operating_Systems #OS_File_System
## Введение в файловые системы
### Иерархия памяти компьютерной системы
Память вычислительной машины представляет собой иерархию запоминающих устройств (ЗУ), отличающихся **средним временем доступа**, **объёмом** и **стоимостью хранения данных**.

**Структура иерархии (от вершины к основанию пирамиды):**
#### 1. Регистры процессора
- **Объём:** несколько десятков байт
- **Время доступа:** определяется тактовой частотой процессора (доли наносекунды)
- **Назначение:** хранение операндов текущих операций, промежуточное хранение данных
- **Особенность:** самый быстрый, но самый малый по объёму уровень памяти
#### 2. Кэш-память (Static RAM - SRAM)
- **Объём:** от нескольких десятков до нескольких сотен килобайт
- **Время доступа:** обычно не превышает 8 наносекунд
- **Назначение:** хранение данных, к которым необходимо обеспечить быстрый доступ
- **Технология:** статическая память SRAM
- **Особенность:** компактные быстродействующие запоминающие устройства
#### 3. Оперативная память (Dynamic RAM - DRAM)
- **Объём:** от десятков мегабайт до нескольких гигабайт
- **Время доступа:** примерно 10-20 наносекунд
- **Технология:** относительно медленная динамическая память
- **Особенность:** более объёмная, но менее быстродействующая по сравнению с кэшем
#### 4. Внешняя память (жёсткий диск)
- **Объём:** десятки и сотни гигабайт (терабайты в современных системах)
- **Время доступа:** относительно низкое (миллисекунды)
- **Назначение:** фундамент пирамиды запоминающих устройств
- **Особенность:** большой объём при низкой скорости доступа

**Печальная закономерность:** 
> Чем больше объём устройства, тем менее быстродействующим оно является. Более того, стоимость хранения данных в расчёте на один бит также увеличивается с ростом быстродействия устройств.

**Компромиссное решение:**
Кэш-память представляет некоторое компромиссное решение проблемы потребности пользователя в недорогой и быстрой памяти одновременно.

---
## Концепция файловой системы
### Проблема хранения информации
**Ограничения оперативной памяти:**
1. Оперативная память **слишком мала**, чтобы хранить большие массивы информации
2. Оперативная память **не сохраняет информацию** (данные) после выключения питания (энергозависимая память)

**Решение:** Использование внешних запоминающих устройств (ВЗУ) для постоянного хранения данных.

### Определение файловой системы
**Файловая система (ФС)** – часть операционной системы, управляющая хранением и доступом к информации на внешних устройствах (ВЗУ).

**Файловая система (ФС)** - набор файлов (в которых содержится некая информация) и структура директорий (в которых содержится информация о файлах), а также вся информация, необходимая для реализации и управления Файловая система.

**Компоненты файловой системы:**
- Набор файлов (в которых содержится некая информация)
- Структура директорий (в которых содержится информация о файлах)
- Вся информация, необходимая для реализации и управления ФС
---
## Файлы и их организация
### Понятие файла
**Файл** – именованный набор информации, сохраняемой на внешнем устройстве.

**Файл («обычный» файл)** может рассматриваться как набор бит, байтов, строк (записей). Этот набор информации определяется создателем или пользователем файла.

**Ключевые характеристики файла:**
- С точки зрения пользователя, **файл является минимальной единицей хранения**
- Нельзя записать что-либо на диск, не создавая файл
- Файл — именованная область внешней памяти

### Основная идея использования внешней памяти
**Принцип блочной организации:**
1. Операционная система делит внешнюю память на **блоки фиксированного размера** (например, 4 Кбайт)
2. С точки зрения пользователя, каждый файл состоит из набора **индивидуальных элементов**, называемых **записями** (например, характеристика какого-нибудь объекта)
3. Каждый файл хранится в виде определённой последовательности блоков (не обязательно смежных)

**Современная реализация:**
- В современных ОС файлы обычно представляют собой **неструктурированную последовательность байтов** (длина записи равна 1)
- Считывание очередного байта осуществляется с так называемой **текущей позиции**, которая характеризуется смещением от начала файла

**Базовая операция с файлом:**
Чтение блока с диска и перенос его в буфер, находящийся в основной памяти.

---
## Атрибуты файла
Каждый файл имеет набор атрибутов (метаданных), которые описывают его свойства и характеристики:
### Основные атрибуты:
- **Имя файла** — символьное имя для идентификации пользователем
- **Тип файла** — для систем, поддерживающих различные типы
- **Размер файла** — текущий размер в байтах, словах или блоках
- **Расположение** — указатель на устройство и местоположение файла на этом устройстве
- **Время и дата** — время создания, последнего изменения, последнего доступа
- **Идентификатор пользователя** — информация о владельце файла
- **Права доступа** — информация о том, кто может читать, писать, выполнять файл

Эта информация хранится в структуре директории, которая также находится на внешней памяти.

---
## Операции с файлами
Файловая система предоставляет набор операций для работы с файлами:
### Основные операции:
1. **Создание файла (Create)**
   - Выделяется место в файловой системе
   - Создаётся запись в директории

1. **Открытие файла (Open)**
   - Подготовка к работе с файлом
   - Проверка прав доступа
   - Загрузка метаданных в таблицу открытых файлов

3. **Чтение файла (Read)**
   - Чтение данных из файла в память
   - Автоматическое перемещение указателя текущей позиции

4. **Запись в файл (Write)**
   - Запись данных из памяти в файл
   - Автоматическое перемещение указателя текущей позиции
   - Возможное увеличение размера файла

5. **Изменение позиции в файле (Seek)**
   - Установка указателя текущей позиции на заданное значение
   - Не требует операций ввода-вывода

6. **Закрытие файла (Close)**
   - Освобождение записи в таблице открытых файлов
   - Запись изменённых данных на диск

7. **Удаление файла (Delete)**
   - Освобождение дискового пространства
   - Удаление записи из директории

8. **Дополнительные операции:**
   - **Appending** — добавление данных в конец файла
   - **Moving** — перемещение файла
   - **Copying** — копирование файла
   - **Renaming** — переименование файла
   - **Truncating** — усечение файла (удаление содержимого с сохранением атрибутов)

---
## Системные вызовы Open() и Close()
### Проблема производительности
При каждой операции с файлом требуется обращение к директории для получения информации о местоположении и атрибутах файла. Это неэффективно при активной работе с файлом.

### Решение: Таблица открытых файлов
**Системный вызов Open():**
1. При активном доступе к файлу используется системный вызов `open()`
2. Запись из директории копируется в **таблицу открытых файлов процесса**
3. Проверяются права доступа
4. Если всё в порядке, файл становится доступным для операций
5. Возвращается **файловый дескриптор (file descriptor)** — индекс в таблице открытых файлов

**Системный вызов Close():**
- Освобождает запись в таблице открытых файлов
- Записывает изменения на диск
- Освобождает ресурсы

### Таблица открытых файлов системы
При совместном доступе к файлам структура усложняется:

**Двухуровневая система таблиц:**
1. **Таблица открытых файлов процесса** (для каждого процесса)
   - Содержит указатель на системную таблицу
   - Текущая позиция чтения/записи (уникальна для каждого процесса)
   - Права доступа
   - Режим открытия (чтение, запись и т.д.)

2. **Таблица открытых файлов системы** (глобальная)
   - Расположение файла на диске
   - Размер файла
   - Даты доступа
   - **Счётчик открытий** — количество процессов, открывших файл

**Дополнительные механизмы:**
- В некоторых системах — **блокировки файлов** для предотвращения конфликтов при одновременном доступе
- Блокировки могут быть разделяемыми (shared) или эксклюзивными (exclusive)

![[OS 66.png]]

---
## Типы файлов
### Классификация по типам
Операционные системы могут различать файлы по типам:
#### 1. Исполняемые файлы
- **Обязательны для поддержки системой**
- Содержат машинный код, который может быть загружен и выполнен
- Имеют специальную внутреннюю структуру (заголовок, секции кода, данных и т.д.)
- Система **ВСЕГДА** отличает исполняемые файлы от других типов
#### 2. Архивы
- Содержат сжатые или несжатые наборы файлов
- Могут иметь специальную структуру
#### 3. Файлы данных
- Текстовые файлы
- Бинарные файлы
- Файлы баз данных
- Мультимедиа файлы и другие

### Способы идентификации типа файла
**1. Расширение имени файла:**
- Например: `.exe`, `.txt`, `.jpg`, `.pdf`
- Используется в Windows и DOS
- Удобно для пользователя, но ненадёжно (можно изменить расширение)

**2. Магические числа (magic numbers):**
- Специальные байты в начале файла
- Используется в Unix/Linux
- Более надёжный способ
- Примеры: ELF-заголовок для исполняемых файлов Linux

![[OS 67.png]]

---
## Структура файла
### Подходы к структурированию файлов
Операционные системы могут по-разному подходить к вопросу структуры файлов:
#### 1. Неструктурированный подход (современные ОС)
**Характеристики:**
- Файл — просто последовательность байтов
- Система не накладывает никакой структуры
- Интерпретация содержимого — задача прикладной программы
- **Преимущества:**
  - Максимальная гибкость
  - Не возникает проблем при установке новых приложений с новыми форматами файлов
  - Приложения могут использовать любые структуры данных
- **Недостатки:**
  - Нет встроенной поддержки структурированных данных
  - Каждое приложение должно само обрабатывать структуру своих файлов

#### 2. Структурированный подход
**Характеристики:**
- ОС определяет набор структур, поддерживаемых системой
- Например: записи фиксированной длины, последовательность записей с ключевыми полями
- **Преимущества:**
  - Встроенная поддержка базовых операций со структурированными данными
  - Оптимизация на уровне ОС
- **Недостатки:**
  - Ограниченная гибкость
  - Увеличение размера файловой системы
  - Могут возникнуть проблемы при установке новых приложений с неподдерживаемыми форматами

### Поддержка исполняемых файлов
**Важное исключение:**
Структура **исполняемых файлов** поддерживается всегда, так как система должна уметь:
- Загружать программу в память
- Настраивать адресное пространство
- Передавать управление на точку входа
---
## Записи и позиционирование
### Понятие записи
**Запись** — это наименьший элемент данных, который может быть обработан как единое целое прикладной программой при обмене с внешним устройством.

**Характеристики записей:**
- Могут быть **фиксированной** или **переменной** длины
- Определяют логическую структуру файла
- Не обязательно совпадают с физическими блоками на диске

### Преобразование записей в блоки
**Блок** — минимальная единица данных, которая может быть прочитана или записана на внешнее устройство.

**Процесс пакования и распаковки:**
1. **Пакование (упаковка):**
   - Перед операциями чтения-записи записи объединяются в **блоки** для вывода
   - Несколько логических записей могут помещаться в один физический блок

2. **Распаковка:**
   - При чтении блока записи извлекаются из блока
   - Предоставляются приложению в исходном виде

**Блочный фактор (blocking factor):**
- Число логических записей в одном физическом блоке
- Влияет на эффективность операций ввода-вывода

**Формула блочного фактора:**
```
	Блочный фактор = Размер блока / Размер записи
```

### Внутренняя фрагментация
**Проблема:**
Все файловые системы страдают от **внутренней фрагментации**:
- Если размер файла не кратен размеру блока, последний блок используется не полностью
- Образуется свободное пространство внутри последнего блока
- Это пространство не может быть использовано другими файлами

**Пример:**
- Размер блока: 4096 байт
- Размер файла: 5000 байт
- Используется: 2 блока (8192 байт)
- Потери: 3192 байт (внутренняя фрагментация)

---
## Методы доступа к файлам
Для того, чтобы информация, хранящаяся в файле, стала доступной, её надо **найти** в файле и **считать** нужные блоки файла в оперативную память.

**Выбор метода доступа** для конкретного приложения — одна из существенных проблем разработки.

### 1. Последовательный доступ (Sequential Access)
**Последовательный доступ** — самый простой и распространённый метод доступа к файлам.

**Принцип работы:**
- Записи файла обрабатываются **по порядку**, одна за другой
- Текущая позиция в файле определяется автоматически
- Чтение происходит от начала до конца файла
- Записи могут быть **постоянной** или **переменной** длины
- При достижении конца файла дальнейшее чтение невозможно
- Запись новых данных обычно происходит в конец файла

**Характеристики:**
- Записи могут быть **постоянной** или **переменной** длины
- Текущая позиция определяется автоматически
- Последовательное чтение от начала до конца

**Операции:**
- `read_next()` — чтение следующей записи
- `write_next()` — запись следующей записи
- `rewind()` — возврат к началу файла
- `skip n` — пропустить n записей (иногда поддерживается)

**Применение:**
- Обработка логов
- Потоковое чтение данных
- Архивы на ленточных накопителях
### 2. Прямой доступ (Direct Access / Random Access)
**Прямой доступ** позволяет обращаться к записям файла по их номерам (индексам), без необходимости последовательного чтения всех предыдущих записей.

**Принцип работы:**
- Записи файла имеют **фиксированную длину**
- Каждая запись имеет **номер** (индекс)
- Доступ к записи осуществляется напрямую по её номеру
- Не требуется чтение предыдущих записей
- Позволяет быстро читать или записывать произвольные записи
- Текущая позиция может быть изменена произвольно

**Реализация:**
1. При обращении по номеру логической записи **вычисляется блок**, в котором находится нужная запись
2. Вычисленный блок **считывается с диска** в память
3. Из блока извлекается нужная запись

**Формула:**
```
номер_блока = номер_записи / записей_в_блоке
смещение_в_блоке = номер_записи % записей_в_блоке
```

**Важная особенность:**
Номер блока является **относительным номером блока** — индекс относительно начала файла, а не абсолютный адрес на диске.

**Операции:**
- `read(n)` — чтение записи номер n
- `write(n)` — запись в позицию номер n
- `seek(n)` — установка текущей позиции на запись n

**Применение:**
- Базы данных
- Файлы с индексами
- Системы управления файлами

#### Запрос к записи по номеру n для прямого доступа:
Если **l - длина логической записи**. То запрос преобразуется в чтение l байт начиная с позиции l * n внутри файла

Или: 
	```
	адрес записи = базовый адрес + (n - 1) * l + 1
	```

### 3. Индексный доступ (Indexed Access)
**Описание:**
- Строится **индексный файл**, содержащий указатели на блоки данных
- Поиск осуществляется через индекс
- Обеспечивает быстрый доступ по ключевым полям

### Взаимная симуляция методов доступа
**Важное замечание:**
- **Последовательный доступ на файле прямого доступа** — легко реализуется (просто последовательно читаем записи по порядку)
- **Прямой доступ на последовательном файле** — труднее и неэффективно (нужно читать все записи до нужной)

---
## Организация файлов
Организация файла определяет способ размещения данных в файле и методы доступа к ним.

![[OS 69.png]]
### 1. Последовательная организация
**Описание:**
Простейший вариант — **последовательный файл**, представляющий собой последовательность записей.

**Характеристики:**
- При однобайтовых записях файл является потоком байтов
- Обработка предполагает последовательное чтение записей от начала файла
- Конкретная запись определяется её положением в файле
- **Модель ленты** — последовательный доступ

**Операции:**
- Чтение от начала до конца
- `rewind()` — возврат к началу файла
- Запись только в конец файла (в некоторых системах)

**Применение:**
- Магнитные ленты
- Потоковая обработка данных
- Логи и журналы событий

### 2. Последовательная организация с записями фиксированной длины
**Улучшение:**
Хранение файла в виде последовательности **записей фиксированной длины**, каждая из которых имеет внутреннюю структуру.

**Характеристики:**
- Операция чтения производится над **записью**
- Операция записи переписывает или добавляет запись
- Упрощается вычисление позиции записи

**Исторические примеры:**
- **80 байт** — соответствовало числу позиций в перфокарте
- **132 символа** — ширина принтера
- **128 символов** — в ОС CP/M

**Замечание:**
С введением CRT-терминалов (мониторов) данная идея утратила популярность, так как исчезла привязка к физическим устройствам ввода-вывода.

### 3. Индексно-последовательная организация
**Описание:**
Последовательность записей **переменной длины**, каждая из которых содержит **ключевое поле** в фиксированной позиции внутри записи.

**Ключевые особенности:**
- Файл хранится в отсортированном виде по ключевому полю
- Строится индекс для ускорения поиска
- Возможен как последовательный, так и прямой доступ
---
## Индексация и методы доступа по ключу
### Проблема поиска записи
Во многих случаях известно **значение ключа** — поля с фиксированным размещением внутри записи, а **не номер записи**.

**Задача:** Найти запись по значению ключа.

### Идеальный случай: прямое вычисление адреса
В некоторых **очень редких случаях** возможно построение функции, которая по значению ключа **однозначно вычисляет адрес** (номер блока) записи:

```
адрес = F(ключ)
```

**Требования к функции F():**
- Должна быть **линейной** для обеспечения однозначного соответствия
- Каждому ключу соответствует уникальный адрес
- Обратное преобразование также должно быть возможным

**Проблема:**
В реальности такие функции построить практически невозможно, так как:
- Пространство ключей может быть разреженным
- Ключи могут быть нечисловыми
- Требуется избыточное дисковое пространство

### Хэширование (Hashing)
**Суть метода:**
Используется **хэш-функция** `h(k)` для вычисления адреса **начала поиска** записи.

**Принцип работы:**
1. Берём значение ключа (или некоторые его характеристики)
2. Вычисляем хэш-функцию: `адрес = h(ключ)`
3. Полученное значение — адрес начала поиска
4. Если там не та запись, ищем дальше согласно алгоритму разрешения коллизий

**Важные понятия:**
- **Коллизия** — ситуация, когда нескольким разным ключам соответствует одно значение хэш-функции
- **Синонимы** — значения ключей, которые имеют одно и то же значение хэш-функции

**Два независимых решения при использовании хэширования:**
1. **Выбор хэш-функции** — как вычислять адрес из ключа
2. **Выбор метода разрешения коллизий** — что делать, когда несколько ключей дают один адрес

### Разрешение коллизий при хэшировании
#### Стратегия 1: Свободное замещение (Open Addressing)
**Принцип:**
При возникновении коллизии ищем следующую свободную ячейку в основной области.
**Алгоритм вставки:**
1. Для каждой новой записи вычисляется значение хэш-функции
2. Запись заносится в основную область в соответствии с полученным значением
3. Если ячейка занята, применяется метод пробирования:
   - **Линейное пробирование:** проверяем следующие ячейки подряд
   - **Квадратичное пробирование:** проверяем ячейки с квадратичным шагом
   - **Двойное хэширование:** используем вторую хэш-функцию для вычисления шага

**Алгоритм поиска:**
1. Вычисляем хэш-функцию от ключа
2. Проверяем ячейку по вычисленному адресу
3. Если не та запись, применяем тот же метод пробирования, что и при вставке
4. Продолжаем до нахождения записи или пустой ячейки

**Недостатки:**
- **Первичная кластеризация** — образование длинных цепочек занятых ячеек
- Снижение производительности при заполнении таблицы
- Сложность удаления записей

#### Стратегия 2: Метод цепочек с областью переполнения
**Принцип:**
Хэш-таблица делится на две области:
1. **Основная область** — для записей, попавших на свободные ячейки
2. **Область переполнения** — для записей-синонимов (коллизий)

**Алгоритм вставки:**
1. Вычисляем хэш-функцию от ключа
2. Если ячейка свободна, записываем в основную область
3. Если ячейка занята:
   - Помещаем запись в область переполнения
   - Создаём ссылку от записи в основной области на цепочку в области переполнения

**Алгоритм поиска:**
1. Вычисляем хэш-функцию
2. Проверяем ячейку в основной области
3. Если не та запись, следуем по цепочке ссылок в области переполнения

**Преимущества:**
- Проще удаление записей
- Нет первичной кластеризации
- Более предсказуемая производительность

**Недостатки:**
- Требуется дополнительная память для области переполнения
- При большом числе коллизий цепочки становятся длинными

![[OS 68.png]]

---
## Индексная организация файлов
### Общие принципы
**Индексная организация** применима только при **фиксированной длине записей**, которые могут быть блокированными или неблокированными.

**Фиксированная длина записей** - это случай, когда каждая запись файла имеет одинаковый размер.

**Блокированные записи** - это когда несколько записей объединены в один блок для эффективного ввода-вывода.

**Неблокированные записи** - это когда каждая запись хранится отдельно, без объединения в блоки.

**Ключевая идея:**
Расположение записей в наборе определяется с помощью **индексов** — специальных записей, которые содержат:
- Значение ключа
- Указатель на местоположение записи с этим ключом

**Характеристики:**
- Индексы **автоматически строятся** системой при создании файла
- Индексы **корректируются** при обновлении файла
- Обеспечивают относительно быстрый доступ к записям

**Структура:**
- **Индексный файл** обычно хранится на том же устройстве, что и сам файл
- Индексный файл — упорядоченный список элементов
- Каждый элемент индекса содержит:
  - Идентификатор записи (ключ)
  - Указание о местоположении данной записи

**Процесс поиска:**
1. Обращение к индексному файлу
2. Нахождение нужного ключа в индексе
3. Извлечение адреса записи
4. Обращение к основному файлу по найденному адресу

Такие файлы называются **индексированными**, а метод доступа к ним — **доступ с использованием индекса**.

### Типы индексов
#### 1. Плотный индекс (Dense Index)
**Определение:**
В индексных файлах с плотным индексом для **каждой записи** в основной области существует **одна запись** в индексной области.

**Структура основной области:**
- Последовательность записей одинаковой длины
- Записи расположены в произвольном порядке

**Структура индексной области:**
- Для каждой записи основной области — одна индексная запись
- Все записи в индексной области **упорядочены по значению ключа**
- Можно применить эффективные способы поиска в упорядоченном пространстве

**Важное замечание:**
Так как индексные файлы строятся для **первичных ключей (ПК)**, в них не может быть двух записей с одним значением ПК (первичный ключ уникален).

![[OS 70.png]]

**Алгоритм поиска:**
Наиболее эффективным алгоритмом поиска на упорядоченном массиве является **логарифмический (бинарный) поиск**:
1. Пространство поиска разбивается пополам
2. Так как оно строго упорядочено, определяется, в какой половине находится искомый элемент
3. Процесс повторяется для выбранной половины
4. Продолжается до нахождения элемента

**Формула максимального времени доступа:**
```
T_n = log₂(N_бл.инд.) + 1
```
где:
- `T_n` — количество обращений к диску
- `N_бл.инд.` — количество блоков в индексе
- `+1` — одно обращение для чтения самой записи из основной области

**Пример:**
- Размер индекса: 10 000 элементов
- Количество блоков индекса: 1000
	- Максимальное число обращений: log₂(1000) + 1 ≈ 10 + 1 = 11 обращений к диску

#### 2. Неплотный индекс (Sparse Index)
**Определение:**
Неплотный индекс строится для **упорядоченных файлов** и использует принцип **внутреннего упорядочения** для уменьшения количества хранимых индексов.
**Упорядоченный файл** — файл, в котором записи хранятся в порядке возрастания (или убывания) значений ключевого поля.
**Внутреннее упорядочение** — организация записей в файле таким образом, что они следуют определённому порядку на основе значений ключевых полей.

**Основная идея:**
- Основная область хранится в упорядоченном виде по ключу
- В индексе хранятся указатели **не на каждую запись**, а только на **первую запись каждого блока**

**Структура записи индекса:**
```
[Ключ первой записи блока] [Адрес блока]
```

**Алгоритм поиска:**
1. В индексе находится блок, который **может содержать** нужную запись
2. Блок считывается в память
3. Внутри блока осуществляется последовательный или бинарный поиск

**Формула времени доступа:**
```
T_n = log₂(KIB) + 1
```
где:
- `KIB` — количество индексных блоков (блоков в индексе)
- Индекс значительно меньше, чем при плотном индексе

**Пример:**
Предположим, у нас файл из 25 000 записей, размер блока = 50 записей:
- Количество блоков данных: 25 000 / 50 = 500 блоков
- Количество элементов в индексе: 500 (по одному на блок)
- Если в блоке индекса 100 элементов: количество блоков индекса = 5
- Время доступа: log₂(5) + 1 ≈ 3 + 1 = 4 обращения к диску

Это **существенно меньше**, чем при произвольном хранении записей файла, но требует **поддержания основного файла в упорядоченном виде**.

![[OS 71.png]]

**Недостаток:**
Поддержание основного файла в упорядоченном виде требует дополнительных затрат при вставке и удалении записей.

### Многоуровневые индексы
**Проблема:**
Для больших файлов индекс может быть слишком велик.

**Решение:**
Создать **индекс для индексного файла** (блоки промежуточного уровня или блоки косвенной адресации).

**Древовидная организация:**
- Блоки, составляющие файл, являются листьями дерева
- Каждый внутренний узел содержит указатели на множество блоков файла
- Корень дерева — главный индекс

**Способ выделения дискового пространства при помощи индексных узлов:**
Применяется в ряде ОС (Unix и некоторых других). Используется древовидная организация блоков.

![[OS 72.png]]

---
## Обобщение: методы доступа к файлам
### Классификация методов
**Основные методы доступа:**
1. **Sequential Access (последовательный доступ)**
   - Простейший метод
   - Чтение записей по порядку

2. **Direct Access (прямой доступ)**
   - Доступ к записям по номеру
   - Требует записи фиксированной длины

3. **Indexed Access (индексный доступ)**
   - Использование индексных структур
   - Доступ по ключевым полям

4. **Seek (позиционирование)**
   - Поиск и установка текущей позиции в файле
   - Изменение указателя без чтения данных

5. **Access by Key (доступ по ключу)**
   - Для индексированных файлов
   - Поиск записи по значению ключа
---

## Типичная организация файловой системы
### Уровни файловой системы
Файловая система имеет многоуровневую архитектуру:
**Уровни (сверху вниз):**
1. **Логическая файловая система (Logical File System)**
   - Работа с файлами и директориями
   - Операции: open, close, read, write, create, delete
   - Управление правами доступа
   - Интерфейс для пользовательских программ

2. **Модуль организации файлов (File Organization Module)**
   - Управление логической структурой файлов
   - Преобразование логических записей в физические блоки
   - Управление свободным пространством

3. **Базовая файловая система (Basic File System)**
   - Работа с блоками данных
   - Управление буферами в памяти
   - Кэширование данных

4. **Управление вводом-выводом (I/O Control)**
   - Работа с драйверами устройств
   - Передача команд контроллерам устройств
   - Обработка прерываний

5. **Устройства хранения (Storage Devices)**
   - Физические диски и другие накопители

![[OS 73.png]]

---
## Директории (каталоги)
### Назначение директорий
**Директория (каталог)** — специальный файл, содержащий информацию о других файлах и поддиректориях.

**Основные функции директорий:**
1. **Организация файлов** — группировка файлов по логическим категориям
2. **Именование** — обеспечение уникальных имён для файлов
3. **Навигация** — обеспечение пути доступа к файлам
4. **Хранение метаданных** — информация об атрибутах файлов
5. **Управление доступом** — контроль прав доступа к файлам

### Информация, хранимая в директориях
Директория содержит записи о файлах, каждая из которых включает:
- **Имя файла**
- **Тип файла** (обычный файл, директория, специальный файл)
- **Расположение файла** на диске (номера блоков или указатель на структуру индексных узлов)
- **Размер файла**
- **Атрибуты файла** (права доступа, владелец, временные метки)
- В некоторых системах — указатель на файловый дескриптор или индексный узел (inode)

### Обеспечение надёжности файловой системы
Директории участвуют в обеспечении надёжности файловой системы разными способами:
- Дублирование критической информации
- Хранение контрольных сумм
- Поддержка механизмов восстановления
- Ведение журналов изменений
---
## Структуры организации директорий
### 1. Одноуровневая структура (Single-Level Directory)

**Описание:**
Все файлы находятся в одной директории (корневой директории).

**Структура:**
```
Root Directory
├── file1.txt
├── file2.exe
├── file3.dat
├── ...
└── fileN.doc
```

**Характеристики:**
- Простейшая организация
- Все файлы имеют уникальные имена в пределах системы
- Нет возможности группировки файлов

**Преимущества:**
- Простота реализации
- Быстрый поиск файла по имени
- Минимальные накладные расходы

**Недостатки:**
- Проблема уникальности имён при большом количестве файлов
- Невозможность группировки файлов по категориям
- Сложность навигации при большом количестве файлов
- Нет изоляции между пользователями

**Применение:**
Использовалась в ранних операционных системах, сейчас практически не применяется.

---
### 2. Двухуровневая структура (Two-Level Directory)
**Описание:**
Отдельная директория для каждого пользователя. Все пользовательские директории находятся в корневой директории.

**Структура:**
```
Root Directory
├── User1/
│   ├── file1.txt
│   ├── file2.txt
│   └── program.exe
├── User2/
│   ├── file1.txt  (допустимо, так как в другой директории)
│   ├── data.dat
│   └── script.sh
└── User3/
    ├── document.doc
    └── image.jpg
```

**Характеристики:**
- Каждый пользователь имеет свою директорию
- Имена файлов должны быть уникальными только в пределах директории пользователя
- Изоляция файлов разных пользователей

**Преимущества:**
- Решена проблема конфликта имён между пользователями
- Обеспечена изоляция пользователей
- Простая реализация защиты файлов

**Недостатки:**
- Ограниченная возможность группировки файлов
- Сложность организации совместного доступа к файлам
- Нет возможности создания подкатегорий
- Неудобство при работе со множеством файлов одного пользователя

**Применение:**
Использовалась в некоторых ранних многопользовательских системах.

---
### 3. Древовидная структура (Tree-Structured Directory)
**Описание:**
Иерархическая структура с корневой директорией и произвольной глубиной вложенности поддиректорий.

**Структура:**
```
Root (/)
├── home/
│   ├── user1/
│   │   ├── documents/
│   │   │   ├── report.doc
│   │   │   └── notes.txt
│   │   ├── pictures/
│   │   │   ├── photo1.jpg
│   │   │   └── photo2.png
│   │   └── programs/
│   │       └── app.exe
│   └── user2/
│       ├── data/
│       └── projects/
├── usr/
│   ├── bin/
│   │   └── sh
│   └── lib/
└── var/
    └── log/
```

**Характеристики:**
- **Корневая директория** — начало дерева
- Каждая директория может содержать файлы и поддиректории
- Произвольная глубина вложенности
- Эффективный поиск и навигация

**Ключевые возможности:**
#### Текущая (рабочая) директория
- Каждый процесс имеет **текущую директорию** (current/working directory)
- Файлы в текущей директории можно указывать без полного пути
- Изменяется командой `cd` (change directory)

#### Пути доступа
**1. Абсолютный путь (Absolute Path):**
- Указывает полный путь от корневой директории
- Начинается с символа корня (`/` в Unix, `C:\` в Windows)
- Примеры:
  - Unix: `/usr/bin/sh` — путь к командному процессору Bourne Shell
  - Windows: `C:\Users\John\Documents\file.txt`

**2. Относительный путь (Relative Path):**
- Указывает путь относительно текущей директории
- Не начинается с символа корня
- Использует специальные обозначения:
  - `.` — текущая директория
  - `..` — родительская директория
- Примеры:
  - `documents/report.doc` — файл в поддиректории documents
  - `../pictures/photo.jpg` — файл в соседней директории pictures
  - `../../data/file.dat` — файл на два уровня выше

**Преимущества древовидной структуры:**
- **Эффективный поиск** — логарифмическая сложность при сбалансированном дереве
- **Возможность группировки** — логическая организация файлов
- **Поддержка понятий** текущей директории и пути доступа
- **Масштабируемость** — подходит для больших файловых систем
- **Гибкость** — произвольная организация файлов

**Недостатки:**
- Невозможность совместного использования файлов (файл может быть только в одной директории)
- Дублирование файлов при необходимости доступа из разных мест

**Применение:**
Используется в большинстве современных операционных систем как основа структуры директорий.

---
### 4. Структура в виде ациклического графа (Acyclic Graph)
**Описание:**
Граф без циклов, позволяющий директориям **разделять (share)** и **совместно использовать** поддиректории и файлы.

**Важное уточнение:**
Разделяемые директории и файлы **не являются копиями** — это те же самые файлы и директории, а не их дубликаты!

**Структура:**
```
Root
├── user1/
│   ├── programs/
│   │   └── shared_app → [link to /common/app]
│   └── data/
│       └── shared_file.txt → [link to /common/data/file.txt]
├── user2/
│   ├── projects/
│   │   └── shared_file.txt → [link to /common/data/file.txt]
│   └── tools/
│       └── shared_app → [link to /common/app]
└── common/
    ├── app/
    │   └── (actual program)
    └── data/
        └── file.txt (actual file)
```

#### Механизмы реализации
**1. Hard Links (жёсткие ссылки):**
**Характеристики:**
- Прямая ссылка на индексный узел (inode) файла
- Все жёсткие ссылки равноправны
- Нельзя создать для директорий (в большинстве систем)
- Работают только в пределах одной файловой системы
- Файл существует, пока есть хотя бы одна ссылка на него

**Механизм работы:**
- В индексном узле хранится **счётчик ссылок** (link count)
- При создании жёсткой ссылки счётчик увеличивается
- При удалении ссылки счётчик уменьшается
- Когда счётчик = 0, файл физически удаляется с диска

**Пример (Unix/Linux):**
```bash
# Создание жёсткой ссылки
ln /path/to/original /path/to/link

# Оба пути указывают на один и тот же файл
# Изменения через любой путь влияют на оригинал
```

**2. Symbolic Links / Soft Links (символические/мягкие ссылки):**
**Характеристики:**
- Специальный файл, содержащий путь к целевому файлу/директории
- Можно создавать для директорий
- Работают между разными файловыми системами
- При удалении оригинала ссылка становится "битой" (dangling link)

**Механизм работы:**
- Символическая ссылка — отдельный файл специального типа
- Содержит текстовую строку с путём к целевому файлу
- При обращении система автоматически перенаправляет на целевой файл

**Пример (Unix/Linux):**
```bash
# Создание символической ссылки
ln -s /path/to/original /path/to/link

# Ссылка указывает на путь, а не на inode
```

**Сравнение Hard Links и Soft Links:**

| Характеристика            | Hard Link           | Soft Link      |
| ------------------------- | ------------------- | -------------- |
| Для директорий            | Нет                 | Да             |
| Между файловыми системами | Нет                 | Да             |
| После удаления оригинала  | Файл доступен       | Битая ссылка   |
| Размер                    | Запись в директории | Отдельный файл |
| Производительность        | Выше                | Немного ниже   |

#### Преимущества ациклического графа:
- **Совместное использование** файлов и директорий
- **Экономия дискового пространства** — нет дублирования
- **Согласованность данных** — изменения видны всем пользователям
- **Гибкость организации** — различные способы доступа к одним данным

#### Недостатки и проблемы:
- **Сложность удаления** — нужно отслеживать все ссылки
- **Проблема обхода** — алгоритмы обхода усложняются
- **Управление ссылками** — требуется механизм подсчёта ссылок или сборки мусора

#### Решение проблем при удалении:
**При использовании hard links:**
- Система поддерживает счётчик ссылок в inode
- Файл удаляется только когда счётчик = 0
- Гарантирует отсутствие битых ссылок

**При использовании soft links:**
- Возможны битые ссылки
- Требуется проверка существования целевого файла
- Некоторые системы периодически ищут и удаляют битые ссылки
---
### 5. Структура в виде общего (произвольного) графа (General Graph)
**Описание:**
Разрешаются **циклы** в структуре директорий — директория может содержать ссылку на свою родительскую директорию или на себя (кроме стандартных `.` и `..`).

**Пример цикла:**
```
/home/user/dir1/
    ├── dir2/
    │   └── link_to_dir1 → [ссылка на /home/user/dir1]
    └── file.txt
```

При обходе: `dir1 → dir2 → link_to_dir1 → dir2 → link_to_dir1 → ...` (бесконечный цикл)

#### Проблемы произвольного графа
**1. Бесконечные циклы при обходе:**
- Алгоритмы поиска файлов могут зациклиться
- Программы копирования и архивации могут работать бесконечно
- Команды типа `find`, `du`, `ls -R` могут не завершиться

**2. Проблема сборки мусора:**
- Файл может быть недостижим из корня, но участвовать в цикле
- Счётчик ссылок не обнулится
- Классические алгоритмы сборки мусора не работают

**3. Сложность определения корректности:**
- Трудно гарантировать, что файл достижим из корня
- Сложно вычислить реальный размер поддерева

#### Методы решения проблемы циклов
**Метод 1: Запрет на создание циклов**
- Не разрешать создание ссылок на директории (только hard links на файлы)
- Разрешать только символические ссылки на директории, но не учитывать их при обходе
- **Недостаток:** ограничение функциональности

**Метод 2: Обнаружение циклов при обходе**
- Отслеживать посещённые директории (по inode номеру)
- Если директория уже была посещена, не входить в неё повторно
- **Недостаток:** накладные расходы на хранение информации о посещённых узлах

**Метод 3: Ограничение глубины обхода**
- Установить максимальную глубину обхода дерева
- Прекратить обход при достижении лимита
- **Недостаток:** может не обойти все легитимные файлы

**Метод 4: Сборка мусора**
- Периодически выполнять **сборку мусора** во внешней памяти
- Искать файлы и директории, недостижимые из корня
- Удалять такие файлы
- **Недостаток:** традиционные алгоритмы сборки мусора не делают проверок на наличие циклов, нужны специальные алгоритмы

**Метод 5: Проверка при создании ссылки**
- Каждый раз при создании новой ссылки запускать алгоритм проверки отсутствия циклов
- Отклонять создание ссылки, если она создаёт цикл
- **Недостаток:** "дорогое" решение, замедляет создание ссылок
---
## Монтирование файловых систем
### Концепция монтирования
**Монтирование (Mounting)** — процесс подключения файловой системы, находящейся на некотором устройстве, к общему дереву директорий операционной системы.

**Зачем нужно монтирование:**
Структура директорий может быть выстроена на нескольких **томах** (физических или логических дисках). Они должны быть **смонтированы** для того, чтобы стали доступными в единой иерархии директорий.

### Процесс монтирования
**Операционной системе предоставляется:**
1. **Имя устройства** — физическое устройство с файловой системой (например, `/dev/sda1` в Linux или `D:` в Windows)
2. **Точка монтирования (mount point)** — место подсоединения, пустая директория в существующей файловой системе

**Алгоритм монтирования:**
1. ОС проверяет, что точка монтирования существует и является директорией
2. Читается суперблок файловой системы с устройства
3. Проверяется корректность файловой системы
4. Файловая система подключается к указанной точке монтирования
5. Содержимое этой директории становится корнем смонтированной файловой системы

**Результат:**
После монтирования файлы на устройстве становятся доступными через указанный путь в общей иерархии директорий.

### Примеры монтирования
**Linux/Unix:**
```bash
# Монтирование раздела диска
mount /dev/sda2 /mnt/data

# Теперь файлы с /dev/sda2 доступны через /mnt/data/
# Например: /mnt/data/file.txt

# Размонтирование
umount /mnt/data
```

**Windows:**
- Автоматическое монтирование разделов как логических дисков (C:, D:, E:)
- Монтирование в директории (точки подключения NTFS):
  ```
  C:\Mount\Data → подключение другого раздела
  ```

### Автоматическое монтирование
**Linux:** файл `/etc/fstab` описывает файловые системы для автоматического монтирования при загрузке.

**Пример `/etc/fstab`:**
```
# <устройство>  <точка монт.>  <тип ФС>  <опции>    <dump>  <fsck>
/dev/sda1       /              ext4      defaults   0       1
/dev/sda2       /home          ext4      defaults   0       2
/dev/sdb1       /mnt/data      ntfs      defaults   0       0
```

---
## Удалённые файловые системы
### Концепция удалённого доступа
Удалённые файловые системы позволяют работать с файлами, физически находящимися на других компьютерах в сети.

### Типы удалённых файловых систем
**1. World Wide Web (WWW)**
- Доступ через протоколы HTTP/HTTPS
- Файлы доступны по URL
- Обычно только чтение (хотя есть WebDAV для записи)

**2. Распределённые файловые системы (Distributed File Systems - DFS)**
- Клиент-серверная архитектура
- Прозрачный доступ к удалённым файлам
- Файлы выглядят как локальные

**Примеры DFS:**
#### NFS (Network File System)
- Разработана Sun Microsystems для Unix
- Широко используется в Linux/Unix окружении
- Использует RPC (Remote Procedure Call)
- Поддерживает монтирование удалённых директорий

**Принцип работы:**
```
Клиент                        Сервер
   |                             |
   | mount server:/share /mnt    |
   |---------------------------->|
   |                             |
   | Обращение к /mnt/file.txt   |
   |---------------------------->| Чтение /share/file.txt
   |<----------------------------|
```

#### SMB/CIFS (Server Message Block / Common Internet File System)
- Разработана Microsoft
- Используется в Windows сетях
- Позволяет разделять файлы, принтеры, порты
- Кросс-платформенная реализация: Samba (для Linux)

**Компоненты:**
**1. Редиректор (Redirector)**
- Компонент клиентской стороны
- Перехватывает запросы к файлам
- Определяет, локальный файл или удалённый
- Перенаправляет запросы на сервер

**2. Сервер (Server)**
- Обрабатывает запросы клиентов
- Управляет доступом к разделяемым ресурсам
- Обеспечивает безопасность

#### AFS (Andrew File System)
- Разработана в университете Carnegie Mellon
- Масштабируемая DFS для больших сетей
- Кэширование на стороне клиента
- Поддержка большого количества клиентов

---
## Распределённые информационные системы
**Цель:** Обеспечение единого взгляда на сетевую информацию и ресурсы.
### Службы каталогов
**1. LDAP (Lightweight Directory Access Protocol)**
- Протокол для доступа к службам каталогов
- Хранение информации о пользователях, компьютерах, ресурсах
- Централизованное управление
- Используется для:
  - Аутентификации пользователей
  - Хранения контактной информации
  - Управления политиками безопасности

**2. Active Directory (Microsoft)**
- Служба каталогов на основе LDAP
- Интеграция с Windows сетями
- Управление пользователями, группами, компьютерами
- Групповые политики

**3. DNS (Domain Name System)**
- Распределённая система имён
- Преобразование доменных имён в IP-адреса
- Иерархическая структура

---
## CIFS – Common Internet File System (Microsoft)
### Архитектура CIFS
CIFS — расширение протокола SMB, предназначенное для работы через Интернет.

### Типы сообщений CIFS
**1. Session Control Messages**
- Команды для установки и разрыва соединения с сервером

**2. File Messages**
- Открытие, закрытие, чтение, запись файлов

**3. Printer Messages**
- Работа с сетевыми принтерами
- Отправка заданий на печать
- Управление очередью печати

**4. Miscellaneous Messages**
- Позволяют редиректору писать в **named pipes** и **mailslots**
- Получение информации о статусе сервера и ресурсов

### Named Pipes и Mailslots
**Named Pipes:**
- Механизм межпроцессного взаимодействия
- Двунаправленная связь
- Работает по сети через CIFS

**Mailslots:**
- Однонаправленная связь
- Для широковещательных сообщений
- Менее надёжна, чем named pipes

---
## Виртуальная файловая система (VFS)
### Назначение VFS
**Виртуальная файловая система (Virtual File System, VFS)** — абстрактный слой в ядре операционной системы, обеспечивающий единый интерфейс для работы с различными типами файловых систем.

**Цели VFS:**
1. **Единообразный доступ** клиентских приложений к различным типам файловых систем
2. **Организация единого интерфейса** доступа пользователя к различным файловым системам, драйверы которых загружены в память компьютера
3. **Абстракция от типа файловой системы** — приложения не знают, какая конкретно ФС используется

### Возможности VFS
VFS может быть использована для доступа к:
- **Локальным файловым системам:** FAT32, ext4, NTFS, XFS, Btrfs и др.
- **Сетевым файловым системам:** NFS, SMB/CIFS
- **Специальным файловым системам:** procfs, sysfs, tmpfs
- **Виртуальным устройствам**

### Принцип работы VFS
**Архитектура:**

```
Приложение
     |
     | (системные вызовы: open, read, write, close)
     |
     v
+---------+
|   VFS   | ← Абстрактный интерфейс
+---------+
     |
     +------------------+------------------+
     |                  |                  |
     v                  v                  v
+----------+      +-----------+      +-----------+
|  ext4    |      |   NTFS    |      |    NFS    |
| драйвер  |      |  драйвер  |      |  драйвер  |
+----------+      +-----------+      +-----------+
     |                  |                  |
     v                  v                  v
  Диск 1             Диск 2          Сетевой сервер
```

**VFS декларирует программный интерфейс** между ядром и конкретной файловой системой:
- Определяет набор операций, которые должна реализовать каждая ФС
- Стандартизирует структуры данных (inode, dentry, file)
- Обеспечивает кэширование и буферизацию

**Для добавления поддержки новой файловой системы:**
Нужно лишь написать драйвер, реализующий интерфейс VFS.

### VFS в различных ОС
**Linux:**
- Механизм VFS — часть ядра, исходный код открыт
- Это позволяет разработчикам ФС писать драйверы максимально эффективно
- **Результат:** Linux поддерживает монтирование подавляющего большинства современных файловых систем
- Поддерживает более 50 различных файловых систем

**OS/2 и Microsoft Windows:**
- Механизм называется **Installable File System (IFS)** — устанавливаемая файловая система
- Драйверы ФС загружаются динамически
- Закрытый интерфейс (хотя документирован для разработчиков)

**Unix:**
- Файловые системы включают **File System Switch** в System V Release 3
- В Ultrix — похожий механизм
- Более ранняя реализация концепции VFS

### Преимущества VFS

1. **Прозрачность:** приложения не зависят от типа файловой системы
2. **Расширяемость:** легко добавить поддержку новых ФС
3. **Переносимость:** приложения работают с любыми ФС
4. **Эффективность:** централизованное кэширование и буферизация
5. **Безопасность:** единая точка контроля доступа

![[OS 74.png]]


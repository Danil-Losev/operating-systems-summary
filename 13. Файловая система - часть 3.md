#Operating_Systems #OS_File_System 
## Введение
### Связь задач управления дисковым пространством
Для лучшего понимания структуры данных файловой системы на диске необходимо рассмотреть два взаимосвязанных аспекта:
1. **Алгоритмы выделения дискового пространства** - как файловая система распределяет блоки диска между файлами
2. **Способы учета свободной и занятой дисковой памяти** - как система отслеживает, какие блоки доступны для использования

Эти задачи **тесно связаны** между собой и влияют на:
- Производительность файловой системы
- Эффективность использования дискового пространства
- Скорость доступа к данным
- Надежность хранения информации

### Общий принцип организации
Для каждого метода выделения пространства запись в директории, соответствующая символьному имени файла, содержит **указатель**, следуя которому можно найти все блоки данного файла.

Различные методы отличаются:
- Способом организации этого указателя
- Структурой хранения информации о блоках файла
- Компромиссом между производительностью и эффективностью использования пространства
---
## Методы выделения дискового пространства
### Непрерывное размещение (Contiguous Allocation)
#### Описание метода
**Простейший способ** хранения файлов - каждый файл представляет собой непрерывную последовательность блоков диска.

**Характеристики файла при непрерывном размещении:**
- **Адрес первого блока** (стартовый блок b)
- **Длина файла** (количество блоков n)

**Физическое размещение:**
Файл, стартующий с блока b, последовательно занимает блоки:
```
b, b+1, b+2, b+3, ..., b+n-1
```

#### Преимущества метода
**1. Простота реализации**
- Выяснение местонахождения файла сводится к вопросу: "Где находится первый блок?"
- В директории хранятся только два числа: начальный адрес и длина
- Простой расчет адреса любого блока: **адрес блока i = начальный адрес + i**

**2. Высокая производительность**
- **Целый файл может быть считан за одну дисковую операцию**
- Минимальное количество перемещений головки диска
- Идеально подходит для последовательного доступа
- Эффективен и для прямого доступа (быстрый расчет адреса блока)

#### Примеры использования
Непрерывное выделение используется в:
- **IBM/CMS** - операционная система IBM
- **RSX-11** - для хранения выполняемых файлов
- **ISO 9660** - файловая система CD-ROM
- **UDF** - файловая система DVD

#### Недостатки метода
**1. Внешняя фрагментация**
В процессе эксплуатации диск представляет собой совокупность свободных и занятых фрагментов:

```
[Файл A][Свободно 3 блока][Файл B][Свободно 10 блоков][Файл C][Свободно 5 блоков]
```

**Проблема:**
- Не всегда имеется подходящий по размеру свободный фрагмент для нового файла
- Даже если суммарно свободного места достаточно, оно разбросано по маленьким кускам
- Создание файла размером 8 блоков в примере выше невозможно без перемещения данных

**2. Проблема выделения блока нужного размера**
Метод страдает от классической проблемы выделения памяти - необходимо выбрать подходящий свободный фрагмент из списка:

**Стратегии выбора:**
- **First Fit** - первый подходящий фрагмент
- **Best Fit** - наименьший достаточный фрагмент
- **Worst Fit** - наибольший доступный фрагмент

Все стратегии со временем приводят к фрагментации.

**3. Невозможность динамического роста файла**
- Если файл нужно увеличить, а следующие блоки заняты - файл необходимо переместить
- Предварительное выделение "с запасом" приводит к внутренней фрагментации

**4. Необходимость уплотнения (дефрагментации)**
**Единственное решение** перечисленных проблем:
- Периодическое **уплотнение содержимого внешней памяти**
- "Сборка мусора" - объединение свободных участков в один большой блок
- **Дорогостоящая операция**, невозможная для частого выполнения

**Процесс дефрагментации:**
1. Перемещение файлов в начало диска
2. Объединение свободных областей в конце
3. Обновление всех ссылок на перемещенные блоки

#### Когда метод применим
**Нерационален для:**
- Систем с постоянно изменяющимся содержимым диска
- Многопользовательских систем
- Серверов с активной записью

**Вполне пригоден для:**
- **Стационарных файловых систем** (read-only)
- **Компакт-дисков** (CD-ROM, DVD)
- **Архивных систем**
- Систем, где файлы создаются один раз и не изменяются

### Связный список (Linked Allocation)
#### Суть метода
**Решение проблемы внешней фрагментации**: представление файла в виде связного списка блоков диска.

**Организация:**
- Запись в директории содержит указатель на **первый** и **последний** блоки файла
- Иногда используется специальный знак **конца файла (EOF)**
- **Каждый блок содержит указатель на следующий блок**

![[OS 79.png]]

#### Структура блока
```
┌────────────────────────────────────┐
│  Данные файла (например, 508 байт) │
├────────────────────────────────────┤
│     Указатель на следующий блок    │
│             (4 байта)              │
└────────────────────────────────────┘
Общий размер блока: 512 байт
```

#### Преимущества
**1. Отсутствие внешней фрагментации**
- Файл может использовать **любые свободные блоки**
- Не требуется непрерывная область
- Блоки файла могут быть разбросаны по всему диску

**2. Динамический рост файла**
- Файл легко увеличивается добавлением новых блоков
- Достаточно найти любой свободный блок и добавить его в конец списка

**3. Простое выделение памяти**
- Не нужно искать фрагмент определенного размера
- Подойдет любой свободный блок

#### Недостатки метода
**1. Потеря эффективности прямого доступа**
**Проблема последовательного обхода:**
- Для поиска i-го блока нужно осуществить несколько обращений к диску
- Последовательно считываются блоки от 1 до i-1
- **Теряются все преимущества прямого доступа к файлу**

**Пример:**
```
Чтобы прочитать блок 100:
1. Прочитать блок 0 → получить адрес блока 1
2. Прочитать блок 1 → получить адрес блока 2
...
100. Прочитать блок 99 → получить адрес блока 100
101. Наконец, прочитать блок 100

Итого: 101 операция чтения вместо одной!
```

**2. Низкая надежность**
**Последствия дефектного блока:**
- Наличие дефектного блока в списке приводит к **потере информации** в оставшейся части файла
- Потенциальная **потеря дискового пространства**, отведенного под файл
- Разрыв цепочки делает недоступными все последующие блоки

**3. Потеря полезного пространства в блоке**
**Проблема с размером блока:**
- Для указателя на следующий блок нужно выделить место внутри блока (обычно 4 байта)
- Емкость блока традиционно является степенью двойки (256, 512, 1024, 2048, 4096 байт)
- С учетом указателя блок перестает быть степенью двойки (512 - 4 = 508 байт полезных данных)

**Неудобства:**
- Многие программы читают и пишут блоками по степеням двойки
- Приходится выполнять дополнительные операции для работы с "неправильным" размером

#### Вывод
Метод связного списка **обычно в чистом виде не используется** из-за существенных недостатков, особенно потери производительности при прямом доступе.

### Таблица отображения файлов (FAT)
#### Усовершенствование метода связного списка
**Ключевая идея:** хранить указатели **не в дисковых блоках**, а в **индексной таблице в памяти**.

**Название:** FAT - **File Allocation Table** (таблица размещения файлов)
#### Системы, использующие FAT
Этой схемы придерживаются многие популярные ОС:
- **MS-DOS**
- **OS/2**
- **MS Windows** (для FAT16, FAT32, exFAT)
- Windows 95/98/ME
- Съемные носители (флешки, карты памяти)

#### Структура FAT
**Организация таблицы:**
- Таблица состоит из записей, **по одной на каждый блок диска**
- Номер записи соответствует номеру блока
- Содержимое записи - номер **следующего блока** файла

**Запись в директории содержит:**
- Имя файла
- Атрибуты
- **Ссылку на первый блок** файла

![[OS 80.png]]

**Пример:**
```
Файл начинается с блока 4:

Таблица FAT:
Блок 0: [система]
Блок 1: EOF       (конец другого файла)
Блок 2: 9         (следующий блок - 9)
Блок 3: [свободен]
Блок 4: 7         (начало нашего файла, следующий - 7)
Блок 5: [свободен]
Блок 6: 2         (следующий блок - 2)
Блок 7: 6         (следующий блок - 6)
Блок 8: [свободен]
Блок 9: EOF       (конец нашего файла)

Последовательность блоков файла: 4 → 7 → 6 → 2 → 9
```
#### Граничные значения
В строках таблицы, соответствующих последним блокам файлов, записывается **граничное значение**:
- **EOF** (End Of File) - конец файла
- Или специальное числовое значение (например, 0xFFFF для FAT16)

#### Преимущества FAT
**1. Сохранение полезного объема блока**
- Указатели хранятся в отдельной таблице
- **Весь блок используется для данных**
- Нет потери пространства на указатели в блоках

**2. Улучшенная производительность прямого доступа**
- Таблица FAT находится в памяти
- Можно быстро пройти по цепочке блоков **без обращения к диску**
- Прямой доступ к блоку i требует просмотра только таблицы в памяти

**3. Оптимизация размещения**
- **Можно судить о физическом соседстве блоков** на диске
- При выделении нового блока легко найти свободный блок **поблизости** от других блоков файла
- Минимизация времени поиска головки диска

**4. Простота управления свободным пространством**
- Свободные блоки легко идентифицировать по специальному значению в FAT
- Быстрый поиск свободных блоков

#### Недостатки FAT
**1. Размер таблицы в памяти**

**Проблема масштабирования:**
- Таблица должна содержать по одной записи на каждый блок диска
- Для больших дисков таблица становится **очень большой**

**Расчет размера FAT:**
```
Диск 1 ТБ, блоки по 4 КБ:
Количество блоков = 1 ТБ / 4 КБ = 268 миллионов блоков
Размер FAT (4 байта на запись) = 268М × 4 = 1 ГБ!
```

**2. Ограничение размера диска/файла**
Варианты FAT имеют ограничения:
- **FAT12**: максимум 4096 кластеров (для дискет)
- **FAT16**: максимум 65536 кластеров → максимум 2 ГБ (с блоками 32 КБ)
- **FAT32**: максимум около 268 миллионов кластеров → максимум 2 ТБ
- Размер файла в FAT32 ограничен 4 ГБ

**3. Уязвимость к повреждениям**
- Повреждение FAT приводит к потере доступа ко всем файлам
- Критически важная структура данных
- Обычно хранится в двух копиях для надежности

**4. Фрагментация**
- Не решает проблему фрагментации
- Файлы со временем разбиваются на несвязанные блоки
- Снижение производительности

#### Оптимизации FAT
**Кэширование:**
- Вся таблица или её часть держится в памяти
- Критично для производительности

**Резервирование:**
- Обычно хранятся **две копии** FAT на диске
- При повреждении одной копии используется вторая

### Индексные узлы (i-node)
#### Концепция индексных узлов
**Наиболее распространенный метод** выделения файлу блоков диска:

Связать с каждым файлом **небольшую таблицу** - **индексный узел** (i-node, index node), которая перечисляет:
- Атрибуты файла
- Дисковые адреса блоков файла

#### Организация системы
**Запись в директории:**
- Имя файла
- **Адрес индексного блока** (номер i-node)

**Индексный узел:**
- По мере заполнения файла указатели на блоки диска принимают осмысленные значения
- Содержит как метаданные, так и адреса блоков данных

![[OS 81.png]]

#### Преимущества индексирования
**1. Поддержка прямого доступа**
- Все адреса блоков файла собраны в одном месте
- Можно быстро найти любой блок файла
- Не нужно последовательно проходить по цепочке

**2. Отсутствие внешней фрагментации**
- Блоки файла могут располагаться в любых местах диска
- Индексный узел хранит все необходимые адреса

**3. Широкое распространение**
- Поддерживает как **последовательный**, так и **прямой** доступ к файлу
- Используется в большинстве современных файловых систем Unix/Linux

#### Многоуровневая индексация
**Проблема:** размер файлов может сильно варьироваться - от нескольких байт до гигабайт.

**Решение:** комбинация одноуровневого и многоуровневых индексов.

#### Структура индексного узла
**Прямая адресация (Direct Blocks):**
Первые несколько адресов блоков файла хранятся **непосредственно в индексном узле**:
- Обычно 12-15 прямых указателей
- Для **маленьких файлов** индексный узел хранит всю необходимую информацию
- Обеспечивает **максимальную производительность** для небольших файлов

**Косвенная адресация (Indirect Blocks):**
Для больших файлов один из адресов индексного узла указывает на **блок косвенной адресации**:
- Этот блок содержит адреса **дополнительных блоков данных** файла
- Позволяет адресовать существенно больше блоков

**Двойная косвенная адресация (Double Indirect):**
Если и косвенной адресации недостаточно:
- Используется блок **двойной косвенной адресации**
- Содержит адреса **блоков косвенной адресации**
- Каждый из которых содержит адреса блоков данных

**Тройная косвенная адресация (Triple Indirect):**
Для очень больших файлов:
- Блок **тройной косвенной адресации**
- Указывает на блоки двойной косвенной адресации
- Которые указывают на блоки косвенной адресации
- Которые указывают на блоки данных

#### Схема индексного узла в Unix
```
Индексный узел (inode):
├─ Метаданные (владелец, права, размер, время и т.д.)
├─ Прямые указатели (12 шт.) → блоки данных (12 блоков)
├─ Одинарный косвенный → блок адресов → блоки данных (256 блоков)
├─ Двойной косвенный → блоки адресов → блоки адресов → данные (65536 блоков)
└─ Тройной косвенный → блоки адресов → ... → данные (16777216 блоков)
```


**Пример расчета (блок 4 КБ, адрес 4 байта):**
**Прямая адресация:**
- 12 блоков × 4 КБ = 48 КБ

**Одинарная косвенная:**
- 1 блок указателей = 4 КБ / 4 байта = 1024 указателя
- 1024 блока × 4 КБ = 4 МБ

**Двойная косвенная:**
- 1024 блока указателей × 1024 блока данных = 1048576 блоков
- 1048576 × 4 КБ = 4 ГБ

**Тройная косвенная:**
- 1024 × 1024 × 1024 = 1073741824 блоков
- 1073741824 × 4 КБ = 4 ТБ

**Максимальный размер файла:** 48 КБ + 4 МБ + 4 ГБ + 4 ТБ ≈ **4 ТБ**

#### Системы, использующие i-node
Данную схему используют:
- **Unix File System (UFS)** и все её вариации
- **ext2, ext3, ext4** (Linux)
- **HPFS** (OS/2)
- **NTFS** (Windows) - с модификациями
- **HFS+, APFS** (macOS)
- **XFS, JFS, ReiserFS** и другие

#### Преимущества многоуровневой индексации
**1. Гибкость размера**
Фиксированный, относительно небольшой размер индексного узла поддерживает работу с файлами, размер которых может меняться **от нескольких байтов до нескольких терабайт**.

**2. Оптимизация для маленьких файлов**
Для маленьких файлов (большинство в системе):
- Используется только **прямая адресация**
- Обеспечивает **максимальную производительность**
- Не требуется дополнительных обращений к диску

**3. Поддержка больших файлов**
Для больших файлов:
- Дополнительные уровни косвенности подключаются по необходимости
- Можно адресовать огромное количество блоков
- Разумный компромисс между размером индексного узла и максимальным размером файла

**4. Быстрый доступ**
- Прямой доступ к любому блоку файла
- Не нужно последовательно проходить всю цепочку
- Для доступа к блоку нужно пройти максимум 4 уровня (i-node → тройной косвенный → двойной → одинарный → данные)

#### Недостатки
**1. Потеря пространства на индексные блоки**
- Индексные узлы занимают место на диске
- Блоки косвенной адресации используют дисковое пространство

**2. Уязвимость индексных блоков**
- Повреждение индексного узла делает **недоступными данные файла**
- Даже если сами данные не повреждены
- Критичность сохранности индексных структур

**3. Дополнительные обращения к диску**
- Для больших файлов требуется несколько чтений для получения адреса блока
- Частично компенсируется кэшированием индексных блоков

#### Оптимизации
**Кэширование индексных узлов:**
- Часто используемые i-node держатся в памяти
- Существенно ускоряет доступ к файлам

**Группирование блоков:**
- В ext2/ext3/ext4 диск разделен на группы блоков
- Индексные узлы и данные одного файла хранятся в одной группе
- Минимизация времени поиска

**Экстенты (extents):**
- В ext4, XFS, NTFS вместо отдельных блоков используются экстенты
- Экстент - непрерывная последовательность блоков
- Один указатель описывает много блоков: (начальный_адрес, длина)
- Уменьшает количество указателей для больших файлов
---
## Управление свободным пространством
Для эффективной работы файловой системы необходимо отслеживать, какие блоки диска свободны, а какие заняты.

### Битовый вектор (Bitmap)
#### Описание метода
Список свободных блоков диска реализуется в виде **битового вектора** (bit map, bit vector).
**Организация:**
- Каждый блок диска представлен **одним битом**
- Бит принимает значение:
  - **0** - блок свободен
  - **1** - блок занят
  - (или наоборот, в зависимости от реализации)

**Пример:**
```
0011110011110001100000...
││││││││││││││││││││││
└┴┼┼┼┼┴┴┼┼┼┼┴┴┴┼┼┴┴┴┴┴─ свободные блоки
  └┴┴┴──┴┴┴┴───┴┴────── занятые блоки (файл)
```

#### Преимущества битового вектора
**1. Относительная простота**
- Легко проверить состояние любого блока
- Простая структура данных

**2. Эффективность поиска свободных блоков**

**Поиск первого свободного блока:**
- Многие компьютеры имеют **инструкции манипулирования битами**
- Например, компьютеры Intel и Motorola имеют инструкции для локализации первого единичного (или нулевого) бита в слове
- Можно быстро найти свободный блок

**Поиск n последовательных свободных блоков:**
- Битовый вектор позволяет легко получить информацию о **смежных областях** дисковой памяти
- Важно для непрерывного выделения или минимизации фрагментации
- Можно за один проход найти достаточно большой непрерывный фрагмент

**3. Минимальный размер структуры**
- Один бит на блок - наиболее компактное представление
- Например, для диска с 1 миллионом блоков нужно всего 125 КБ

#### Пример использования

Метод учета свободных блоков с помощью битового вектора используется в:
- **Apple Macintosh** (HFS, HFS+)
- **ext2, ext3, ext4** (Linux)
- **NTFS** (Windows) - 
- **XFS** (Unix)

#### Недостатки битового вектора
**1. Проблема масштабирования**
Несмотря на минимальный размер, битовый вектор может оказаться **большого размера** для современных дисков.

**Расчет размера битового вектора:**
**Пример 1: Диск 4 ГБ, блоки 4 КБ**
```

Количество блоков = 4 ГБ / 4 КБ = 1 миллион блоков
Размер битового вектора = 1М бит / 8 = 125 КБ
Результат: легко помещается в память
```

**Пример 2: Диск 4 ТБ, блоки 4 КБ**
```
Количество блоков = 4 ТБ / 4 КБ = 1 миллиард блоков
Размер битового вектора = 1Г бит / 8 = 125 МБ
Результат: значительный объем памяти
```

**2. Требование к размещению в памяти**
Метод **эффективен только**, если битовый вектор **помещается в памяти целиком**.

**Проблема частичной загрузки:**
- Если вектор не помещается в памяти, приходится держать только его часть
- Поиск свободных блоков может требовать чтения других частей с диска
- Теряется преимущество быстрого поиска

**3. Решение для больших дисков**
**Разбиение на регионы:**
Когда битовый вектор становится слишком большим:
1. Вектор разбивают на **регионы** (области диска)
2. Организуют **резюмирующие структуры данных**
3. Резюме содержит сведения о **количестве свободных блоков** для каждого региона

**Преимущества разбиения:**
- Ускорение поиска свободного пространства
- Можно держать в памяти только резюме и активные регионы
- Возможность балансировки нагрузки между регионами

**Пример резюмирующей структуры:**
```
Регион 0: 1500 свободных блоков из 10000
Регион 1: 8300 свободных блоков из 10000
Регион 2: 200 свободных блоков из 10000
...
```

При поиске свободного блока сначала проверяется резюме, выбирается регион с достаточным количеством свободного места, и только затем загружается битовый вектор этого региона.

### Связный список свободных блоков (Free Block List)
#### Описание метода
Альтернативный подход: **связать в список все свободные блоки**.

**Организация:**
- Указатель на **первый свободный блок** размещается в специально отведенном месте диска (например, в суперблоке)
- Эта информация **кэшируется в памяти**
- Каждый свободный блок содержит указатель на следующий свободный блок

#### Преимущества метода
**1. Не требует дополнительного пространства**
- Используются сами свободные блоки для хранения списка
- Отсутствует расходование дополнительной дисковой памяти на структуры управления

**2. Работа с большими дисками**
- Не зависит от размера диска
- Не нужно держать всю структуру в памяти

**3. Простота добавления и удаления**
- Освобождение блока - добавление в начало списка
- Выделение блока - взятие первого элемента списка

#### Недостатки метода
**1. Неэффективность трассирования**
Для полного обхода списка:
- Нужно выполнить **много обращений к диску**
- Каждый свободный блок нужно прочитать, чтобы получить адрес следующего
- Очень медленная операция

**2. Отсутствие информации о смежности**
При использовании списка свободной памяти:
- **Невозможно** легко получить информацию о смежных областях дисковой памяти
- Трудно найти несколько последовательных свободных блоков
- Приводит к фрагментации

**3. Необходимость прохода по списку**
Для поиска определенного количества блоков нужно:
- Последовательно пройти по списку
- Прочитать несколько блоков с диска
- Неэффективно при частых выделениях

#### Частичное решение проблемы
**К счастью**, во многих ситуациях нам необходим только **первый свободный блок**:
- Для выделения одного блока достаточно взять голову списка
- Это быстрая операция, не требующая обхода

#### Модификация метода связного списка
**Группировка свободных блоков:**
Более эффективная организация:
1. Хранить адреса **n свободных блоков** в первом свободном блоке
2. Первые **n-1** этих блоков действительно используются для выделения
3. **Последний** (n-й) блок содержит адреса **других n свободных блоков**
4. И так далее

**Преимущества модификации:**
- Меньше обращений к диску при выделении нескольких блоков
- Можно держать в памяти список из n адресов
- Когда список заканчивается, читается следующая порция адресов

**Пример организации (n=100):**
```
Блок A (первый свободный):
├─ Адрес свободного блока 1
├─ Адрес свободного блока 2
├─ ...
├─ Адрес свободного блока 99
└─ Адрес блока B (содержит следующие 100 адресов)

Блок B:
├─ Адрес свободного блока 100
├─ Адрес свободного блока 101
├─ ...
└─ Адрес блока C
```

#### Другие методы
**Свободное пространство как файл:**
- Свободное пространство можно рассматривать как специальный файл
- Вести для него соответствующий **индексный узел**
- Использовать все преимущества индексированного доступа

**Комбинированные подходы:**
- Использование битового вектора для метаданных
- Списки для больших областей свободного пространства
- Гибридные структуры данных

### Сравнение методов

| Характеристика | Битовый вектор | Связный список |
|----------------|----------------|----------------|
| **Размер структуры** | Фиксированный, пропорционален размеру диска | Минимальный, использует сами свободные блоки |
| **Поиск первого свободного блока** | Очень быстро (битовые операции) | Быстро (взять первый элемент) |
| **Поиск n последовательных блоков** | Быстро | Медленно, требует обхода |
| **Информация о смежности** | Доступна | Отсутствует |
| **Память** | Весь вектор или резюме в памяти | Только голова списка |
| **Для больших дисков** | Требует разбиения на регионы | Работает без модификаций |

**Выбор метода зависит от:**
- Размера диска
- Доступной оперативной памяти
- Паттернов использования (много мелких файлов vs. мало больших)
- Требований к производительности

---
## Размер блока
### Важность выбора размера блока
Размер логического блока играет **важную роль** в производительности и эффективности файловой системы.

В некоторых системах (например, Unix) размер блока может быть **задан при форматировании диска**.

### Проблемы маленького размера блока
**Последствия использования небольших блоков:**

**1. Большое количество блоков на файл**
- Каждый файл будет содержать **много блоков**
- Увеличивается количество записей в индексных структурах
- Растет размер таблиц отображения

**2. Медленное чтение файла**
Каждая операция чтения блока сопровождается задержками:
- **Время поиска** (seek time) - перемещение головки к нужному цилиндру
- **Задержка вращения** (rotational latency) - ожидание, пока нужный сектор окажется под головкой
- **Время передачи** (transfer time) - собственно чтение данных

**Проблема:**
- Файл из многих блоков требует множества операций позиционирования
- Накладные расходы на поиск и вращение превышают время фактической передачи данных
- Файл будет **читаться медленно**

**Пример:**
```
Файл 100 КБ, блоки по 1 КБ:
- 100 операций чтения
- Если время поиска = 10 мс, вращения = 5 мс, чтения = 1 мс
- Общее время = 100 × (10 + 5 + 1) = 1600 мс = 1.6 секунды

Файл 100 КБ, блоки по 10 КБ:
- 10 операций чтения
- Общее время = 10 × (10 + 5 + 10) = 250 мс = 0.25 секунды
```
### Проблемы большого размера блока
**Последствия использования больших блоков:**

**1. Более высокая скорость обмена с диском**
- Меньше операций позиционирования
- Отношение времени передачи к накладным расходам выше
- Лучшая производительность последовательного чтения

**2. Внутренняя фрагментация**
**Проблема:**
- Каждый файл занимает **целое число блоков**
- В среднем **половина последнего блока** остается неиспользованной
- Чем больше блок, тем больше потери

**Пример:**
```
Блоки по 4 КБ:
- Файл 10 КБ занимает 3 блока = 12 КБ
- Потери: 2 КБ (17%)

Блоки по 64 КБ:
- Файл 10 КБ занимает 1 блок = 64 КБ
- Потери: 54 КБ (84%)!
```

**3. Снижение процента полезного дискового пространства**
Для диска с множеством маленьких файлов:
- Большие блоки приводят к значительным потерям пространства
- Может быть занято существенно больше места, чем реальный размер данных

### Размер блока и страницы виртуальной памяти
**Связь с виртуальной памятью:**

Для систем со **страничной организацией памяти** характерна сходная проблема с размером страницы.

**Желательное соотношение:**
- Единицей пересылки диск-память должна быть **страница**
- Упрощает работу подсистемы виртуальной памяти
- Позволяет напрямую отображать файлы в память (memory-mapped files)

**Наиболее распространенный размер страниц памяти:**
- **4 КБ** (4096 байт)
- На современных системах также 8 КБ, 16 КБ
- На серверах иногда используются huge pages (2 МБ, 1 ГБ)

### Компромиссный выбор размера блока

**Типичные размеры блоков:**
Обычный компромиссный выбор размера блока:
- **512 байт** - старые системы, дискеты
- **1 КБ** (1024 байт) - старые Unix системы
- **2 КБ** (2048 байт)
- **4 КБ** (4096 байт) - **наиболее распространенный** в современных системах
- **8 КБ** (8192 байт)
- **16 КБ, 32 КБ, 64 КБ** - для специализированных применений

### Факторы выбора размера блока
**При выборе нужно учитывать:**

**1. Тип носителя:**
- **HDD**: большие блоки (4-64 КБ) - компенсируют медленный поиск
- **SSD**: средние блоки (4-16 КБ) - нет задержки поиска
- **NVMe**: оптимизация под размер страницы флеш-памяти

**2. Паттерны использования:**
- **Много мелких файлов** - меньший размер блока (4 КБ)
- **Большие мультимедиа файлы** - больший размер блока (64 КБ)
- **Базы данных** - зависит от размера страницы БД

**3. Размер диска:**
- **Маленькие диски** - меньший размер блока
- **Большие диски** - больший размер блока приемлем

**4. Архитектура системы:**
- Размер страницы памяти
- Размер кэш-линии процессора
- Размер сектора диска (традиционно 512 байт, новые диски - 4 КБ)

### Современные подходы
**Advanced Format (4K sectors):**
- Физический размер сектора на современных дисках - 4096 байт
- Лучше согласуется с размером блока 4 КБ
- Повышает эффективность использования пространства

**Переменный размер блока:**
- Некоторые ФС поддерживают разные размеры блоков для разных файлов
- Оптимизация для конкретных сценариев

**Экстенты:**
- Вместо отдельных блоков - непрерывные области (экстенты)
- Один экстент может покрывать много блоков
- Уменьшает метаданные для больших файлов

---

## Резюме: Файловые системы
### Основные концепции файлов
#### Определения

**Файл:**
- **Смежная область логического адресного пространства**
- Хранится, как правило, во внешней памяти
- Может содержать **данные** или **программу**
- Абстракция для работы с постоянным хранилищем

**Директория (каталог):**
- **Системная структура** во внешней памяти
- Содержит **ссылки** на файлы или другие директории
- Организует иерархию файловой системы

#### Структура файлов
**Организация данных в файле:**
- Файл делится на **записи** постоянной или переменной длины
- Возможны файлы **сложной структуры**, интерпретируемые создавшими их программами
  - Пример: документ Microsoft Word, Excel, PDF
- **Интерпретация**: файлы интерпретируют ОС и обрабатывающие их программы

### Атрибуты и операции с файлами
#### Основные атрибуты файла
Метаданные, описывающие файл:
- **Имя** - идентификатор для пользователя
- **Тип** - указывает формат данных
- **Ссылка на размещение** - где находятся данные на устройстве
- **Размер** - количество байтов
- **Признаки защиты** - права доступа
- **Время создания** - когда файл был создан
- **Время чтения** - последнее обращение
- **Время модификации** - последнее изменение

**Хранение:** информация о файлах хранится в структуре директорий.

#### Основные операции над файлом
**Жизненный цикл файла:**
1. **Создание** (create) - создание нового файла
2. **Запись** (write) - добавление или изменение данных
3. **Чтение** (read) - получение данных из файла
4. **Позиционирование** (seek) - изменение текущей позиции в файле
5. **Удаление** (delete) - уничтожение файла
6. **Сокращение** (truncate) - уменьшение размера файла
7. **Открытие** (open) - подготовка файла к работе
8. **Закрытие** (close) - завершение работы с файлом

#### Типы файлов
В большинстве ОС тип файла указывается с помощью **расширения имени**:
- .txt - текстовые файлы
- .exe, .com - исполняемые файлы
- .doc, .docx - документы Word
- .jpg, .png - изображения
- .mp3, .mp4 - мультимедиа
- и многие другие

### Методы доступа к файлам
#### Прямой доступ (Random Access)
**Характеристики:**
- Доступ к данным **по номеру блока**
- Можно читать блоки в **любом порядке**
- Необходим для баз данных, индексных файлов

#### Последовательный доступ (Sequential Access)
**Характеристики:**
- Чтение/запись данных **последовательно**
- С помощью **сдвига текущей позиции** (offset)
- Простая модель, естественна для лент и потоков

**Взаимосвязь:**
- Последовательный доступ может быть **смоделирован операциями прямого доступа**
- Обратное не всегда возможно (например, для ленточных накопителей)

#### Индексные файлы
**Назначение:** используются для ускорения поиска в больших основных файлах.

**Принцип:**
- Небольшой файл-индекс содержит ключи и указатели
- Основной файл содержит данные
- Поиск сначала в индексе (быстро), затем прямой доступ к данным

**Пример:** базы данных используют B-tree индексы для быстрого поиска записей.

### Организация хранения
#### Разделы диска
**Раздел (partition):**
- **Смежная область** дисковой памяти
- Имеет свое **логическое имя** (C:, D:, /dev/sda1)
- Файлы и директории в файловой системе хранятся в разделах

**Преимущества разделения:**
- Изоляция систем
- Разные файловые системы на одном диске
- Ограничение роста отдельных систем

### Операции с директориями
#### Основные операции над директорией
**Управление файлами:**
1. **Поиск файла** - нахождение файла по имени
2. **Создание файла** - добавление записи о новом файле
3. **Удаление файла** - удаление записи о файле
4. **Переименование файла** - изменение имени

**Управление структурой:**
5. **Создание поддиректории** - создание вложенной директории
6. **Вывод содержимого директории** - список файлов
7. **Создание символической ссылки** - ссылка на файл или директорию
8. **Обход файловой системы** - рекурсивный проход по дереву

### Логическая организация директорий
#### Типы структур директорий
**1. Одноуровневая директория**
- Все файлы в одном каталоге
- Простая, но неудобная
- Нет группировки

**2. Двухуровневая директория**
- Директория для каждого пользователя
- Базовое разделение
- Все еще ограничена

**3. Древовидная структура** ⭐ **Рекомендуется**
- Иерархия директорий
- **Преимущества:**
  - Поддиректории для каждого пользователя
  - Файлы с одинаковыми именами в разных директориях
  - Тематическая организация файлов
  - Масштабируемость

**4. Ациклический граф**
- Возникает при **совместном использовании** узлов
- Несколько поддиректорий ссылаются на один узел
- Реализуется через жесткие или символические ссылки
- Требует осторожности при удалении

**5. Произвольный граф**
- Может содержать **циклы**
- **Нежелательно:**
  - Обнаружение циклов - неэффективная операция
  - Проблемы с обходом дерева
  - Возможны бесконечные циклы
  - Усложнение операций типа поиска и удаления

### Методы реализации директорий
#### Способы реализации
**1. Линейный список**
- Простая реализация
- Медленный поиск (O(n))
- Подходит для небольших директорий

**2. Хеш-таблица** ⭐ **Более эффективна**
- Обеспечивает **высокую эффективность**
- Быстрый поиск (O(1) в среднем)
- Требует больше памяти
- Усложнение при изменении размера

### Методы размещения файлов
#### Основные методы
**1. Непрерывное (смежное) размещение**

**Характеристики:**
- Файл занимает **смежную область** памяти на диске
- **Преимущества:**
  - Простой и эффективный доступ
  - Отличная производительность для последовательного чтения
- **Недостатки:**
  - Невозможно увеличение файла
  - Внешняя фрагментация
  - Потери дисковой памяти

**2. Ссылочное размещение**
**Характеристики:**
- Файл представляется в виде **списка дисковых блоков**
- **Пример:** FAT (File Allocation Table) в MS-DOS и Windows
- **Преимущества:**
  - Отсутствуют потери дискового пространства
  - Легкое увеличение файла
- **Недостатки:**
  - Нет возможности эффективного произвольного доступа
  - Необходимо последовательно проходить список

**3. Индексируемое размещение** ⭐ **Наиболее распространено**
**Характеристики:**
- Все указатели на блоки данных собраны в **индексный блок** (индексную таблицу)
- **Преимущества:**
  - Возможен произвольный доступ
  - Отсутствие внешней фрагментации
  - Эффективное масштабирование
- **Недостатки:**
  - Требуется хранение индексных блоков
  - Повреждение индексного блока делает данные недоступными
  - Дополнительные обращения к диску для больших файлов

### Управление свободным пространством
#### Методы учета свободного пространства
**1. Битовый вектор (Bitmap)**
**Характеристики:**
- Каждый элемент (бит) указывает, **свободен ли i-й блок или занят**
- **Преимущества:**
  - Легко получить информацию о смежных областях
  - Быстрый поиск свободных блоков
  - Компактное представление
- **Недостатки:**
  - Для больших дисков требует много памяти
  - Должен помещаться в памяти для эффективности

**2. Список свободной памяти (Free List)**
**Характеристики:**
- Связный список свободных блоков
- **Преимущества:**
  - Отсутствует дополнительное расходование памяти
  - Не зависит от размера диска
- **Недостатки:**
  - Невозможно легко найти смежные области
  - Медленный обход для поиска нескольких блоков

### Оптимизация производительности
#### Кэширование и оптимизации
**Производительность управления дисковой памятью и вводом-выводом зависит от:**
**1. Кэширование диска (Disk Cache)**
- Часто используемые блоки держатся в памяти
- Существенное ускорение операций

**2. Опережающее считывание (Read-ahead)**
- Предсказание будущих обращений
- Загрузка данных заранее
- Эффективно для последовательного доступа

**3. Освобождение прочитанного**
- Освобождение кэша от редко используемых данных
- Алгоритмы замещения (LRU, LFU)

**4. Виртуальные диски в основной памяти (RAM disk)**
- Эмуляция диска в ОЗУ
- Максимальная скорость
- Потеря данных при отключении питания

#### Унифицированная буферная кэш-память
Для оптимизации кэширования используется **унифицированная буферная кэш-память** (unified buffer cache):
- Используется как при вводе-выводе в обычные файлы
- Так и при работе с файлами, отображаемыми в память (memory-mapped files)
- Устраняет дублирование данных в памяти
- Повышает эффективность использования ОЗУ

### Надежность файловых систем
#### Резервное копирование
Для сохранения и восстановления файлов рекомендуется использовать **резервное копирование**:
- Регулярные бэкапы
- Разные уровни: полные и инкрементные
- Хранение в безопасном месте
- Тестирование восстановления

#### Журналирование
**Файловые системы с журналом транзакций** обеспечивают **повышенную надежность**:
- Запись всех изменений в журнал перед применением
- Быстрое восстановление после сбоев
- Гарантия целостности метаданных
- Примеры: ext3/ext4, NTFS, XFS, JFS

**Преимущества журналирования:**
- Минимальное время восстановления после сбоя
- Атомарность операций
- Защита от потери данных при сбое питания
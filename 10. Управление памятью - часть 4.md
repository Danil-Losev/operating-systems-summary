#Operating_Systems #OS_Memory
## Введение в кэширование
### Основная проблема
Современные вычислительные системы сталкиваются с фундаментальным противоречием:
- **Пользователям необходима** большая, быстрая и недорогая память
- **В реальности существует закономерность**: чем больше объём памяти, тем она медленнее и дешевле; чем меньше объём — тем быстрее и дороже

### Что такое кэширование?
**Кэширование** — это универсальный метод организации памяти, который позволяет:
- Уменьшить среднее время доступа к данным
- Экономить дорогостоящую быстродействующую память
- Создать иллюзию большого объёма быстрой памяти

**Принцип работы**: динамическое копирование наиболее часто используемой информации из «медленного» запоминающего устройства в «быстрое».

---
## Иерархия памяти
### Общая структура
Память вычислительной машины представляет собой **иерархию запоминающих устройств (ЗУ)**, отличающихся:
- Средним временем доступа к данным
- Объёмом хранимой информации
- Стоимостью хранения одного бита

![[OS 64.png]]
### Уровни иерархии памяти (от быстрых к медленным)
#### 1. Регистры процессора
- **Расположение**: внутри процессора
- **Объём**: несколько десятков байт
- **Время доступа**: 2-3 наносекунды (1 такт процессора)
- **Характеристики**: самые быстрые, самые дорогие
- **Назначение**: хранение промежуточных данных текущих операций

#### 2. Статическая память (SRAM) — Кэш-память процессора
- **Объём**: от нескольких десятков до нескольких сотен килобайт (L1, L2, L3)
- **Время доступа**: не превышает 8 наносекунд
- **Характеристики**: очень быстрая, дорогая, компактная
- **Назначение**: хранение данных, требующих быстрого доступа

#### 3. Динамическая память (DRAM) — Оперативная память
- **Объём**: от десятков мегабайт до нескольких гигабайт
- **Время доступа**: 10-20 наносекунд
- **Характеристики**: относительно медленная, менее дорогая
- **Назначение**: основная рабочая память для выполняемых программ

#### 4. Внешняя память — Жёсткий диск (HDD)
- **Объём**: десятки и сотни гигабайт
- **Время доступа**: миллисекунды
- **Характеристики**: большой объём, низкая скорость
- **Назначение**: постоянное хранение данных

### Ключевая закономерность
> **Чем больше объём устройства, тем оно менее быстродействующее.**
> 
> **Стоимость хранения данных (в расчёте на один бит) увеличивается с ростом быстродействия.**
### Компромиссное решение
Кэш-память представляет собой **компромисс между скоростью и объёмом**, позволяя получить:
- Высокую скорость доступа (как у дорогой памяти)
- Большой эффективный объём (за счёт умного управления данными)
- Приемлемую стоимость (не нужно делать всю память быстрой)

---
## Концепция кэш-памяти
### Определение кэша
**Кэш-память (cache)** — это способ совместного функционирования двух типов запоминающих устройств, отличающихся временем доступа и стоимостью хранения данных.

За счет динамического копирования в «быстрое» ЗУ наиболее часто используемой информации из «медленного» ЗУ:
- **С одной стороны**: уменьшается среднее время доступа к данным
- **С другой стороны**: экономится более дорогая быстродействующая память

### Ключевое свойство — прозрачность
**Прозрачность кэш-памяти** означает, что:
- Система не требует внешней информации об интенсивности использования данных
- Пользователи не принимают участия в перемещении данных
- Программы не управляют кэшированием
- **Всё делается автоматически системными средствами**

### Терминология
Термином **«кэш»** или **«кэш-память»** часто называют:
1. Способ организации работы двух типов запоминающих устройств (методология)
2. Само «быстрое» ЗУ (конкретное устройство)

---
## Применение кэширования в различных подсистемах
### 1. Кэширование оперативной памяти
- **Быстрое ЗУ**: статическая память (SRAM)
- **Медленное ЗУ**: динамическая память (DRAM)
- **Цель**: уменьшение среднего времени доступа процессора к оперативной памяти

### 2. Кэширование дисковых данных (система ввода-вывода)
- **Быстрое ЗУ**: буферы в оперативной памяти
- **Медленное ЗУ**: жёсткий диск
- **Цель**: ускорение доступа к данным на диске

### 3. Виртуальная память как вариант кэширования
- **Быстрое ЗУ**: оперативная память
- **Медленное ЗУ**: жёсткий диск (файл подкачки)
- **Особенность**: используется не для уменьшения времени доступа, а для расширения доступного объёма памяти
- **Механизм**: временно неиспользуемый код и данные перемещаются на диск, освобождая место для активных процессов
- **Результат**: наиболее интенсивно используемые данные «оседают» в оперативной памяти
---
## Принципы работы кэш-памяти
### Структура записи в кэш-памяти
Содержимое кэш-памяти — это **совокупность записей** о загруженных элементах данных из основной памяти.

**Каждая запись включает**:
1. **Значение элемента данных** — сами данные
2. **Адрес в основной памяти** — откуда были скопированы данные
3. **Дополнительную информацию**:
   - **Признак модификации** (dirty bit) — изменялись ли данные в кэше
   - **Признак действительности** (valid bit) — являются ли данные актуальными

![[OS 65.png]]

### Алгоритм работы кэша
#### При каждом обращении к основной памяти:
**Шаг 1**: Просмотр содержимого кэш-памяти
- Поиск выполняется **по содержимому**, а не по адресу
- Ищется запись с нужным адресом основной памяти

**Шаг 2**: Возможны два варианта развития событий
##### Вариант А: Кэш-попадание (cache-hit) ✓
**Условие**: данные обнаружены в кэш-памяти

**Действия**:
1. Данные считываются из кэш-памяти
2. Результат передаётся источнику запроса
3. **Выигрыш**: данные получены быстро

##### Вариант Б: Кэш-промах (cache-miss) ✗
**Условие**: нужные данные отсутствуют в кэш-памяти

**Действия**:
1. Данные считываются из основной (медленной) памяти
2. Результат передаётся источнику запроса
3. **Одновременно**: данные копируются в кэш-память для будущих обращений

---
## Эффективность кэширования
### Среднее время доступа к памяти
Эффективность кэширования зависит от **вероятности попадания в кэш**.
#### Математическая модель
Пусть:
- **t₁** — среднее время доступа к основной (медленной) памяти
- **t₂** — время доступа к кэш-памяти (быстрой), где **t₂ << t₁**
- **p** — вероятность кэш-попадания (0 ≤ p ≤ 1)
- **t** — среднее время доступа в системе с кэшем

**По формуле полной вероятности**:
```
t = t₁(1 - p) + t₂p = (t₂ - t₁)p + t₁
```

#### Анализ формулы
**Среднее время доступа линейно зависит от вероятности попадания**:
- При **p = 0** (кэш пустой): t = t₁ (время доступа к медленной памяти)
- При **p = 1** (все данные в кэше): t = t₂ (время доступа к быстрой памяти)

**Вывод**: Использование кэш-памяти имеет смысл **только при высокой вероятности кэш-попадания** (обычно > 90%).

### Пример расчёта
Допустим:
- t₁ = 100 нс (оперативная память)
- t₂ = 10 нс (кэш)
- p = 0.95 (95% попаданий)

```
t = (10 - 100) × 0.95 + 100 = -90 × 0.95 + 100 = -85.5 + 100 = 14.5 нс
```

**Ускорение**: 100 / 14.5 ≈ **6.9 раз быстрее**!

---
## Факторы, влияющие на вероятность попадания
Вероятность обнаружения данных в кэше зависит от множества факторов:
### Характеристики системы
- **Объём кэша** — чем больше, тем выше вероятность попадания
- **Объём кэшируемой памяти** — чем меньше, тем эффективнее кэш
- **Алгоритм замещения данных** — определяет, что вытеснять из кэша
### Характеристики вычислительного процесса
- **Особенности выполняемой программы** — структура кода и данных
- **Время работы программы** — кэш «прогревается» со временем
- **Уровень мультипрограммирования** — количество одновременно работающих процессов

### Типичные показатели
В большинстве реализаций кэш-памяти **процент кэш-попаданий составляет свыше 90%**.
Такая высокая эффективность объясняется объективными свойствами данных: **локальностью**.

---
## Локальность данных
### Концепция локальности
**Локальность** — это свойство программ и данных, состоящее в том, что обращения к памяти группируются во времени и пространстве.

**Существует два типа локальности**:
### 1. Временная локальность (Temporal Locality)
**Определение**: Если произошло обращение по некоторому адресу, то **следующее обращение по тому же адресу с большой вероятностью произойдёт в ближайшее время**.

#### Примеры временной локальности:
**Пример 1: Переменная-счётчик в цикле**
```c
for (int i = 0; i < 1000; i++) {
    // Переменная i используется многократно
    array[i] = i * 2;
}
```
Переменная `i` обрабатывается многократно в короткий промежуток времени.

**Пример 2: Инструкции в цикле**
```c
while (condition) {
    // Эти инструкции выполняются многократно
    doSomething();
}
```
Код тела цикла выполняется многократно.

**Пример 3: Часто вызываемая функция**
```c
// Функция вызывается многократно
int calculate(int x) {
    return x * x + 2 * x + 1;
}
```

#### Как используется временная локальность в кэше:
**Принцип**: Вновь считанные данные помещаются в кэш, предполагая, что скоро они понадобятся снова.

**Динамика работы системы**:
1. **Начало работы** (кэш пуст):
   - Почти каждый запрос выполняется "по полной программе"
   - Просмотр кэша → констатация промаха → чтение из медленной памяти → копирование в кэш

2. **По мере заполнения кэша**:
   - Возрастает вероятность обращения к ранее использованным данным
   - Эти данные уже находятся в кэше
   - Данные считываются значительно быстрее

---
### 2. Пространственная локальность (Spatial Locality)
**Определение**: Если произошло обращение по некоторому адресу, то **с высокой вероятностью в ближайшее время произойдёт обращение к соседним адресам**.
#### Примеры пространственной локальности:
**Пример 1: Последовательное выполнение инструкций**
```assembly
MOV AX, 1     ; адрес 1000
ADD AX, BX    ; адрес 1004
JMP label     ; адрес 1008
```
Инструкции выполняются последовательно (кроме переходов).

**Пример 2: Обработка массива**
```c
int sum = 0;
for (int i = 0; i < 100; i++) {
    sum += array[i];  // Последовательный доступ к элементам
}
```
Элементы массива расположены последовательно в памяти.

**Пример 3: Обработка структур данных**
```c
struct Point {
    int x;
    int y;
};
Point p;
p.x = 10;  // Доступ к полю x
p.y = 20;  // Доступ к соседнему полю y
```

#### Как используется пространственная локальность в кэше:
**Принцип**: В кэш-память считывается **не один элемент**, к которому произошло обращение, а **целый блок данных**, расположенных в непосредственной близости.

**Преимущества блочного копирования**:
1. **Для программного кода**:
   - Команды обычно выбираются последовательно
   - Имеет смысл загружать целый фрагмент программы
   - Ускоряется выполнение последовательных инструкций

2. **Для массивов данных**:
   - При обработке массива загружается часть или весь массив
   - Учитывается высокая вероятность обращений к соседним элементам
   - Значительно сокращается число обращений к медленной памяти

**Типичный размер блока кэша**: 32-128 байт (зависит от архитектуры).

---
## Алгоритмы замещения в кэше
### Проблема вытеснения
В процессе работы содержимое кэш-памяти постоянно обновляется, поэтому **данные должны периодически вытесняться** из кэша.

### Что происходит при вытеснении?
**Вытеснение** может выполняться двумя способами:

#### 1. Простое освобождение места
**Условие**: вытесняемые данные за время нахождения в кэше **НЕ были изменены** (признак модификации = 0)

**Действия**:
- Объявление области кэш-памяти свободной
- Сброс бита действительности (valid bit)
- **Копирование в основную память не требуется** (данные там актуальны)

#### 2. Запись модифицированных данных
**Условие**: вытесняемые данные **были модифицированы** в кэше (dirty bit = 1)

**Действия**:
1. Копирование данных в основную память (запись изменений)
2. Объявление области кэш-памяти свободной
3. Сброс бита действительности

### Требования к алгоритмам замещения
**Идеальный алгоритм замещения должен**:
1. **Быть максимально быстрым** — не замедлять работу кэш-памяти
2. **Обеспечивать максимальную вероятность попаданий** — вытеснять наименее нужные данные

**Проблема**: Из-за непредсказуемости вычислительного процесса **ни один алгоритм не может гарантировать оптимальный результат**.

**Решение**: Разработчики используют **рациональные решения**, которые не сильно замедляют работу кэша.

### Популярные алгоритмы замещения
#### 1. LRU (Least Recently Used) — Давно не использовавшийся
**Принцип**: Вытесняется элемент, к которому дольше всего не было обращений.

**Достоинства**:
- Хорошо учитывает временную локальность
- Высокая эффективность для большинства приложений

**Недостатки**:
- Требует отслеживания времени последнего обращения
- Дополнительные аппаратные затраты

#### 2. FIFO (First In First Out) — Первым вошёл, первым вышел
**Принцип**: Вытесняется элемент, который дольше всего находится в кэше.

**Достоинства**:
- Простота реализации
- Низкие аппаратные затраты

**Недостатки**:
- Может вытеснять активно используемые данные
- Менее эффективен, чем LRU

#### 3. Random — Случайное вытеснение
**Принцип**: Вытесняется случайно выбранный элемент.

**Достоинства**:
- Максимально простая реализация
- Очень быстрый

**Недостатки**:
- Непредсказуемая эффективность
- Может вытеснять важные данные

#### 4. LFU (Least Frequently Used) — Реже всего использовавшийся
**Принцип**: Вытесняется элемент с наименьшим количеством обращений.

**Достоинства**:
- Учитывает частоту использования

**Недостатки**:
- Требует подсчёта количества обращений
- Может "застревать" старый часто использовавшийся элемент

---
## Согласование данных
### Проблема несогласованности
Наличие в компьютере **двух копий данных** (в основной памяти и в кэше) порождает **проблему согласования данных**.

**Ситуация**: Если происходит запись в основную память по некоторому адресу, а содержимое этой ячейки находится в кэше, то **соответствующая запись в кэше становится недостоверной**.

**Последствия** без механизмов согласования:
- Чтение из кэша вернёт устаревшие данные
- Нарушится целостность данных
- Программы будут работать некорректно

### Решения проблемы согласования
Существует два основных подхода к решению проблемы:
#### 1. Сквозная запись (Write-Through)
**Принцип**: Запись выполняется **одновременно** в кэш и в основную память.

**Алгоритм работы**:
**Шаг 1**: При каждом запросе на запись просматривается кэш

**Шаг 2А**: Если данных **НЕТ** в кэше:
- Запись выполняется только в основную память

**Шаг 2Б**: Если данные **ЕСТЬ** в кэше:
- Запись выполняется **одновременно** в кэш и основную память
- Данные всегда остаются согласованными

**Преимущества**:
- ✓ Простота реализации
- ✓ Данные в основной памяти всегда актуальны
- ✓ Надёжность при сбоях (данные не теряются)

**Недостатки**:
- ✗ Каждая запись требует обращения к медленной основной памяти
- ✗ Снижение производительности записи
- ✗ Увеличение нагрузки на шину памяти

**Схема Write-Through**:
```
Запрос на запись → Проверка кэша
                    ↓
        Данные в кэше? 
        /              \
     ДА                НЕТ
      ↓                 ↓
Запись в КЭШ       Запись только
     +             в основную
Запись в ОСН.         память
   память
```

#### 2. Обратная запись (Write-Back / Copy-Back)
**Принцип**: Запись выполняется **только в кэш**, а в основную память данные записываются **только при вытеснении**.

**Алгоритм работы**:
**Шаг 1**: При запросе на запись просматривается кэш

**Шаг 2А**: Если данных **НЕТ** в кэше:
- Запись выполняется только в основную память

**Шаг 2Б**: Если данные **ЕСТЬ** в кэше:
- Запись выполняется **только в кэш**
- Устанавливается **признак модификации** (dirty bit = 1)
- Основная память **НЕ обновляется**

**Шаг 3**: При вытеснении данных из кэша:
- Проверяется признак модификации
- Если dirty bit = 1, данные записываются в основную память
- Основная память актуализируется

**Преимущества**:
- ✓ Высокая производительность записи (работа с быстрым кэшем)
- ✓ Снижение нагрузки на шину памяти
- ✓ Эффективность при многократных записях в один адрес

**Недостатки**:
- ✗ Сложность реализации
- ✗ Основная память может содержать устаревшие данные
- ✗ Риск потери данных при сбоях (если не записаны в основную память)
- ✗ Необходимость хранения признака модификации для каждого блока

**Схема Write-Back**:
```
Запрос на запись → Проверка кэша
                    ↓
        Данные в кэше?
        /              \
     ДА                НЕТ
      ↓                 ↓
Запись в КЭШ      Запись в основную
Set dirty bit = 1      память
      ↓
При вытеснении:
dirty bit = 1?
    ↓ ДА
Запись в основную
     память
```
### Сравнение подходов

| Характеристика          | Write-Through                     | Write-Back                     |
| ----------------------- | --------------------------------- | ------------------------------ |
| **Скорость записи**     | Медленная (всегда обращение к ОП) | Быстрая (только кэш)           |
| **Согласованность**     | Всегда согласована                | Временно несогласована         |
| **Нагрузка на шину**    | Высокая                           | Низкая                         |
| **Сложность**           | Простая                           | Сложная                        |
| **Надёжность**          | Высокая (данные в ОП)             | Ниже (риск потери)             |
| **Типичное применение** | Простые системы                   | Высокопроизводительные системы |

---
## Резюме и ключевые концепции
### Управление памятью в ОС
**Оперативная память** — это важнейший ресурс вычислительной системы, требующий тщательного управления со стороны мультипрограммной операционной системы.

**Особая роль памяти**: Процессор может выполнять инструкции программы **только в том случае**, если они находятся в памяти.

**Распределение памяти**:
- Между модулями прикладных программ
- Между модулями самой операционной системы

### Функции ОС по управлению памятью
Операционная система в мультипрограммной среде выполняет следующие функции:
1. **Отслеживание состояния памяти**
   - Учёт свободной памяти
   - Учёт занятой памяти
   - Ведение таблиц распределения

2. **Выделение памяти процессам**
   - Выделение памяти при создании процесса
   - Освобождение памяти при завершении процесса
   - Динамическое изменение выделенной памяти

3. **Вытеснение на диск (свопинг)**
   - Полное или частичное вытеснение кодов и данных на диск
   - Когда размеры оперативной памяти недостаточны
   - Возвращение в оперативную память при освобождении места

4. **Настройка адресов (релокация)**
   - Преобразование виртуальных адресов в физические
   - Настройка программы на конкретную область физической памяти

5. **Защита памяти**
   - Защита процессов от взаимного вмешательства
   - Предотвращение несанкционированного доступа
   - Изоляция адресных пространств

### Типы адресов в жизненном цикле программы
На разных этапах жизненного цикла программы используются **три типа адресов**:
#### 1. Символьные адреса
- **Использование**: на этапе программирования
- **Форма**: имена переменных, меток, функций
- **Пример**: `count`, `main()`, `buffer`
#### 2. Виртуальные адреса
- **Использование**: после компиляции/сборки
- **Форма**: условные числа (логические адреса)
- **Вырабатываются**: компилятором и компоновщиком
- **Диапазон**: от 0 до максимального адреса виртуального пространства
#### 3. Физические адреса
- **Использование**: во время выполнения
- **Форма**: реальные адреса в оперативной памяти
- **Назначаются**: операционной системой при загрузке
### Виртуальное адресное пространство
**Виртуальное адресное пространство процесса** — совокупность виртуальных адресов процесса.
**Характеристики**:
- Диапазон возможных адресов **одинаков для всех процессов**
- Определяется разрядностью адреса (например, 32 бита → 4 ГБ)

**Типы организации**:
1. **Плоское (линейное)** — непрерывная последовательность адресов
2. **Структурированное** — разделено на сегменты

**Важное различие**:
- **Максимально возможное виртуальное пространство**
  - Определяется разрядностью адреса и архитектурой
  - Например: 2³² = 4 ГБ для 32-битной системы

- **Назначенное (выделенное) виртуальное пространство**
  - Набор адресов, действительно нужных процессу
  - Обычно намного меньше максимального
  - Определяется размером программы и данных

**Структура виртуального пространства**:
Виртуальное адресное пространство делится на **две части**:
1. **Системная часть**
   - Общая для всех процессов
   - Содержит коды и данные операционной системы
   - Защищена от доступа пользовательских программ

2. **Пользовательская часть**
   - Уникальна для каждого процесса
   - Содержит код и данные процесса
   - Может изменяться динамически
### Методы управления памятью
**Современный подход**: Виртуальная память является **наиболее эффективным способом** управления памятью.

Виртуальная память **вытеснила** устаревшие методы:
- Распределение фиксированными разделами
- Распределение динамическими разделами
- Распределение перемещаемыми разделами

**Принцип виртуальной памяти**: Использование дисковой памяти для временного хранения не помещающихся в оперативную память данных и кодов выполняемых процессов.
### Классы реализаций виртуальной памяти
#### 1. Страничная виртуальная память
**Принцип**: Перемещение данных между памятью и диском **страницами** — частями фиксированного размера.

**Характеристики страницы**:
- Фиксированный размер (обычно 4 КБ, 8 КБ, 16 КБ)
- Сравнительно небольшой размер
- Механическое разделение без учёта смысла

**Достоинства**:
- ✓ Высокая скорость обмена (малый размер страницы)
- ✓ Низкий уровень фрагментации
- ✓ Простота управления

**Недостатки**:
- ✗ Сложно организовать защиту данных (разделены механически)
- ✗ Не учитывается смысловое значение данных
#### 2. Сегментная виртуальная память
**Принцип**: Перемещение данных **сегментами** — частями произвольного размера, полученными с учётом смыслового значения.

**Характеристики сегмента**:
- Произвольный размер (от нескольких байт до мегабайт)
- Смысловая единица (функция, массив, стек, куча)
- Осмысленное разделение данных

**Достоинства**:
- ✓ «Осмысленность» сегментов упрощает защиту
- ✓ Удобное разделение кода между процессами
- ✓ Естественная структуризация программы

**Недостатки**:
- ✗ Медленное преобразование адреса
- ✗ Высокий уровень фрагментации (сегменты разного размера)
- ✗ Сложность поиска свободного места
#### 3. Сегментно-страничная виртуальная память
**Принцип**: **Комбинация** двух предыдущих подходов.

**Механизм**:
1. Виртуальное пространство делится на **сегменты** (смысловые единицы)
2. Каждый сегмент делится на **страницы** (фиксированного размера)
3. Обмен с диском происходит страницами

**Достоинства**:
- ✓ Сочетает преимущества обоих подходов
- ✓ Смысловая организация (удобная защита)
- ✓ Эффективный обмен (страницами)
- ✓ Низкая фрагментация

**Недостатки**:
- ✗ Сложность реализации
- ✗ Двухуровневое преобразование адресов

**Современное использование**: Большинство современных ОС используют страничную или сегментно-страничную организацию памяти.
### Разделяемые сегменты
**Разделяемые сегменты** — сегменты виртуальной памяти, доступные нескольким процессам одновременно.

**Применение разделяемых сегментов**:
#### 1. Экономия физической памяти
**Ситуация**: Несколько пользователей работают с одним приложением

**Решение**: Кодовый сегмент приложения размещается в памяти **один раз** и используется всеми процессами

**Пример**: 10 пользователей запускают текстовый редактор
- Без разделения: 10 копий кода в памяти
- С разделением: 1 копия кода для всех

#### 2. Средство обмена данными между процессами (IPC)
**Назначение**: Передача данных между процессами через общую память

**Преимущества**:
- Высокая скорость обмена (нет копирования)
- Простота доступа к данным

**Механизм**:
1. Процесс A записывает данные в разделяемый сегмент
2. Процесс B читает данные из того же сегмента
### Кэширование в иерархии памяти
**Принцип кэширования** широко используется для ускорения доступа к данным в вычислительных системах.

**Иерархия запоминающих устройств**:
```
┌──────────────────────────────────┐
│  Регистры процессора (десятки Б) │ ← Самый быстрый
├──────────────────────────────────┤
│  Процессорный кэш (сотни КБ)     │
├──────────────────────────────────┤
│  Оперативная память (ГБ)         │
├──────────────────────────────────┤
│  Дисковая память (сотни ГБ-ТБ)   │ ← Самый медленный
└──────────────────────────────────┘
```

**Организация**:
- **Нижний уровень**: емкая, но относительно медленная дисковая память
- **Средний уровень**: оперативная память
- **Верхний уровень**: сверхоперативная память процессорного кэша

**Принцип работы**: Каждый уровень памяти (кроме нижнего) выполняет роль **кэша по отношению к нижележащему уровню**.

### Структура записи в кэш-памяти (повторение)
Каждая запись в кэш-памяти об элементе данных включает:
1. **Значение элемента данных**
   - Сами данные (содержимое)
   - Размер зависит от размера блока кэша

2. **Адрес в основной памяти**
   - Откуда были скопированы данные
   - Используется для идентификации при поиске

3. **Дополнительная информация**:
   - **Признак модификации (dirty bit)**
     - 0 = данные не изменялись
     - 1 = данные были изменены, требуется запись в основную память
   
   - **Признак действительности (valid bit)**
     - 0 = запись пуста или недействительна
     - 1 = запись содержит действительные данные
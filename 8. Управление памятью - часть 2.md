#Operating_Systems #OS_Memory
## Введение: проблема ограниченности оперативной памяти
### Базовое требование к выполнению программ
**Фундаментальное правило**: чтобы программа могла выполняться, она должна находиться в оперативной памяти. Объем доступной оперативной памяти напрямую ограничивает:
- Число одновременно выполняющихся программ
- Размеры виртуальных адресных пространств процессов
- Общий уровень мультипрограммирования системы

### Зависимость загрузки процессора от количества процессов
Оптимальное количество одновременно выполняемых процессов зависит от типа задач:

| Тип задач                      | Характеристика                                           | Оптимальное количество процессов   |
| ------------------------------ | -------------------------------------------------------- | ---------------------------------- |
| **Вычислительные** (CPU-bound) | Мало операций ввода-вывода, процессор постоянно занят    | 3-5 задач                          |
| **Интерактивные** (I/O-bound)  | Много операций ввода-вывода, процессор часто простаивает | Несколько десятков или сотен задач |

**Важный принцип**: Когда процесс выполняет операции ввода-вывода, он переходит в состояние ожидания, освобождая процессор для других процессов. Чем выше доля времени, проводимого процессами в ожидании I/O, тем больше процессов может одновременно выполняться без простоя процессора.

![[OS 47.png]]
**График зависимости**: Коэффициент загрузки процессора растет с увеличением числа процессов, но темп роста зависит от доли времени ожидания ввода-вывода.

**Практический совет**: Для мониторинга загрузки процессора используйте:
- **Windows**: Диспетчер задач (Task Manager)
- **Linux**: команды `w`, `who`, `top`, `htop`
---

## Свопинг (Swapping)
### Концепция свопинга
**Свопинг** — это метод организации вычислительного процесса, при котором образы некоторых процессов **целиком или частично** временно выгружаются на диск для освобождения оперативной памяти.
### Классификация процессов в мультипрограммном режиме
В мультипрограммной системе процессы находятся в различных состояниях:
1. **Активный процесс** — коды которого в данный момент интерпретируются процессором
2. **Приостановленные процессы** — находятся в ожидании завершения ввода-вывода или освобождения ресурсов
3. **Процессы в состоянии готовности** — стоят в очереди к процессору

### Механизм выгрузки процессов
**Принцип работы**:
Образы неактивных процессов могут быть временно выгружены на диск до следующего цикла активности. При этом:
- ОС «знает» о существовании выгруженного процесса
- Учитывает его при распределении процессорного времени и системных ресурсов
- Хранит метаданные о местоположении процесса на диске

**Последовательность действий при выгрузке (swapping out)**:
1. **Выбор кандидата**: Система определяет процесс для выгрузки (обычно долго неактивный)
2. **Сохранение на диск**: Образ процесса (код, данные, стек) записывается в swap-область
3. **Освобождение памяти**: Оперативная память, занятая процессом, помечается как свободная
4. **Обновление метаданных**: ОС запоминает, где на диске находится образ процесса

**Последовательность действий при загрузке (swapping in)**:
1. **Проверка доступности памяти**: Когда подходит очередь выполнения выгруженного процесса
2. **Освобождение места**: Если свободного места не хватает, выгружается другой процесс
3. **Загрузка с диска**: Образ процесса возвращается в оперативную память
4. **Возобновление выполнения**: Процесс продолжает работу с того момента, где был остановлен

![[OS 48.png]]

---
## Оверлеи (Overlays)
### Концепция оверлеев
**Оверлеи (Overlays)** — это техника ручного управления памятью, при которой программист **явно** разбивает программу на части (модули), которые могут **перекрывать** друг друга в памяти.

**Историческая справка:**
- Использовались в **ранних системах** без виртуальной памяти
- Позволяли выполнять программы **больше** размера физической памяти
- **Ответственность за управление** лежала на программисте

### Принцип работы
**Механизм:**
1. Программа делится на **корневой модуль** (root) и **оверлейные модули** (overlays)
2. **Корневой модуль** всегда находится в памяти
3. **Оверлейные модули** загружаются в **одну и ту же область памяти** по требованию
4. Когда нужен новый модуль, он **замещает** предыдущий модуль в оверлейной области

**Структура:**
```
+-------------------+
| Корневой модуль   | <- Всегда в памяти
+-------------------+
| Оверлейная область| <- Модули загружаются сюда по очереди
|                   |
|  Модуль A или B   |
|     или C         |
+-------------------+
```

**Пример:**
```
Программа состоит из модулей:
- Main (корневой): 50 КБ
- ModuleA: 40 КБ
- ModuleB: 45 КБ  
- ModuleC: 35 КБ

Без оверлеев: нужно 170 КБ памяти

С оверлеями:
- Main всегда в памяти: 50 КБ
- Область для модулей A/B/C: 45 КБ (максимальный размер)
- Итого: 95 КБ памяти
```

### Управление оверлеями
**Ответственность программиста:**
- Программист должен **явно указать**, какие модули являются оверлейными
- Программист должен **управлять загрузкой** модулей
- Требуется тщательное **планирование структуры** программы

**Пример кода (псевдокод):**
```c
main() {
    // Корневой модуль
    initialize();
    
    // Загрузка и выполнение модуля A
    load_overlay("ModuleA");
    execute_module_A();
    
    // Загрузка и выполнение модуля B (замещает A)
    load_overlay("ModuleB");
    execute_module_B();
    
    // Снова модуль A (перезагрузка)
    load_overlay("ModuleA");
    execute_module_A_again();
    
    finalize();
}
```

### Преимущества и недостатки
**Преимущества:**
- Позволяет запускать большие программы на системах с малой памятью
- Программист имеет **полный контроль** над использованием памяти
- Не требуется поддержка виртуальной памяти от ОС

**Недостатки:**
- **Сложность разработки** — программист должен тщательно планировать структуру
- **Ошибки** в управлении оверлеями трудно отлаживать
- **Негибкость** — изменение структуры требует переработки кода
- **Ответственность** полностью на программисте
- **Устаревшая техника** — заменена виртуальной памятью

### Современное применение
**Оверлеи почти не используются** в современных системах:
- Виртуальная память решает те же задачи **автоматически**
- Операционная система берёт на себя управление памятью
- Программисту не нужно беспокоиться о размере программы

**Исключения:**
- Некоторые **встраиваемые системы** без MMU
- **Игровые консоли** старых поколений
- Специализированные системы с **жёсткими ограничениями** памяти
---
## Виртуальная память
### Определение и назначение
**Виртуальная память** — механизм, при котором оперативная память виртуализируется за счет дисковой памяти, что позволяет:
- Повысить уровень мультипрограммирования
- Запускать программы, размер которых превышает объем физической памяти
- Создавать иллюзию большого непрерывного адресного пространства

**Виртуальная память (Virtual Memory)** — это технология управления памятью, которая позволяет программам использовать больше памяти, чем физически доступно в системе, за счёт использования дискового пространства в качестве расширения оперативной памяти.

**Виртуальный ресурс** — ресурс, который пользователю или пользовательской программе представляется обладающим свойствами, которыми он в действительности не обладает.

**Преимущества виртуальной памяти:**
1. **Выполнение больших программ:**
   - Программа может быть больше размера физической памяти
   - Размер виртуального адресного пространства ограничен только разрядностью адреса

2. **Увеличение степени мультипрограммирования:**
   - Одновременно может выполняться больше процессов
   - Каждый процесс использует только часть физической памяти

3. **Упрощение программирования:**
   - Программист не беспокоится об ограничениях физической памяти
   - Не нужно вручную управлять загрузкой/выгрузкой частей программы

4. **Изоляция процессов:**
   - Каждый процесс работает в своём виртуальном адресном пространстве
   - Невозможно случайно обратиться к памяти другого процесса
### Как работает виртуальная память
**С точки зрения программиста**:
- Транслятор использует виртуальные адреса
- Программа компилируется так, как будто имеется однородная оперативная память большого объема
- Программист работает с виртуальным адресным пространством, намного превышающим физическую память

**В действительности**:
- Все коды и данные хранятся на дисках
- При необходимости загружаются в реальную оперативную память
- Работа такой "оперативной памяти" происходит значительно медленнее из-за доступа к диску

![[OS 50.png]]
### Сравнение с оверлеями (историческая справка)

| Характеристика   | Оверлеи                  | Виртуальная память    |
| ---------------- | ------------------------ | --------------------- |
| **Управление**   | Явное, программистом     | Автоматическое, ОС    |
| **Планирование** | При написании программы  | В процессе выполнения |
| **Прозрачность** | Требует модификации кода | Полностью прозрачна   |
| **Гибкость**     | Низкая                   | Высокая               |

**Принципиальное отличие**: При использовании оверлеев разбиение программы на части и планирование их загрузки должны были выполняться **заранее программистом** во время написания программы. Виртуальная память делает это автоматически.

---
## Функции операционной системы при виртуализации памяти
Виртуализация оперативной памяти осуществляется **совокупностью программных модулей ОС и аппаратных схем процессора** и включает решение следующих задач:
### Основные задачи
1. **Размещение данных в запоминающих устройствах разного типа**
   - Часть кодов программы — в оперативной памяти
   - Часть — на диске
   - Решение о размещении принимается динамически

2. **Выбор образов процессов или их частей для перемещения**
   - Определение, какие страницы/сегменты выгрузить из ОП на диск
   - Определение, какие страницы/сегменты загрузить с диска в ОП
   - Использование алгоритмов замещения страниц

3. **Перемещение данных между памятью и диском по мере необходимости**
   - Обработка страничных прерываний (page faults)
   - Управление дисковым пространством (файл подкачки)
   - Оптимизация операций ввода-вывода

4. **Преобразование виртуальных адресов в физические**
   - Использование таблиц страниц
   - Кэширование преобразований (TLB)
   - Аппаратная поддержка MMU (Memory Management Unit)
---
## Два подхода к организации виртуальной памяти
### Свопинг (Swapping)
**Принцип**: Образы процессов выгружаются на диск и возвращаются в оперативную память **целиком**.
**Характеристики**:
- Перемещается весь образ процесса
- Простая реализация
- Большие накладные расходы на ввод-вывод
- Редко используется в современных системах в чистом виде

### Виртуальная память (Virtual Memory)
**Принцип**: Между оперативной памятью и диском перемещаются **части** образов процессов (сегменты, страницы).

**Преимущества**:
- Меньшие накладные расходы на ввод-вывод
- Более эффективное использование памяти
- Загрузка только необходимых частей программы
---
## Классы реализации виртуальной памяти
### 1) Страничная виртуальная память (Paging)
**Определение**: Организует перемещение данных между памятью и диском **страницами** — частями виртуального адресного пространства **фиксированного и сравнительно небольшого размера**.

**Характеристики**:
- Фиксированный размер страниц (обычно 4 КБ)
- Простота управления
- Возможна внутренняя фрагментация
### 2) Сегментная виртуальная память (Segmentation)
**Определение**: Предусматривает перемещение данных **сегментами** — частями виртуального адресного пространства **произвольного размера**, полученными с учетом смыслового значения данных.

**Характеристики**:
- Размер сегмента определяется логикой программы (код, данные, стек)
- Естественное отображение структуры программы
- Возможна внешняя фрагментация
### 3) Сегментно-страничная виртуальная память
**Определение**: Использует **двухуровневое деление**:
1. Виртуальное адресное пространство делится на сегменты
2. Сегменты делятся на страницы

**Единица перемещения**: страница.

**Преимущество**: Объединяет элементы обоих предыдущих подходов — логическую структуру сегментов и эффективность управления страницами.

---
## Страничное распределение памяти
### Основные понятия
**Страничная организация памяти** — наиболее распространённый способ реализации виртуальной памяти в современных операционных системах.

**Основной принцип:**
- Виртуальное адресное пространство каждого процесса делится на **виртуальные страницы** (virtual pages)
- Физическая память делится на **физические страницы** или **кадры** (frames, page frames)
- Размер виртуальной и физической страницы **одинаков**

**Виртуальные страницы (Virtual Pages)** — части виртуального адресного пространства процесса одинакового фиксированного размера.

**Физические страницы (Physical Pages, Page Frames, Blocks)** — части оперативной памяти того же размера, что и виртуальные страницы.

![[OS 51.png]]

### Размер страницы
**Выбор размера страницы:**
- Размер страницы выбирается равным **степени двойки**: 512, 1024, 4096, 8192 байт и т.д.
- Это позволяет упростить механизм преобразования адресов

**Типичные размеры:**
- **4 КБ (4096 байт)** — наиболее распространённый размер в современных системах
- **8 КБ** — используется в некоторых архитектурах
- **2 МБ, 4 МБ, 1 ГБ** — большие страницы (huge pages) для специальных случаев

**Преимущества больших страниц:**
- Меньше записей в таблице страниц
- Меньше промахов TLB (Translation Lookaside Buffer)
- Меньше накладных расходов на управление

**Преимущества малых страниц:**
- Меньше внутренней фрагментации
- Более точное управление памятью
- Меньше неиспользуемой памяти на страницу

### Виртуальные страницы (Virtual Pages)
**Определение:**
- Виртуальное адресное пространство процесса делится на части фиксированного размера
- Каждая часть называется **виртуальной страницей**

**Характеристики:**
- Все виртуальные страницы одинакового размера
- Страницы нумеруются последовательно: 0, 1, 2, 3, ...
- В общем случае размер виртуального адресного пространства **не кратен** размеру страницы
- **Последняя страница** каждого процесса дополняется **фиктивной областью** (padding)

**Пример:**
```
Виртуальное адресное пространство: 17 КБ
Размер страницы: 4 КБ

Страница 0: 0x0000 - 0x0FFF (4 КБ, полностью используется)
Страница 1: 0x1000 - 0x1FFF (4 КБ, полностью используется)
Страница 2: 0x2000 - 0x2FFF (4 КБ, полностью используется)
Страница 3: 0x3000 - 0x3FFF (4 КБ, полностью используется)
Страница 4: 0x4000 - 0x43FF (1 КБ используется, 3 КБ — фиктивная область)
```

### Физические страницы (Physical Pages / Frames)
**Определение:**
- Вся оперативная память делится на части того же размера, что и виртуальные страницы
- Называются **физическими страницами**, **блоками** или **кадрами** (frames)

**Характеристики:**
- Размер физической страницы = размер виртуальной страницы
- Физические страницы нумеруются: 0, 1, 2, ...
- Количество физических страниц = (Размер физической памяти) / (Размер страницы)

**Пример:**
```
Физическая память: 4 ГБ (4 294 967 296 байт)
Размер страницы: 4 КБ (4096 байт)

Количество физических страниц: 4 294 967 296 / 4096 = 1 048 576 страниц
```

### Структура виртуального адреса
При размере страницы 4 КБ = 4096 байт = 2¹²:

```
┌──────────────────────┬─────────────┐
│  Номер страницы      │  Смещение   │
│  (20 бит)            │  (12 бит)   │
└──────────────────────┴─────────────┘
    32-разрядный виртуальный адрес
```

**Пример разбора адреса**:
```
10110001010101010101 | 010001100101
        ↓                    ↓
  Номер страницы: 726357    Смещение: 1125
```

**Расчеты**:
- Для записи смещения в странице 4 КБ нужно **12 бит** (максимальное смещение 4095)
- Остальные биты (32 - 12 = **20 бит**) используются для номера виртуальной страницы
- Это дает 2²⁰ = **1 048 576 страниц** по 4 КБ каждая
- Итого: виртуальное адресное пространство = 2²⁰ × 2¹² = 2³² = **4 ГБ**

![[OS 49.png]]
### Преимущество степеней двойки
Выбор размера страницы равным степени двойки позволяет **упростить механизм преобразования адресов**:
- Младшие биты адреса автоматически дают смещение внутри страницы
- Старшие биты — номер страницы
- Не требуется деление или остаток от деления
### Размер виртуального адресного пространства
**Для 32-битных систем:**
- При размере страницы 4 КБ:
  - 20 бит на номер страницы → 2^20 = 1 048 576 страниц
  - 1 048 576 страниц × 4 КБ = **4 ГБ**

**Для 64-битных систем:**
- При размере страницы 4 КБ:
  - 12 бит на смещение
  - 52 бита на номер страницы (в реальности используется меньше)
  - Теоретически: 2^52 страниц × 4 КБ = **16 ПБ (петабайт)**
- На практике используется 48 бит (256 ТБ виртуального пространства)

### Отображение виртуальных страниц на физические
**Ключевое свойство:**
- **Смежные виртуальные страницы НЕ обязательно располагаются в смежных физических страницах**
- Виртуальная страница может быть загружена в любую свободную физическую страницу

**Пример отображения:**
```
Виртуальные страницы процесса A:
  Виртуальная страница 0 → Физическая страница 5
  Виртуальная страница 1 → Физическая страница 128
  Виртуальная страница 2 → Физическая страница 3
  Виртуальная страница 3 → не загружена (на диске)
  Виртуальная страница 4 → Физическая страница 1024
```

### Пример разбора адреса
**Дано:**
- 32-битная система
- Размер страницы: 4 КБ = 2^12 байт
- Виртуальный адрес: `0xB1555125` (в двоичном виде)

**Двоичное представление:**
```
Адрес: 10110001010101010101 010001100101
       |-------- 20 бит --------|--12 бит--|
       Номер страницы           Смещение
```

**Расшифровка:**
- **Номер страницы:** `10110001010101010101` (двоичное) = `726357` (десятичное)
- **Смещение:** `010001100101` (двоичное) = `1125` (десятичное)

**Интерпретация:**
- Адрес находится в виртуальной странице номер **726357**
- На позиции **1125** от начала этой страницы
---
## Дисковое пространство для виртуальной памяти
### Область свопинга / Страничный файл
Для временного хранения сегментов и страниц на диске отводится:
- **Специальная область диска**, или
- **Специальный файл**

**Традиционные названия**:
- Область/файл свопинга (swap area/file)
- **Страничный файл** (page file, paging file) — наиболее употребимое название

**Примеры**:
- Windows: `pagefile.sys`, `swapfile.sys`
- Linux: swap-раздел или swap-файл

**Файл подкачки** (также называемый **файлом свопинга** или **страничным файлом**) — это специальная область на диске (или отдельный файл), используемая для временного хранения страниц и сегментов, вытесненных из оперативной памяти.
### Размер страничного файла и производительность
**Влияние размера страничного файла**:

| Параметр | Больший размер | Меньший размер |
|----------|----------------|----------------|
| **Уровень мультипрограммирования** | Выше (больше процессов) | Ниже (меньше процессов) |
| **Скорость работы** | Ниже (больше обменов с диском) | Выше (меньше обменов) |
| **Использование диска** | Больше | Меньше |

**Важное понимание**: Увеличение числа одновременно работающих приложений за счет увеличения размера страничного файла **замедляет их работу**, так как значительная часть времени тратится на перекачку кодов и данных между оперативной памятью и диском.

**Компромисс**: Размер страничного файла в современных ОС является **настраиваемым параметром**, который выбирается администратором для достижения баланса между:
- Уровнем мультипрограммирования
- Быстродействием системы

**Рекомендации по настройке**:
- Для серверов с большим количеством процессов: больший файл подкачки
- Для рабочих станций с достаточной ОП: минимальный файл подкачки
- Для систем с SSD: уменьшить размер для продления срока службы диска

---
## Таблица страниц
### Назначение и создание
**Таблица страниц** — это информационная структура данных, которая содержит записи обо всех виртуальных страницах процесса и их отображении на физические страницы.

**Основная задача:**
- Хранить информацию о том, в какой физической странице находится каждая виртуальная страница
- Предоставлять дополнительную информацию о состоянии каждой страницы

**Создание**:
- При создании процесса ОС создает таблицу страниц
- Может быть одна таблица на процесс или общая для всех процессов
- Загружается в оперативную память несколько начальных виртуальных страниц (начальные страницы кодового сегмента и сегмента данных)
- Копия всего виртуального адресного пространства процесса находится на диске

**Важное свойство**: Смежные виртуальные страницы **не обязательно** располагаются в смежных физических страницах.

![[OS 52.png]]
### Хранение таблицы страниц
**Расположение:**
- Таблицы страниц **размещаются в оперативной памяти**
- Адрес таблицы страниц текущего процесса хранится в **специальном регистре процессора** (например, CR3 в x86)

**При переключении контекста:**
- ОС загружает адрес таблицы страниц нового процесса в специальный регистр
- Это автоматически переключает преобразование адресов на новый процесс
### Структура дескриптора страницы
**Дескриптор страницы (Page Table Entry)** — запись в таблице страниц, содержащая информацию об одной виртуальной странице.

**Основные поля дескриптора:**
#### 1. Номер физической страницы (Frame Number)
- Указывает, в какую физическую страницу загружена данная виртуальная страница
- Используется для преобразования виртуального адреса в физический
- Имеет смысл только если страница присутствует в памяти

#### 2. Бит присутствия / Бит валидности (Present Bit / Valid Bit)
- **Установлен в 1 (v — valid):** страница находится в оперативной памяти
- **Установлен в 0 (i — invalid):** страница выгружена на диск или ещё не загружена
- При обращении к странице с битом 0 генерируется **прерывание page fault**

#### 3. Бит модификации (Dirty Bit / Modified Bit)
- **Устанавливается в 1:** при любой записи по адресу, относящемуся к данной странице
- **Значение:**
  - Если бит = 1: страница была изменена и при выгрузке должна быть записана на диск
  - Если бит = 0: страница не изменялась, при выгрузке запись на диск не нужна
- Устанавливается **аппаратно** процессором

#### 4. Бит обращения / Бит доступа (Referenced Bit / Accessed Bit)
- **Устанавливается в 1:** при каждом обращении к странице (чтение или запись)
- **Назначение:** используется алгоритмами замещения страниц для определения "популярности" страницы
- Устанавливается **аппаратно** процессором
- ОС периодически сбрасывает этот бит для отслеживания недавних обращений

#### 5. Дополнительные биты
- **Биты защиты (Protection Bits):**
  - R (Read) — разрешено чтение
  - W (Write) — разрешено запись
  - X (Execute) — разрешено выполнение
- **Бит кэширования (Cache Disable):** отключить кэширование для этой страницы
- **Бит глобальности (Global Bit):** страница общая для всех процессов (например, ядро ОС)

**Примерная структура дескриптора:**
```
| Номер физ. страницы | G | D | A | P | R | W | X |
|     20-40 бит       | 1 | 1 | 1 | 1 | 3 бита    |

G - Global (глобальная страница)
D - Dirty (модифицирована)
A - Accessed (был доступ)
P - Present (присутствует в памяти)
R/W/X - права доступа
```

### Установка битов
**Аппаратная установка:**
- **Бит присутствия (P):** устанавливается ОС при загрузке страницы, сбрасывается при выгрузке
- **Бит модификации (D):** устанавливается **автоматически процессором** при записи в страницу
- **Бит обращения (A):** устанавливается **автоматически процессором** при любом обращении к странице

**Программное управление:**
- ОС может читать и сбрасывать биты обращения и модификации
- ОС использует эту информацию для принятия решений о замещении страниц
---
## Преобразование виртуальных адресов в физические
### Процесс преобразования адреса
**При каждом обращении к памяти** выполняется следующая последовательность действий:
#### Шаг 1: Извлечение номера страницы и смещения
- Виртуальный адрес разбивается на две части:
  - **Номер виртуальной страницы** (старшие биты)
  - **Смещение внутри страницы** (младшие биты)

**Пример:**
```
Виртуальный адрес: 0x00123456 (для 32-бит системы, страница 4 КБ)

Двоичное: 0000 0000 0001 0010 0011 | 0100 0101 0110
          |-------- 20 бит ------| |--- 12 бит ---|
          Номер страницы: 0x123     Смещение: 0x456
```

#### Шаг 2: Обращение к таблице страниц
- По номеру виртуальной страницы находится соответствующий **дескриптор** в таблице страниц
- Из дескриптора извлекается информация о странице

**Адресация в таблице:**
```
Адрес_дескриптора = Базовый_адрес_таблицы + (Номер_страницы × Размер_дескриптора)
```

**Базовый адрес таблицы страниц** хранится в специальном регистре процессора.
**Размер дескриптора** зависит от архитектуры (обычно 4 или 8 байт).
#### Шаг 3: Проверка бита присутствия
**Если бит присутствия = 1 (страница в памяти):**
- Извлекается **номер физической страницы** из дескриптора
- Выполняется преобразование виртуального адреса в физический (переход к шагу 4)

**Если бит присутствия = 0 (страница на диске):**
- Генерируется **прерывание page fault** (страничное прерывание)
- Управление передаётся обработчику page fault (переход к процедуре обработки)

#### Шаг 4: Формирование физического адреса
**Формула:**
```
Физический_адрес = (Номер_физической_страницы × Размер_страницы) + Смещение
```

или в битовом представлении:
```
|  Номер физической страницы  |  Смещение  |
|    (из таблицы страниц)     | (из вирт. адреса) |
```

**Пример:**
```
Виртуальный адрес: 0x00123456
Номер виртуальной страницы: 0x123 (291 десятичное)
Смещение: 0x456 (1110 десятичное)

Из таблицы страниц:
  Виртуальная страница 0x123 → Физическая страница 0x5F8 (1528 десятичное)

Физический адрес = 0x5F8000 + 0x456 = 0x5F8456
```

### Преобразование адресов без кэширования
**Проблема:**
- При каждом обращении к памяти требуется **дополнительное обращение к памяти** для чтения таблицы страниц
- Это **удваивает время доступа** к памяти

**Последовательность обращений:**
```
1. Обращение к таблице страниц (чтение дескриптора) — 1 обращение к памяти
2. Обращение к нужным данным                           — 1 обращение к памяти
---
Итого: 2 обращения к памяти вместо 1
```

**Следствие:**
- Производительность системы снижается примерно вдвое
- Необходимо решение для ускорения преобразования адресов

### Пример преобразования
```
Виртуальный адрес: 0x12345678
Размер страницы: 4 КБ (0x1000)

Разбор:
  Номер страницы: 0x12345678 >> 12 = 0x12345
  Смещение: 0x12345678 & 0xFFF = 0x678

Поиск в таблице страниц:
  Дескриптор[0x12345].ФизическийНомер = 0x89ABC
  Дескриптор[0x12345].Валидность = 1 (в памяти)

Физический адрес:
  0x89ABC × 0x1000 + 0x678 = 0x89ABC678
```
---
## Обработка страничного прерывания (Page Fault)
### Определение
**Page Fault (страничное прерывание)** — это исключение, возникающее при попытке обращения к виртуальной странице, которая в данный момент отсутствует в оперативной памяти.

**Причины возникновения:**
1. Страница ещё не была загружена (первое обращение)
2. Страница была вытеснена на диск для освобождения памяти
3. Неправильная ссылка на адрес (выход за пределы адресного пространства

### Последовательность обработки page fault
#### Шаг 1: Генерация прерывания
- Процессор обнаруживает, что бит присутствия = 0
- Генерируется прерывание (trap/exception)
- Управление передаётся обработчику page fault в ядре ОС

#### Шаг 2: Проверка правильности ссылки
**Операционная система проверяет:**
- Правильна ли ссылка на адрес?
- Не находится ли адрес за пределами виртуального адресного пространства процесса?
- Имеет ли процесс право доступа к этой странице?

**Если ссылка неверна:**
- Процесс завершается аварийно с ошибкой **Segmentation Fault** или **Access Violation**

**Если ссылка верна:**
- Продолжается обработка (переход к шагу 3)

#### Шаг 3: Поиск свободного кадра
**ОС ищет свободную физическую страницу (frame):**
- Если **есть свободные физические страницы:**
  - Выбирается одна из них для загрузки
  - Переход к шагу 5

- Если **нет свободных физических страниц:**
  - Необходимо **выбрать страницу-жертву** для вытеснения (замещения)
  - Переход к шагу 4

#### Шаг 4: Выбор и выгрузка страницы-жертвы (если нет свободных страниц)
**Вытеснение страницы (Page Replacement)**
**Выбор страницы для вытеснения:**
- Используется **алгоритм замещения страниц** (например, LRU, FIFO, Clock)
- Выбирается страница, которая сейчас не используется

**Действия с выбранной страницей:**
1. В таблице страниц процесса-владельца **обнуляется бит присутствия** этой страницы
2. **Проверяется бит модификации:**
   - **Если бит модификации = 1** (страница была изменена):
     - Новая версия страницы **записывается на диск** (в файл подкачки)
   - **Если бит модификации = 0** (страница не изменялась):
     - Запись на диск не производится (на диске уже есть актуальная копия)
3. Физическая страница **объявляется свободной**

**Безопасность:**
- В некоторых системах освобождаемая страница **обнуляется**
- Это предотвращает использование данных выгруженной страницы другими процессами

#### Шаг 5: Загрузка требуемой страницы
**Операционная система:**
1. **Находит на диске** требуемую виртуальную страницу:
   - ОС должна помнить положение вытесненной страницы в файле подкачки
   - Или страница может находиться в исполняемом файле (если ещё не загружалась)
2. **Читает страницу с диска** в выбранную свободную физическую страницу
3. **Обновляет таблицу страниц:**
   - Записывает номер физической страницы в дескриптор
   - Устанавливает **бит присутствия в 1 (v — valid)**
   - Обнуляет бит модификации (страница только что загружена, не изменена)

#### Шаг 6: Возврат к выполнению инструкции
**Завершение обработки:**
- Процесс переводится из состояния ожидания в состояние готовности
- **Инструкция, вызвавшая page fault, выполняется заново** (с самого начала)
- На этот раз обращение происходит успешно, так как страница уже в памяти

**Параллельное выполнение:**
- Пока текущий процесс ожидает загрузки страницы с диска
- **Активизируется другой процесс** из очереди готовых процессов
- Процессор не простаивает

### Диаграмма последовательности обработки Page Fault
```
1. Обращение к виртуальному адресу
        ↓
2. Проверка бита присутствия
        ↓
3. Бит = 0 → Page Fault
        ↓
4. Проверка правильности адреса
        ↓
5. Адрес неверный? → Завершить процесс (Segmentation Fault)
        ↓ (адрес верный)
6. Есть свободная физическая страница?
        ↓ НЕТ
7. Выбрать страницу-жертву (алгоритм замещения)
        ↓
8. Проверить бит модификации
        ↓
9. Если модифицирована → Записать на диск
        ↓
10. Обнулить бит присутствия страницы-жертвы
        ↓ ДА
11. Загрузить требуемую страницу с диска
        ↓
12. Обновить таблицу страниц (установить бит присутствия = 1)
        ↓
13. Повторить инструкцию, вызвавшую Page Fault
        ↓
14. Успешное обращение к памяти
```

![[OS 53.png]]

---
## Загрузка по требованию (Demand Paging)
### Концепция
**Demand Paging (загрузка по требованию)** — стратегия управления виртуальной памятью, при которой страницы загружаются в оперативную память **только тогда, когда на них происходит обращение**.

**Основной принцип:**
- Страницы **не загружаются заранее**
- Страница загружается **только при первом обращении** к ней
- Если к странице не было обращений, она **никогда не будет загружена** в память

### Преимущества Demand Paging
#### 1. Экономия операций ввода-вывода
- Загружаются только необходимые страницы
- Не тратится время на загрузку неиспользуемых частей программы
#### 2. Экономия памяти
- В памяти находятся только активно используемые страницы
- Больше места для других процессов
#### 3. Быстрое время отклика
- Процесс может начать выполняться, как только загружены начальные страницы
- Не нужно ждать загрузки всей программы
#### 4. Поддержка большего числа пользователей
- При фиксированном размере памяти можно запустить больше процессов
- Каждый процесс использует только часть своего виртуального пространства

### Механизм работы
**При запуске процесса:**
1. Создаётся таблица страниц с битами присутствия = 0
2. Загружаются только **минимально необходимые страницы**:
   - Начальная страница кода (с точкой входа)
   - Начальная страница данных
   - Страница стека
3. Процесс начинает выполняться

**При обращении к не загруженной странице:**
1. Генерируется Page Fault
2. Страница загружается с диска
3. Выполнение продолжается

**Если страница не используется:**
- Она **остаётся на диске**
- Не занимает оперативную память
- Не тратится время на её загрузку

### Lazy Swapper
**Lazy Swapper** — компонент ОС, который помещает страницу в память **только при первой ссылке на неё**.

**Терминология:**
- Swapper, работающий со страницами, называется **pager**
- В контексте виртуальной памяти термины "swapping" и "paging" часто взаимозаменяемы

**"Ленивая" загрузка:**
- Страница не загружается, пока на неё не будет ссылки
- Минимизация предварительной загрузки

### Пример эффективности Demand Paging
**Сценарий:**
```
Программа размером: 10 МБ (2560 страниц по 4 КБ)
Реально используется: 2 МБ (512 страниц)

Без Demand Paging:
  - Загружается: 10 МБ
  - Время загрузки: ~1 секунда
  - Память занято: 10 МБ

С Demand Paging:
  - Загружается: 2 МБ (только используемые страницы)
  - Время загрузки: ~0.2 секунды
  - Память занято: 2 МБ
  - Экономия: 8 МБ памяти и 0.8 секунды времени
```
---

## Производительность системы при Demand Paging
### Влияние Page Faults на производительность
**Page Fault Rate (коэффициент страничных прерываний):**
- Обозначается как **p** (0 ≤ p ≤ 1)
- **p = 0:** ни одно обращение к памяти не вызывает page fault
- **p = 1:** каждое обращение к памяти вызывает page fault
- На практике: **p обычно очень мал** (0.001 - 0.01)

### Эффективное время доступа (Effective Access Time - EAT)
**Эффективное время доступа (EAT)** — это среднее время, необходимое для обращения к памяти с учётом возможных page faults.

**Формула:**
```
EAT = (1 - p) × время_доступа_к_памяти + p × время_обработки_page_fault
```

**Компоненты времени:**
- **Время доступа к памяти** — обычно 200 наносекунд (0.2 микросекунды)
- **Время обработки page fault:**
  - Обработка прерывания: ~1-100 микросекунд
  - Чтение страницы с диска: ~8 миллисекунд (8000 микросекунд)
  - Перезапуск инструкции: ~1-100 микросекунд
  - **Итого:** ~8 миллисекунд = 8 000 000 наносекунд

### Пример расчёта эффективного времени доступа
**Дано:**
- Время доступа к памяти = 200 наносекунд (ns)
- Среднее время обслуживания page fault = 8 миллисекунд (ms) = 8 000 000 ns

**Расчёт:**
```
EAT = (1 - p) × 200 + p × 8 000 000
    = 200 - 200p + 8 000 000p
    = 200 + 7 999 800p наносекунд
```

**Если одно обращение из 1000 вызывает page fault (p = 0.001):**
```
EAT = 200 + 7 999 800 × 0.001
    = 200 + 7999.8
    = 8199.8 ns ≈ 8.2 микросекунды
```

**Замедление производительности:**
- Без page faults: 200 ns
- С page faults (p = 0.001): 8200 ns
- **Замедление в ~41 раз!**

**Для приемлемой производительности:**
- Если допустимо замедление не более чем на 10%:
  - 200 × 1.1 = 220 ns
  - 220 = 200 + 7 999 800p
  - 20 = 7 999 800p
  - p ≈ 0.0000025 (одна page fault на 400 000 обращений)

**Вывод:**
- Page faults должны быть **чрезвычайно редкими** для поддержания приемлемой производительности
- Алгоритмы замещения страниц критически важны


---
## Создание процессов и виртуальная память
### Создание процессов с виртуальной памятью
Виртуальная память предоставляет дополнительные возможности при создании процессов:
**1. Copy-on-Write (Копирование при записи):**
- Позволяет процессу-родителю и процессу-потомку совместно использовать страницы памяти
- Копирование происходит только при модификации

**2. Memory Mapped Files (Файлы, отображаемые на память):**
- Файлы могут быть отображены непосредственно в виртуальное адресное пространство
- Операции с файлами выполняются как операции с памятью
--- 
## Copy-on-Write (CoW)
### Проблема создания процессов

При создании дочернего процесса (например, через `fork()` в Unix) традиционно требовалось:
- Скопировать все адресное пространство родительского процесса
- Это медленно и расточительно, особенно если дочерний процесс сразу вызывает `exec()`

### Концепция Copy-on-Write
**Copy-on-Write (CoW)** — оптимизация, позволяющая процессу-родителю и процессу-потомку **использовать одни и те же страницы в памяти** до тех пор, пока какой-то из процессов не начнет модифицировать страницы.

**Основной принцип:**
- При создании процесса-потомка (например, через fork()) **не создаётся полная копия** памяти родителя
- Родитель и потомок **указывают на одни и те же физические страницы**
- Страницы помечаются как **только для чтения** (read-only)
- **Копирование происходит только тогда, когда один из процессов пытается модифицировать страницу**

### Механизм работы Copy-on-Write
#### До модификации страниц
**Состояние после создания процесса:**
1. Процесс-родитель и процесс-потомок созданы
2. **Таблицы страниц обоих процессов указывают на одни и те же физические страницы**
3. Все разделяемые страницы помечаются как **read-only** в обоих процессах
4. Устанавливается специальный **флаг Copy-on-Write** в дескрипторах страниц

**Пример:**
```
Процесс-родитель (PID 100):
  Виртуальная страница 0 → Физическая страница 5 (read-only, CoW)
  Виртуальная страница 1 → Физическая страница 10 (read-only, CoW)
  Виртуальная страница 2 → Физическая страница 15 (read-only, CoW)

Процесс-потомок (PID 101):
  Виртуальная страница 0 → Физическая страница 5 (read-only, CoW)
  Виртуальная страница 1 → Физическая страница 10 (read-only, CoW)
  Виртуальная страница 2 → Физическая страница 15 (read-only, CoW)
```

![[OS 54.png]]

#### При попытке модификации
**Когда процесс пытается записать в разделяемую страницу:**
1. **Генерируется исключение** (page fault с попыткой записи в read-only страницу)
2. ОС обрабатывает исключение:
   - Проверяет флаг Copy-on-Write
   - **Выделяет новую физическую страницу** из пула свободных страниц
   - **Копирует содержимое** разделяемой страницы в новую страницу
   - **Обновляет таблицу страниц** процесса: виртуальная страница теперь указывает на новую физическую страницу
   - Устанавливает права **read-write** для новой страницы
3. Инструкция записи выполняется заново — теперь успешно

**Пример (Процесс 1 модифицировал страницу A):**
```
Процесс-родитель (PID 100):
  Виртуальная страница 0 → Физическая страница 25 (read-write) [новая копия]
  Виртуальная страница 1 → Физическая страница 10 (read-only, CoW)
  Виртуальная страница 2 → Физическая страница 15 (read-only, CoW)

Процесс-потомок (PID 101):
  Виртуальная страница 0 → Физическая страница 5 (read-only, CoW)  [старая версия]
  Виртуальная страница 1 → Физическая страница 10 (read-only, CoW)
  Виртуальная страница 2 → Физическая страница 15 (read-only, CoW)
```

![[OS 55.png]]

### Преимущества Copy-on-Write
**1. Быстрое создание процессов:**
- Не нужно копировать всю память при создании процесса
- fork() выполняется **очень быстро**
- Копирование происходит **постепенно**, по мере необходимости

**2. Экономия памяти:**
- Разделяемые страницы (которые не модифицируются) занимают память **только один раз**
- Особенно эффективно для программ, которые после ork() сразу вызывают xec() (замена образа процесса)

**3. Эффективное использование:**
- Копирование происходит **только для действительно модифицируемых страниц**
- Страницы кода (обычно read-only) никогда не копируются

### Пул свободных страниц
**Zeroed/Free Page Pool:**
- Операционная система поддерживает **пул обнулённых/освобождённых страниц**
- Эти страницы готовы к немедленному использованию
- При Copy-on-Write новые страницы выделяются из этого пула

**Обнуление страниц:**
- Перед помещением в пул освобождённые страницы **обнуляются**
- Это гарантирует, что новый процесс не получит данные предыдущего процесса
- Важно для **безопасности**

### Применение Copy-on-Write
**1. Создание процессов в Unix/Linux:**
- ork() использует CoW для создания дочерних процессов
- Особенно эффективно в сценарии ork() + exec()

**2. Снимки файловых систем:**
- Современные файловые системы (ZFS, Btrfs) используют CoW для создания мгновенных снимков

**3. Контейнеризация:**
- Docker и другие контейнерные технологии используют CoW для эффективного использования образов
---

## Замещение страниц (Page Replacement)
### Необходимость алгоритмов замещения
**Проблема**: Когда все физические страницы заняты, а нужно загрузить новую страницу, необходимо решить, какую страницу выгрузить.

### Алгоритм замещения страниц (Page Replacement Algorithm)
**Определение:**
Алгоритм замещения страниц — это стратегия выбора страницы для выгрузки из памяти на диск, когда необходимо освободить место для новой страницы.

**Основные требования к алгоритму:**
- **Минимизация page faults** — выбирать страницы, которые не будут использоваться
- **Низкие накладные расходы** — сам алгоритм не должен сильно замедлять систему
- **Справедливость** — не дискриминировать определённые процессы

### Влияние на производительность

**Загрузка и выгрузка страниц сильно влияет на производительность системы**:
- Операции с диском в тысячи раз медленнее операций с ОП
- Плохой алгоритм может вызвать "пробуксовку" (thrashing) — постоянные page faults
- Хороший алгоритм минимизирует количество page faults

**Важное наблюдение**: Некоторые страницы могут загружаться в ОП по несколько раз, если алгоритм замещения неэффективен.


### График зависимости загрузки процессора
**Зависимость коэффициента загрузки процессора от:**
1. **Числа одновременно выполняемых процессов**
2. **Доли времени, проводимого процессами в состоянии ожидания ввода-вывода**

**Оптимальная точка:**
```
Загрузка ЦП
    ^
    |         ***
100%|       **   **
    |     **       **
    |   **           ***
    | **                ****
    |*                      ********
    +---------------------------------> Число процессов
         Оптимум        Thrashing
                       (пробуксовка)
```
#### Trashing (пробуксовка)
**Trashing** — состояние системы, при котором из-за частых page faults процессор тратит большую часть времени на обработку page faults вместо выполнения полезной работы.
- Возникает при недостатке физической памяти для текущего набора процессов
- Приводит к значительному снижению производительности
- Решается увеличением объёма физической памяти или оптимизацией алгоритма замещения страниц

![[OS 56.png]]
### Способы уменьшения затрат на замещение
**1. Использование бита модификации (Dirty Bit)**
При вытеснении на диск записываются **только модифицированные страницы**:
- Если dirty bit = 0 → страница не изменилась → на диске актуальная копия → просто освобождаем фрейм
- Если dirty bit = 1 → страница изменилась → нужно записать на диск
- **Экономия**: сокращается количество операций записи на диск

**2. Улучшенная программа обслуживания page fault**
Можно уменьшить затраты, изменив программу так, чтобы она содержала эффективный код выбора страницы для замещения:
- Предсказание будущего использования
- Учет частоты обращений
- Приоритеты страниц

**3. Разделение логической и физической памяти**
Замещение страниц **завершает разделение между физической и виртуальной памятью**:
- Большая **логическая память** может отображаться на меньшую **физическую**
- Программисту доступно адресное пространство, превышающее физическую память
- Прозрачность — программе не нужно знать о замещениях
---

## Политики замещения страниц
### Локальная политика замещения (Local Policy)
**Определение:**
- При замещении страниц процесса выбирается страница-жертва **только из страниц этого же процесса**
- Каждый процесс имеет **фиксированное или динамически изменяемое** количество физических страниц

**Характеристики:**
- Процесс **не влияет** на количество page faults других процессов
- **Изоляция процессов** — каждый процесс работает в своём "пуле" памяти
- Количество страниц может динамически изменяться в зависимости от поведения процесса

**Преимущества:**
- Предсказуемость поведения процессов
- Справедливость — один процесс не может "украсть" память у другого

**Недостатки:**
- Менее эффективное использование памяти
- Процесс может страдать от нехватки памяти, даже если в системе есть свободные страницы

### Глобальная политика замещения (Global Policy)
**Определение:**
- При замещении страницы выбирается страница-жертва **из всех страниц всех процессов** в системе
- Количество страниц, выделенных процессу, **динамически изменяется**

**Характеристики:**
- Процесс может "украсть" страницу у другого процесса
- Количество страниц процесса зависит от его поведения и поведения других процессов
- Более эффективное использование памяти

**Преимущества:**
- Лучшее использование доступной памяти
- Система адаптируется к текущим потребностям процессов

**Недостатки:**
- Один "жадный" процесс может вызвать page faults у других процессов
- Менее предсказуемое поведение
- Возможна пробуксовка (thrashing) системы

**Примеры:**
- **Windows:** использует глобальную политику с приоритетами
- **Linux:** комбинация локальной и глобальной политик

### Сравнение

| Критерий | Локальная | Глобальная |
|----------|-----------|------------|
| **Изоляция** | Высокая | Низкая |
| **Эффективность использования памяти** | Средняя | Высокая |
| **Предсказуемость производительности** | Высокая | Низкая |
| **Сложность реализации** | Низкая | Высокая |
| **Влияние процессов друг на друга** | Нет | Есть |

---
## Memory-Mapped Files (Файлы, отображаемые на память)
**Определение**: Механизм, позволяющий отображать файл или его часть непосредственно на виртуальное адресное пространство процесса.

**Принцип работы**:
- Файл ассоциируется с диапазоном виртуальных адресов
- Обращение к этим адресам вызывает загрузку соответствующей части файла в память
- Изменения в памяти могут автоматически сохраняться в файл

**Преимущества**:
- Упрощение работы с файлами (как с массивами в памяти)
- Эффективность — загружаются только нужные части файла
- Разделение файла между процессами (shared memory через файлы)

**Применение**:
- Чтение больших файлов
- Разделяемые библиотеки
- Межпроцессное взаимодействие

## Основные алгоритмы замещения страниц
### 1. Оптимальный алгоритм (Optimal - OPT)
**Принцип:**
- Вытеснять страницу, которая **не будет использоваться дольше всех** в будущем

**Характеристики:**
- **Теоретически оптимален** — минимизирует количество page faults
- **Невозможен на практике** — требует знания будущих обращений к страницам
- **Используется для сравнения** — как эталон для оценки других алгоритмов

### 2. Алгоритм FIFO (First-In, First-Out)
**Принцип:**
- Вытеснять страницу, которая **находится в памяти дольше всех** (самая "старая")
- Страницы хранятся в **очереди** в порядке загрузки

**Реализация:**
- Простая очередь (queue)
- При загрузке страницы — добавляется в конец очереди
- При необходимости вытеснения — выбирается страница из начала очереди

**Преимущества:**
- **Простота реализации**
- Низкие накладные расходы

**Недостатки:**
- **Аномалия Белади** (Belady's Anomaly) — увеличение числа физических страниц может **увеличить** количество page faults
- Может вытеснять часто используемые страницы

**Пример аномалии Белади:**
```
Последовательность обращений: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

С 3 физическими страницами: 9 page faults
С 4 физическими страницами: 10 page faults (больше!)
```

### 3. Алгоритм LRU (Least Recently Used)
**Принцип:**
- Вытеснять страницу, к которой **дольше всего не было обращений**
- Предположение: если страница давно не использовалась, она вряд ли понадобится в ближайшее время

**Реализация:**
- Для каждой страницы хранится **время последнего обращения**
- При замещении выбирается страница с самым ранним временем обращения

**Преимущества:**
- **Хорошая производительность** на практике
- Приближается к оптимальному алгоритму
- Не подвержен аномалии Белади

**Недостатки:**
- **Сложность реализации** — требуется отслеживать время обращения к каждой странице
- **Накладные расходы** — обновление информации при каждом обращении
- Аппаратная поддержка желательна, но дорога

**Аппроксимации LRU:**
- **NFU (Not Frequently Used)** — подсчёт числа обращений
- **Aging** — затухание счётчиков со временем

### 4. Алгоритм Second Chance (Вторая возможность)
**Принцип:**
- Модификация FIFO с использованием **бита обращения** (reference bit)
- Страницам даётся "вторая возможность" перед вытеснением

**Механизм:**
1. Страницы хранятся в циклической очереди (как в FIFO)
2. При выборе страницы-жертвы:
   - Если **бит обращения = 0**: страница вытесняется
   - Если **бит обращения = 1**: 
     - Бит сбрасывается в 0
     - Страница перемещается в конец очереди (получает "вторую возможность")
     - Проверяется следующая страница

**Преимущества:**
- Проще, чем LRU
- Лучше, чем простой FIFO
- Использует аппаратный бит обращения

**Недостатки:**
- В худшем случае вырождается в FIFO

### 5. Алгоритм Clock (Часы)
**Принцип:**
- Вариация алгоритма Second Chance
- Страницы организованы в **циклический список** (как стрелка часов)

**Механизм:**
1. "Стрелка часов" указывает на текущую страницу
2. При необходимости замещения:
   - Проверяется бит обращения текущей страницы
   - Если **бит = 0**: страница вытесняется, стрелка переходит к следующей
   - Если **бит = 1**: бит сбрасывается, стрелка переходит к следующей
3. Цикл повторяется до нахождения страницы с битом = 0

**Преимущества:**
- Эффективная реализация Second Chance
- Не требует перемещения страниц в списке
- Широко используется на практике

### 6. Расширенный алгоритм Clock (Enhanced Clock)
**Принцип:**
- Использует **два бита**: бит обращения (R) и бит модификации (D)
- Приоритет вытеснения зависит от комбинации битов

**Классы страниц (в порядке приоритета вытеснения):**
1. **(R=0, D=0)** — не использовалась, не модифицирована — **лучший выбор**
2. **(R=0, D=1)** — не использовалась, но модифицирована — нужна запись на диск
3. **(R=1, D=0)** — использовалась недавно, не модифицирована
4. **(R=1, D=1)** — использовалась недавно, модифицирована — **худший выбор**

**Алгоритм:**
- Первый проход: ищем страницу класса 1
- Второй проход (если не нашли): сбрасываем биты R, ищем класс 2
- Третий проход: ищем классы 3-4

**Преимущества:**
- Учитывает стоимость записи модифицированных страниц на диск
- Более эффективен, чем простой Clock

---
## Опережающая подкачка (Pre-paging)
### Концепция
**Опережающая подкачка (Pre-paging)** — стратегия управления виртуальной памятью, при которой система **заранее загружает страницы в память**, ожидая, что они скоро понадобятся.
### Цель
- Снизить количество page faults при выполнении программы
- Улучшить производительность за счёт предсказания будущих обращений к страниц
### Механизм работы
1. При загрузке процесса или при обработке page fault система анализирует **паттерны доступа к памяти**
2. На основе анализа **предсказываются страницы**, которые могут понадобиться в ближайшее время
3. Эти страницы **загружаются в память заранее**, вместе с запрашиваемой страницей
### Преимущества
- Снижение количества page faults
- Улучшение времени отклика процессов
### Недостатки
- Риск загрузки ненужных страниц (избыточная подкачка)
- Увеличение нагрузки на диск и память
### Применение
- Используется в современных операционных системах для оптимизации работы с виртуальной памятью
- Особенно полезна для программ с предсказуемыми паттернами доступа к памяти (например, последовательный доступ к файлам)

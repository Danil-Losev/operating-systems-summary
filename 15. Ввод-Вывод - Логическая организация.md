#Operating_Systems #OS_Input_Output
## Введение: Добавление нового устройства
### Физические требования для подключения устройства
При подключении нового устройства ввода-вывода к существующему компьютеру на **аппаратном уровне** необходимо выполнить следующие действия:

1. **Отобразить порты устройства** в соответствующее адресное пространство
2. **Определить номер прерывания**, которое будет генерироваться устройством
3. **Закрепить за устройством канал DMA** (если требуется)

**Результат:** После выполнения этих действий hardware будет функционировать корректно.

### Проблема программного обеспечения
Однако **только аппаратной настройки недостаточно**. Возникают важные вопросы:

- Как должна быть **построена подсистема управления вводом-выводом** в операционной системе?
- Как обеспечить **легкое и безболезненное добавление новых устройств**?
- Какие **функции возлагаются** на подсистему ввода-вывода ОС?
---
## Физический и программный интерфейсы
### Физический интерфейс (Hardware Interface)
**Достижение в области технического обеспечения:**

В области hardware удалось создать **единый интерфейс** для подключения внешних устройств:

- Выделены **несколько основных принципов взаимодействия** внешних устройств с вычислительной системой
- **Все специфические действия** возложены на контроллеры самих устройств
- Устройства должны **придерживаться определённого стандарта**

**Результат:** Конструкторы вычислительных систем переложили задачу обеспечения совместимости на разработчиков аппаратуры.

### Программный интерфейс (Software Interface)
**Аналогичный подход на уровне ПО:**

Подобно физическому интерфейсу, можно создать **унифицированный программный интерфейс**:
#### Классификация устройств по типам
Устройства делятся на **относительно небольшое число типов**, различающихся по:
- **Набору операций**, которые могут быть выполнены
- Все остальные различия считаются **несущественными**
#### Спецификация интерфейсов
Для каждого типа устройств определяется **интерфейс** между:
- **Ядром ОС** (осуществляющим общую политику ввода-вывода)
- **Драйверами устройств** (программными частями, непосредственно управляющими устройствами)

#### Преимущества подхода
**Для разработчиков ОС:**
- Освобождение от написания специфических программных частей (драйверов)
- Освобождение от тестирования драйверов
- Возможность передать эту деятельность **производителям внешних устройств**

**Архитектурный принцип:**
> Использование принципа **уровневого (слоёного) построения** системы управления вводом-выводом

---
## Драйверы устройств
### Что такое драйвер?
**Драйвер** — специализированная программная часть, непосредственно управляющая конкретным внешним устройством или классом устройств.

**Внешние устройства по отношению к процессору** - это:
- **Периферийные устройства**, подключаемые через шину ввода-вывода
- **Контроллеры устройств**, управляющие периферийными устройствами и взаимодействующие с процессором через шину ввода-вывода
- **Внутренние устройства**, такие как кэш-память, оперативная память и т.д.
- **Специальные процессоры**, такие как графические процессоры (GPU), цифровые сигнальные процессоры (DSP) и т.д.

### Функции драйверов
Драйвер устройства выполняет следующие основные функции:
1. **Обработка запросов записи-чтения**
   - Приём запросов от программного обеспечения управления устройствами
   - Постановка запросов в очередь

2. **Проверка и валидация**
   - Проверка входных параметров запросов
   - Обработка ошибок

3. **Инициализация и мониторинг**
   - Инициализация устройства
   - Проверка статуса устройства

4. **Управление энергопотреблением**
   - Управление энергопотреблением устройства

5. **Регистрация событий**
   - Регистрация событий в устройстве

6. **Выполнение команд**
   - Выдача команд устройству
   - Ожидание их выполнения (возможно, в блокированном состоянии)
   - Ожидание прерывания от устройства

7. **Проверка завершения**
   - Проверка правильности завершения операции
   - Передача запрошенных данных
   - Передача статуса завершённой операции

8. **Реентерабельность (для продвинутых драйверов)**
   - Обработка нового запроса при незавершённом предыдущем запросе
---
## Иерархическая структура подсистемы ввода-вывода
### Необходимость иерархической модели
При большом разнообразии устройств ввода-вывода с существенно различными характеристиками, **иерархическая структура** позволяет соблюсти баланс между двумя противоречивыми требованиями:

**С одной стороны:**
- Необходимо **учесть все особенности** каждого устройства

**С другой стороны:**
- Необходимо **обеспечить единое логическое представление** и унифицированный интерфейс для устройств всех типов

### Принцип построения слоёв
#### Нижние слои
**Нижние слои** подсистемы ввода-вывода должны:
- Включать **индивидуальные драйверы**, написанные для конкретных физических устройств
- Учитывать специфику каждого устройства

#### Верхние слои
**Верхние слои** должны:
- **Обобщать процедуры управления** устройствами
- Предоставлять **общий интерфейс** для групп устройств с общими характеристиками

**Примеры группировки устройств:**
- Принтеры определённого производителя
- Все матричные принтеры
- Все сетевые адаптеры
- Все дисковые накопители

![[OS 83.png]]

### Горизонтальные и вертикальные подсистемы
![[OS 90.png]]
#### Вертикальное деление
Программное обеспечение подсистемы ввода-вывода делится на **вертикальные  подсистемы**, например:
1. **Подсистема управления дисками**
2. **Подсистема управления графическими устройствами**
3. **Подсистема управления сетевыми адаптерами**
4. **Подсистема управления текстовыми терминалами**
5. **Подсистема управления специализированными устройствами**
   - Аналого-цифровые преобразователи (АЦП)
   - Цифро-аналоговые преобразователи (ЦАП)

#### Горизонтальное деление (слои в каждой подсистеме)
В каждой вертикальной подсистеме присутствует **несколько слоёв модулей**:
##### Нижний слой — Аппаратные драйверы
**Функции:**
- Управление аппаратурой внешних устройств
- Обмен байтами и блоками байтов
- **НЕ занимается** вопросами логической организации данных (файлы, графические объекты)

##### Вышележащие слои
**Функции зависят от типа подсистемы:**
- Логическая организация данных
- Работа с файловыми системами (для дисковой подсистемы)
- Работа со сложными графическими объектами (для графической подсистемы)
- Сетевые протоколы (для сетевой подсистемы)
---
## Менеджер ввода-вывода (I/O Manager)
### Определение
**Менеджер ввода-вывода** — центральный компонент подсистемы ввода-вывода, обеспечивающий координацию и взаимодействие между различными модулями и драйверами.
### Назначение менеджера ввода-вывода
**Менеджер ввода-вывода** — модули универсального назначения, которые:
- Организуют **согласованную работу** всех компонентов подсистемы ввода-вывода
- Обеспечивают **взаимодействие** с пользовательскими процессами
- Обеспечивают **взаимодействие** с другими подсистемами ОС

Эти функции **распределяются по всем уровням**, образуя **оболочку**, называемую менеджером ввода-вывода.

### Структура менеджера ввода-вывода
#### Верхний слой менеджера
**Системные вызовы ввода-вывода:**

**Функции:**
1. **Приём запросов** на ввод-вывод от пользовательских процессов
2. **Переадресация запросов** отвечающим за определённый класс устройств модулям и драйверам
3. **Возврат результатов** операций ввода-вывода процессам

**Цель:**
> Поддержка **пользовательского интерфейса** ввода-вывода, создавая для прикладных программистов максимум удобств по манипулированию внешними устройствами и данными.

#### Нижний слой менеджера
**Взаимодействие с контроллерами:**

**Функции:**
1. **Реализация непосредственного взаимодействия** с контроллерами внешних устройств
2. **Экранирование драйверов** от особенностей аппаратной платформы:
   - Шины ввода-вывода
   - Системы прерываний
   - Другие аппаратные особенности

**Механизм работы:**
1. Драйвер отправляет запрос на обмен данными с регистрами контроллера в **обобщённой форме**
2. Используется **независимая от шины** адресация и формат
3. Менеджер **преобразует запросы** в зависящий от аппаратной платформы формат

### Диспетчер прерываний
**Диспетчер прерываний** может:
- **Входить в состав** менеджера ввода-вывода, ИЛИ
- Представлять **отдельный модуль ядра**

**При отдельной реализации:**
- Менеджер ввода-вывода выполняет **первичную обработку** запросов прерываний
- Передаёт диспетчеру **обобщённые сведения** об источнике запроса

### Функции менеджера ввода-вывода
#### 1. Создание стандартной среды взаимодействия
**Создание внутреннего интерфейса:**
- Создание **стандартного внутреннего интерфейса** взаимодействия модулей ввода-вывода между собой
- **Облегчение включения** новых драйверов и файловых систем в состав ОС

**Преимущества для разработчиков:**
- Освобождение от написания **общих процедур**:
  - Буферизация данных
  - Синхронизация нескольких модулей при обмене данными
- Все эти функции берёт на себя **менеджер ввода-вывода**

#### 2. Взаимодействие с другими подсистемами ОС
Менеджер ввода-вывода организует взаимодействие модулей ввода-вывода с:
- Подсистемой **управления процессами**
- Подсистемой **виртуальной памяти**
- Другими подсистемами ОС

---
## Типы устройств и их интерфейсы
### Символьные устройства (Character Devices)
#### Определение
**Символьные устройства** — устройства, которые умеют передавать данные **только последовательно, байт за байтом**.

#### Примеры символьных устройств
**Устройства ввода** (генерируют данные спонтанно, непредсказуемо для системы):
- Клавиатура
- Мышь
- Модем
- Джойстик

**Устройства вывода** (характерно линейное представление данных):
- Принтеры
- Звуковые карты
- Последовательные порты

#### Основные операции
По своей природе символьные устройства обычно умеют совершать **две общие операции**:
- **get** — ввести символ (байт)
- **put** — вывести символ (байт)

### Блочные устройства (Block Devices)
#### Определение
**Блочные устройства** — устройства, которые могут передавать **блок байтов как единое целое**
#### Примеры блочных устройств
- Магнитные диски (HDD)
- Твердотельные накопители (SSD)
- Оптические диски (CD, DVD, Blu-ray)
- Магнитные ленты

#### Основные операции
Для блочных устройств естественными являются операции:
1. **read** — чтение блока информации
2. **write** — запись блока информации
3. **seek** — поиск требуемого блока информации (для устройств прямого доступа)

### Интерфейс драйверов
#### Общие функции для всех драйверов
**Базовые операции:**
- **read** — чтение (для блочных устройств)
- **write** — запись (для блочных устройств)
- **seek** — позиционирование (для блочных устройств)
- **get** — ввод байта (для символьных устройств)
- **put** — вывод байта (для символьных устройств)

#### Специальные функции
**ioctl (input-output control)**
- Функция для передачи драйверу **произвольной команды** с **произвольными параметрами**
- Позволяет задействовать любую возможность драйвера **без изменения интерфейса**
- Название происходит из UNIX

**Примеры специфических операций:**
- Звуковые карты: увеличение/уменьшение громкости
- Дисплеи: изменение разрешающей способности
- Сетевые карты: настройка параметров сети

#### Дополнительные функции интерфейса
**open (инициализация)**
- Функция инициализации или повторной инициализации работы драйвера и устройства

**close (завершение)**
- Функция временного завершения работы с устройством
- Может вызывать отключение устройства

**poll (опрос)**
- Функция опроса состояния устройства
- Используется, если работа с устройством производится методом опроса состояния
- Пример: в Windows NT и Windows 9x так построена работа с принтерами через параллельный порт

**halt (останов)**
- Функция останова драйвера
- Вызывается при останове операционной системы или выгрузке драйвера из памяти

> **Примечание:** Приведённые названия функций являются условными и могут меняться от одной ОС к другой, но выполняемые действия характерны для большинства операционных систем.

---
## Базовая подсистема ввода-вывода
### Роль базовой подсистемы
**Базовая подсистема ввода-вывода** служит **посредником** между:
- Процессами вычислительной системы
- Набором драйверов устройств

**Механизм работы:**
Системные вызовы для выполнения операций ввода-вывода **трансформируются** в вызовы функций необходимого драйвера устройства.

### Услуги, предоставляемые базовой подсистемой
1. **Поддержка различных типов системных вызовов:**
   - Блокирующиеся системные вызовы
   - Неблокирующиеся системные вызовы
   - Асинхронные системные вызовы

2. **Управление данными:**
   - Буферизация входных и выходных данных
   - Кэширование данных

3. **Управление доступом к устройствам:**
   - Spooling (очереди печати)
   - Монопольный захват внешних устройств

4. **Обработка событий:**
   - Обработка ошибок при операциях ввода-вывода
   - Обработка прерываний

5. **Планирование:**
   - Планирование последовательности запросов на выполнение операций

**Spooling** — механизм, при котором данные для вывода на внешнее устройство накапливаются в буфере (обычно на диске) и выводятся на устройство по мере его готовности.

---
## Синхронность и асинхронность операций ввода-вывода

![[OS 92.png]]
### Блокирующиеся системные вызовы (Blocking System Calls)
#### Механизм работы
**При применении блокирующегося вызова:**
1. Процесс переводится из состояния **исполнение** в состояние **ожидание**
2. Процесс блокируется до завершения операции ввода-вывода
3. После завершения операции ОС переводит процесс из состояния **ожидание** в состояние **готовность**
4. После выбора процесса для исполнения происходит окончательный возврат из системного вызова

#### Типичный случай применения
**Когда использовать:**
- Процессу требуется получить от устройства **строго определённое количество данных**
- Без этих данных процесс **не может выполнять работу** далее

**Пример:**
Чтение конфигурационного файла при запуске программы — без этих данных программа не может продолжить работу.

### Неблокирующиеся системные вызовы (Non-blocking System Calls)
#### Простой вариант
**Процесс НЕ переводится в состояние ожидание:**
- Системный вызов возвращается **немедленно**
- Операции ввода-вывода выполняются:
  - **Полностью**, ИЛИ
  - **Частично**, ИЛИ
  - **Не выполняются совсем**
- Зависит от **текущей ситуации** (состояния устройства, наличия данных)

#### Сложный вариант
**Процесс может блокироваться, но:**
- Условием разблокирования является **завершение операций** ИЛИ **окончание промежутка времени** (timeout)

#### Типичный случай применения
**Когда использовать:**
- Периодическая проверка на поступление информации
- Одновременно с выполнением других задач

**Пример:**
Периодическая проверка на поступление информации с клавиатуры при выполнении трудоёмких расчётов.

### Асинхронные системные вызовы (Asynchronous System Calls)
#### Механизм работы
**Процесс никогда не блокируется:**
1. Системный вызов **инициирует** выполнение операций ввода-вывода
2. Вызов **немедленно возвращается**
3. Процесс **продолжает выполнять** свою регулярную деятельность
4. Об окончании операции ОС информирует процесс:
   - Изменением значений переменных, ИЛИ
   - Передачей сигнала, ИЛИ
   - Передачей сообщения, ИЛИ
   - Другим способом

#### Разница между неблокирующимися и асинхронными вызовами
> **Важно понимать разницу:**

**Неблокирующийся вызов для операции read:**
- Вернётся немедленно
- Может прочитать:
  - Запрошенное количество байт, ИЛИ
  - Меньшее количество, ИЛИ
  - Вообще ничего

**Асинхронный вызов для операции read:**
- Также вернётся немедленно
- Но **требуемое количество байт** рано или поздно будет прочитано **в полном объёме**
---
## Буферизация данных
### Определение буфера
**Буфер** — область памяти для запоминания информации при обмене данными между:
- Двумя устройствами
- Двумя процессами
- Процессом и устройством

### Причины использования буферов
#### Причина 1: Разные скорости передачи данных
**Проблема:**
Участники обмена обладают разными скоростями приёма и передачи информации.

**Пример: Передача данных от клавиатуры на модем**
- **Скорость клавиатуры:** определяется скоростью набора текста человеком (обычно очень низкая)
- **Скорость модема:** существенно выше скорости ввода с клавиатуры

**Решение:**
1. Накапливать введённую информацию в буфере (или нескольких буферах)
2. Отсылать данные через модем **после заполнения буферов**
3. Модем не занят на всё время набора текста и остаётся **доступным для других процессов**

#### Причина 2: Разные объёмы данных
**Проблема:**
Участники обмена могут принимать или передавать разные объёмы данных единовременно.

**Пример: Приём данных с модема и запись на жёсткий диск**
- **Модем:** символьное устройство, выдаёт данные **байт за байтом**
- **Жёсткий диск:** блочное устройство, требует накопления **необходимого блока данных**

**Решение с несколькими буферами:**
1. Модем заполняет **первый буфер**
2. После заполнения первого буфера:
   - Модем начинает заполнять **второй буфер**
   - **Одновременно** первый буфер записывается на диск
3. Скорость диска в тысячи раз больше скорости модема
4. К моменту заполнения второго буфера запись первого уже завершена
5. Модем снова заполняет первый буфер, второй записывается на диск

**Результат:** Непрерывная работа без простоев.

#### Причина 3: Копирование из адресного пространства процесса
**Проблема:**
Необходимость копирования информации из приложений в буферы ядра ОС и обратно.

**Сценарий:**
1. Пользовательский процесс хочет вывести данные из своего адресного пространства на внешнее устройство
2. Процесс выполняет системный вызов **write**, передавая:
   - Адрес области памяти с данными
   - Объём данных
3. **Проблема:** Если устройство временно занято, к моменту его освобождения содержимое области может быть испорчено
   - Особенно при использовании **асинхронной формы** системного вызова

**Решение:**
1. В начале работы системного вызова **откопировать** данные в буфер ядра ОС
2. Буфер ядра **постоянно находится** в оперативной памяти
3. Выводить данные на устройство **из этого буфера**

**Результат:** Гарантия целостности данных.

### Варианты буферизации
![[OS 93.png]]

**Типы буферных схем:**
1. **Без буферизации** — прямая передача данных
2. **Одиночная буферизация** — один буфер между источником и приёмником
3. **Двойная буферизация** — два буфера, работающие попеременно
4. **Кольцевая буферизация** — набор буферов, организованных в кольцо
5. **Буферный пул** — множество буферов, управляемых динамически

---
## Кэширование
### Определение кэша
**Кэш (cache — "наличные")** — область быстрой памяти, содержащая **копию данных**, расположенных в более медленной памяти, предназначенная для **ускорения работы** вычислительной системы.

### Различие между буферизацией и кэшированием
> **Важно не смешивать понятия:**

**Буфер:**
- Часто содержит **единственный набор данных**, существующий в системе
- Данные находятся **только в буфере**

**Кэш:**
- По определению содержит **копию данных**, существующих **где-нибудь ещё**
- Данные дублируются

**Совмещение функций:**
Одна и та же область памяти может использоваться и как буфер, и как кэш.

**Пример:**
Буфер для копирования данных из пользовательского пространства при выводе на диск может использоваться как **кэш** для этих данных, если:
- Операции **модификации** выполняются достаточно часто
- Операции **повторного чтения** этого блока выполняются достаточно часто

### Распределение функций
**Функции буферизации и кэширования** не обязательно локализованы в базовой подсистеме ввода-вывода.

Они могут быть реализованы:
- **В драйверах** устройств
- **В контроллерах** устройств (скрытно по отношению к базовой подсистеме)
- На **аппаратном уровне** (например, кэш контроллера диска)
---
## Спулинг и захват устройств
### Спулинг (Spooling)
#### Определение
**Spool** — буфер, который содержит входные или выходные данные для устройства, на котором следует **избегать чередования его использования** (interleaving) различными процессами.

**В современных системах:**
Spool практически **не используется для ввода данных**, а в основном предназначен для накопления **выходной информации**.

#### Пример: Спулинг для принтера
**Проблема:**
Принтер **не может печатать** информацию, поступающую одновременно от нескольких процессов. Однако может быть **желательно** разрешить процессам совершать вывод на принтер **параллельно**.

**Решение через spooling:**
1. ОС **не передаёт информацию напрямую** на принтер
2. Вместо этого ОС **накапливает выводимые данные** в буферах на диске
3. Буферы организованы в виде **отдельного spool-файла** для каждого процесса
4. После завершения процесса соответствующий spool-файл **ставится в очередь** для реальной печати
5. **Диспетчер печати** (spooler) последовательно обрабатывает очередь

**Преимущества:**
- Процессы не ждут освобождения принтера
- Процессы могут быстро "вывести" данные на принтер (фактически — в файл)
- Избегается чередование вывода от разных процессов

### Захват устройств (Device Reservation)
#### Механизм монопольного захвата
**Альтернатива spooling'у:**
В некоторых ОС вместо spooling'а применяется механизм **монопольного захвата устройств** процессами.

#### Как работает захват
**Если устройство свободно:**
- Один из процессов может получить его в **монопольное распоряжение**

**Все другие процессы:**
- При попытке осуществления операций над этим устройством будут:
  - **Блокированы** (переведены в состояние ожидание), ИЛИ
  - Получат **информацию о невозможности** выполнения операции

**Освобождение устройства:**
- Процесс, захвативший устройство, **завершается**, ИЛИ
- Процесс **явно сообщает** ОС о своём отказе от использования устройства

#### Обеспечение механизмов
Обеспечение **spooling'а** и **механизма захвата устройств** является прерогативой **базовой подсистемы ввода-вывода**.

---
## Обработка прерываний и ошибок
### Механизм обработки прерываний
**Если система использует прерывания** (не метод опроса):
При возникновении прерывания:
1. Процессор **частично сохраняет** своё состояние
2. Процессор **передаёт управление** специальной программе обработки прерывания

### Последовательность действий при прерывании
1. **Сохранение контекста**
2. **Обработка прерывания**
3. **Планирование использования процессора**
4. **Восстановление контекста**

### Процедура обработки прерывания
#### Шаг 1: Определение источника прерывания
**Проблема:**
Одна и та же процедура обработки прерывания может использоваться для **нескольких устройств** ввода-вывода (например, если устройства используют одну линию прерываний).

**Действие:**
Первое действие программы обработки — **определение устройства**, которое выдало прерывание.

**Результат:**
Зная устройство, можно **выявить процесс**, который инициировал выполнение соответствующей операции.

#### Шаг 2: Проверка успешности операции
**Прерывание возникает:**
- При **удачном** завершении операции
- При **неудачном** завершении операции

**Действие:**
Определить успешность завершения операции, проверив значение **бита ошибки** в регистре состояния устройства.

#### Шаг 3: Компенсация ошибок
**Возможные действия ОС:**
В некоторых случаях ОС может предпринять действия, направленные на **компенсацию возникшей ошибки**.

**Пример:**
При ошибке чтения с гибкого диска можно попробовать **несколько раз повторить** выполнение команды.

**Если компенсация невозможна:**
ОС впоследствии **известит об этом процесс**, запросивший выполнение операции (например, специальным кодом возврата из системного вызова).

#### Шаг 4: Разблокировка процесса
**Если процесс был заблокирован:**
ОС переводит его в состояние **готовность**.

#### Шаг 5: Обработка следующих запросов
**При наличии других запросов** к освободившемуся устройству:
1. ОС может **инициировать выполнение** следующего запроса
2. Одновременно **известить устройство**, что прерывание обработано

#### Шаг 6: Планирование процессора
На этом собственно обработка прерывания заканчивается, и система может приступать к **планированию использования процессора**.

**Планирование** может привести к переключению контекста на другой процесс.

### Функция обработки прерывания в драйвере
**Делегирование обработки драйверу:**

Действия по обработке прерывания и компенсации ошибок могут быть **частично переложены** на драйвер.

**Для этого** в интерфейс между драйвером и базовой подсистемой добавляют функцию:
- **intr** — функция обработки прерывания

---
## Планирование запросов на ввод-вывод
### Необходимость очередей запросов
#### Ситуация с неблокирующимся вызовом
**При использовании неблокирующегося системного вызова:**
Может оказаться, что требуемое устройство **уже занято** выполнением операций.

**Результат:**
Неблокирующийся вызов может **немедленно вернуться**, не выполнив запрошенных команд.

#### Ситуация с блокирующимся или асинхронным вызовом
**Занятость устройства** приводит к необходимости **постановки запроса в очередь** к данному устройству.

**Результат:**
С каждым устройством оказывается связан **список неудовлетворённых запросов**:
- Запросы от процессов, находящихся в **состоянии ожидания**
- Запросы, выполняющиеся в **асинхронном режиме**

### Очереди процессов
**Состояние ожидание** расщепляется на **набор очередей** процессов, ожидающих:
- Различных устройств ввода-вывода
- Изменения состояний различных объектов:
  - Семафоров
  - Очередей сообщений
  - Условных переменных в мониторах

### Выбор следующего запроса для обслуживания
**После завершения текущего запроса:**
ОС (по ходу обработки возникшего прерывания) должна:
1. **Решить**, какой из запросов в списке должен быть удовлетворён следующим
2. **Инициировать** его исполнение

**Аналогия:**
Подобно краткосрочному планированию процессов, необходимо осуществлять **планирование использования устройств**, пользуясь определённым алгоритмом.

**Критерии и цели** такого планирования мало отличаются от критериев планирования процессов:
- Минимизация среднего времени ожидания
- Справедливость обслуживания
- Предотвращение голодания (starvation)
- Максимизация пропускной способности

### Распределение ответственности за планирование
#### Общий случай
Задача планирования использования устройства обычно возлагается на **базовую подсистему ввода-вывода**.

#### Специфичное планирование
Для **некоторых устройств** лучшие алгоритмы планирования могут быть **тесно связаны с деталями** их внутреннего функционирования.

**В таких случаях:**
Операция планирования **переносится внутрь драйвера** соответствующего устройства, так как детали функционирования **скрыты** от базовой подсистемы.

**Для этого** в интерфейс драйвера добавляется функция:
- **strategy** — функция выбора очередного запроса

---
## Алгоритмы планирования запросов к жёсткому диску
### Особенности планирования для дисков
Жёсткий диск — устройство, для которого планирование запросов особенно важно из-за:
- **Механической природы** позиционирования головок
- **Значительного времени** поиска (seek time)
- Возможности **оптимизации** порядка обслуживания запросов

### Компоненты времени доступа к диску
**Общее время доступа** складывается из:
1. **Seek time** — время перемещения головок к нужному цилиндру
2. **Rotational latency** — время ожидания вращения диска до нужного сектора
3. **Transfer time** — время передачи данных

**Оптимизация** в основном направлена на минимизацию **seek time**.

### Алгоритм FCFS (First Come First Served)
#### Описание
**Первым пришёл — первым обслужен**
- Все запросы организуются в очередь **FIFO**
- Запросы обслуживаются в **порядке поступления**

#### Характеристики
**Преимущества:**
- **Прост** в реализации
- **Справедлив** — гарантирует отсутствие голодания

**Недостатки:**
- Может приводить к **большим общим временам** обслуживания запросов
- **Не оптимизирует** перемещение головок

#### Пример
**Условия:**
- Диск из **100 цилиндров** (от 0 до 99)
- Очередь запросов: **23, 67, 55, 14, 31, 7, 84, 10**
- Головки в начальный момент на **цилиндре 63**

**Последовательность перемещений:**
```
63 → 23 → 67 → 55 → 14 → 31 → 7 → 84 → 10
```

**Суммарное перемещение:**
40 + 44 + 12 + 41 + 17 + 24 + 77 + 74 = **329 цилиндров**

### Алгоритм SSTF (Shortest Seek Time First)
#### Описание
**Короткое время поиска — первым**
Для очередного обслуживания выбирается запрос, данные для которого лежат **наиболее близко** к текущему положению магнитных головок.

#### Обработка равноудалённых запросов
При наличии **равноудалённых запросов** решение может приниматься:
- По алгоритму **FCFS**
- По другим критериям (например, направление движения)

#### Характеристики
**Преимущества:**
- Уменьшает **суммарное перемещение** головок
- **Увеличивает пропускную способность**

**Недостатки:**
- Возможно **голодание** (starvation) для удалённых запросов
- Может быть **несправедливым**

#### Пример
**Условия:** те же (диск 0-99, начало на 63, запросы: 23, 67, 55, 14, 31, 7, 84, 10)

**Последовательность перемещений:**
```
63 → 67 → 55 → 31 → 23 → 14 → 10 → 7 → 84
```

**Пояснение:**
- От 63: ближайший — 67 (расстояние 4)
- От 67: ближайший — 55 (расстояние 12)
- От 55: ближайший — 31 (расстояние 24)
- И так далее...

**Суммарное перемещение:**
4 + 12 + 24 + 8 + 9 + 4 + 3 + 77 = **141 цилиндр**

**Улучшение** по сравнению с FCFS: 329 → 141 (более чем в 2 раза!)

### Алгоритм SCAN (Лифт)
#### Описание
**Алгоритм "лифта"** или **"сканирования"**
Головки **постоянно перемещаются** от одного края диска до другого:
- По ходу движения **обслуживаются все встречающиеся запросы**
- По достижении края **направление движения меняется**
- Процесс повторяется

#### Пример
**Условия:** диск 0-99, начало на 63, запросы: 23, 67, 55, 14, 31, 7, 84, 10
**Направление в начале:** к **уменьшению номеров** цилиндров

**Последовательность перемещений:**
```
63 → 55 → 31 → 23 → 14 → 10 → 7 → 0 → 67 → 84
```

**Пояснение:**
1. Движемся к 0: обслуживаем 55, 31, 23, 14, 10, 7
2. Доходим до 0 (край диска)
3. Меняем направление
4. Движемся к 99: обслуживаем 67, 84

**Суммарное перемещение:**
8 + 24 + 8 + 9 + 4 + 3 + 7 + 67 + 17 = **147 цилиндров**

#### Характеристики
**Преимущества:**
- **Предсказуемое** время ожидания
- **Нет голодания** — каждый запрос будет обслужен
- **Хорошая производительность**

**Недостатки:**
- Неравномерная плотность обслуживания (края диска посещаются реже)

### Алгоритм LOOK
#### Описание
**Модификация SCAN** — "смотрим вперёд"

Если **обслужили последний попутный запрос** в направлении движения:
- **Не доходим до края** диска
- **Сразу изменяем направление** движения на обратное

#### Пример
**Условия:** те же

**Последовательность перемещений:**
```
63 → 55 → 31 → 23 → 14 → 10 → 7 → 67 → 84
```

**Пояснение:**
- После обслуживания 7 (последний запрос в направлении к 0)
- **Не идём до 0**, а сразу разворачиваемся
- Движемся к 67, затем к 84

**Суммарное перемещение:**
8 + 24 + 8 + 9 + 4 + 3 + 60 + 17 = **133 цилиндра**

**Улучшение** по сравнению с SCAN: 147 → 133
#### Характеристики
**Преимущества:**
- Все преимущества SCAN
- **Меньшее перемещение** головок
- **Более эффективен**, чем SCAN

### Алгоритм C-SCAN (Circular SCAN)
#### Описание
**Циклическое сканирование**

**Проблема SCAN:**
К моменту изменения направления движения головки у края диска может накопиться **большое количество новых запросов**. Запросы на другом краю диска будут ждать **несправедливо долго**.

**Решение C-SCAN:**
1. Головка движется от одного края к другому, обслуживая запросы
2. При достижении края головка **без чтения попутных запросов** перемещается на другой край
   - Перемещение часто **существенно быстрее** обычного поиска
3. С другого края снова начинает движение в том же направлении

#### Пример
**Условия:** те же

**Последовательность перемещений:**
```
63 → 55 → 31 → 23 → 14 → 10 → 7 → 0 → 99 → 84 → 67
```

**Пояснение:**
1. Движемся к 0: обслуживаем 55, 31, 23, 14, 10, 7
2. Доходим до 0
3. **Быстро перемещаемся** к 99 (без обслуживания)
4. Обслуживаем 84, 67

**Суммарное перемещение:**
8 + 24 + 8 + 9 + 4 + 3 + 7 + 99 + 15 + 17 = **194 цилиндра**

#### Характеристики
**Преимущества:**
- **Более равномерное** время ожидания
- **Справедливее** для всех запросов
- Уменьшает **дисперсию** времени ожидания

**Недостатки:**
- Большее суммарное перемещение по сравнению с SCAN/LOOK

### Алгоритм C-LOOK
#### Описание

**Комбинация идей C-SCAN и LOOK**
По аналогии с LOOK для алгоритма C-SCAN:
- **Не доходим до края** диска при движении
- После обслуживания последнего запроса в направлении движения
- **Быстро перемещаемся** к самому удалённому запросу в противоположном направлении
- Начинаем обслуживание оттуда

#### Пример
**Условия:** те же
**Последовательность перемещений:**
```
63 → 55 → 31 → 23 → 14 → 10 → 7 → 84 → 67
```

**Пояснение:**
1. Движемся к 0: обслуживаем 55, 31, 23, 14, 10, 7
2. После 7 (последний запрос в этом направлении)
3. **Быстро перемещаемся** к 84 (самый удалённый в противоположном направлении)
4. Обслуживаем 84, затем 67

**Суммарное перемещение:**
8 + 24 + 8 + 9 + 4 + 3 + 77 + 17 = **150 цилиндров**

#### Характеристики
**Преимущества:**
- Преимущества C-SCAN (справедливость)
- Меньшее перемещение по сравнению с C-SCAN

### Сравнение алгоритмов

| Алгоритм | Перемещение (цилиндров) | Справедливость     | Сложность |
| -------- | ----------------------- | ------------------ | --------- |
| FCFS     | 329                     | Высокая            | Низкая    |
| SSTF     | 141                     | Низкая (голодание) | Низкая    |
| SCAN     | 147                     | Высокая            | Средняя   |
| LOOK     | 133                     | Высокая            | Средняя   |
| C-SCAN   | 194                     | Очень высокая      | Средняя   |
| C-LOOK   | 150                     | Очень высокая      | Средняя   |
